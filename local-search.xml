<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(2)</title>
    <link href="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/"/>
    <url>/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda基础知识">CUDA基础知识</h2><span id="more"></span><h3 id="并行计算与串行计算">并行计算与串行计算</h3><p>对于计算密集型任务，当我们有很多计算核心时，每次只调用其中的一个核心进行一次计算任务，这时很浪费的，而这恰恰正式上一节中编写的程序的工作模式。而为了提高计算单元的效率，我们需要将串行工作模式改成并行计算模式，而这就需要用到CUDA和其API接口。</p><h3 id="cuda的基本概念">CUDA的基本概念</h3><p>由于GPU存在成千上万个廉价的计算单元，如果我们能将一个计算任务分解成多个子任务，这样就可以用GPU来完成并行计算，下面来介绍一下在并行计算中的规划方法。</p><p>CUDA引用了<strong>单指令多线程</strong>的并行模式(即每个线程执行相同的数据计算，然后使用一条指令控制从而减少控制器数目和系统复杂度--设想成千上万的线程各自做不同的事情，如果再有线程间通讯/同步，将会是怎样的梦魇)，GPU中包含大量的基础计算单元，称为<strong>核</strong>，每个核都包含了一个逻辑计算单元和一个浮点计算单元，多个核集成在一起被称为<strong>多流处理器</strong>。</p><img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic1.png" class=""><p>而将每个计算任务分解成多个子任务，称为<strong>线程</strong>，多个线程被组织成<strong>线程块</strong>，线程块被分解成大小与一个SM中核数量相同的<strong>线程束</strong>，每个线程束由一个SM负责执行，这些多流处理器的控制单元指挥其他所有核同时在一个线程束的每个线程中执行同一个指令，这是单指令多线程的来源。</p><h3 id="gpu与cpu对比">GPU与CPU对比</h3><p>众所周知，CPU也是可以执行并行计算的，那两者有什么区别呢？</p><p>首先，CPU是通用计算单元，其核心数目比较少，但是具备处理能力较强，同时其芯片上大部分空间是被设计成用于加速IO的高速缓存。而GPU拥有大量的能力稍弱的核，且每次都是使用一堆核做相同的计算(并不是做一摸一样的计算，而是做类型一样的计算，比如都是加法这样，这是更大的计算任务中的一小部分)，与CPU另一个不同之处在于GPU倾向于延迟隐藏，由于GPU上没有很多高速缓存，因此当一个线程束需要的数据不可达时，SM会转向去处理另一个线程束(挂起)。</p><h3 id="cuda计算任务流程">CUDA计算任务流程</h3><p>GPU计算中的关键结构是<strong>核函数</strong>，其产生大量组织成可以分配给SM的计算线程。</p><p>因此在计算时，需要加载核函数来创建一个由多个线程块组成的<strong>线程网格</strong>，同一个网格上的线程共享相同的全局内存空间，每个网格内有很多线程块，而每个线程块由多个线程组成。</p><p>一个线程块只会由一个SM来调度，但是一个SM可以调度多个线程块。另外由于SM的资源是有限的，所以其调用线程是由上限的。</p><img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic1.png" class=""><h3 id="核函数">核函数</h3><p>上面说了核函数是计算的关键函数，下面就来了解一下核函数怎么写。</p><h4 id="核函数的声明与标识符">核函数的声明与标识符</h4><p>由于GPU是一个外部设备，因此每个函数都需要指明这个函数是在主机上调用(CPU)还是在外部设备上调用(GPU)，并根据调用来编译出不同的代码。</p><p>为了告知编译器在哪个设备上编译，就需要额外引入标识符，有以下三种标识符</p><ul><li><p>__global__：在CPU调用父函数，子函数在GPU执行(异步)。用__global__修饰的一般就是内核(kernel)函数。</p></li><li><p>__device__：在GPU调用父函数，子函数在GPU执行。由__device__修饰的函数可以被由__global__和__device__修饰的函数调用，这种情况是动态并行。</p></li><li><p>__host__：在CPU调用父函数，子函数在CPU执行（这是默认的标识符）。</p></li></ul><span class="label label-info">用__host__与__device__修饰的函数将同时在主机核设备上被编译。</span><div class="note note-primary">            <p>一般来说，我们只需要2个修饰词就够了，但是cuda却提供了3个——2个执行位置为GPU。这儿要引入一个“函数执行环境标识符”的概念。父函数调用子函数时，父函数可能运行于CPU或者GPU，相应的子函数也可能运行于CPU或者GPU，但是这绝不是一个2*2的组合关系。因为GPU作为CPU的计算组件，不可以调度CPU去做事，所以不存在父函数运行于GPU，而子函数运行于CPU的情况。</p>          </div><p>另外，核函数不能带有返回值，因此返回类型通常为void，以及在GPU上的核函数是不能访问主机端CPU可以访问的内存数据。</p><p>给出一个声明实例<code>__global__ void run_on_gpu()</code></p><h4 id="核函数的调用">核函数的调用</h4><p>核函数是一种特殊的函数，调用核函数从一个函数名开始，然后以一个包含逗号分割的参数列表，其中网格维度核线程块维度被放在参数列表中(三个尖括号，这是编译器扩展后的)。</p><p>形如<code>aKernal &lt;&lt;&lt;2, 2 &gt;&gt;&gt; ();</code></p><h4 id="一个示例">一个示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function">__host__ __device__ <span class="hljs-type">int</span> <span class="hljs-title">run_on_cpu_or_gpu</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">run_on_gpu</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"run_on_cpu_or_gpu GPU: %d\n"</span>, <span class="hljs-built_in">run_on_cpu_or_gpu</span>());<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"run_on_cpu_or_gpu CPU: %d\n"</span>, <span class="hljs-built_in">run_on_cpu_or_gpu</span>());<br>run_on_gpu &lt;&lt; &lt;<span class="hljs-number">2</span>, <span class="hljs-number">2</span> &gt;&gt; &gt; ();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(1)</title>
    <link href="/2022/09/04/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1/"/>
    <url>/2022/09/04/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda初步探究">CUDA初步探究</h2><span id="more"></span><h3 id="什么是cuda">什么是CUDA</h3><p>CUDA，即Compute Unified DeviceArchitecture的简称，是由NVIDIA公司创立的基于他们公司生产的图形处理器GPUs的一个并行计算平台和编程模型。</p><p>通过CUDA，GPUs可以很方便地被用来进行通用计算（有点像在CPU中进行的数值计算等等）。在没有CUDA之前，GPUs一般只用来进行图形渲染（如通过OpenGL，DirectX）。<br>开发人员可以通过调用CUDA的API，来进行并行编程，达到高性能计算目的。NVIDIA公司为了吸引更多的开发人员，对CUDA进行了编程语言扩展，如CUDAC/C++,CUDA Fortran语言。注意CUDAC/C++可以看作一个新的编程语言，因为NVIDIA配置了相应的编译器nvcc,CUDAFortran一样。更多信息可以参考文献。</p><div class="note note-primary">            <p>本系列的博客跳过了CUDA环境的安装，如果有需要，请自行查阅相关教程，这方面资料还是很多的。</p><p>另外，本博客的环境是基于CUDA10.2，VS2017，windows10下的。</p>          </div><h3 id="运行cuda的样例">运行CUDA的样例</h3><p>首先先找到CUDA的安装目录（本机是<code>C:\Program Files\NVIDIA GPU Computing Toolkit</code>），然后进入<code>extras/demo_suite</code>目录，就能看到已经编译好的样例程序。</p><p>我们运行<code>nbody.exe</code>，这是一个模拟上千个受到万有引力的粒子运动并进行可视化的程序。可以在控制台中进行调整参数，这个程序还有很炫酷的。</p><p>除了<code>nbody.exe</code>，这个目录下还有其他的一些例程可以运行，同样的，还有一些未被编译的例程，可以手动去编译。</p><h3 id="编写一个串行程序">编写一个串行程序</h3><p>我们首先使用传统方式来写一个计算一个点到一条直线上若干点的距离的程序。</p><p>这个简单的cpp程序使用了一个for循环，先对循环变量进行归一化处理，然后计算并存储与参考位置的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> out[N] = { <span class="hljs-number">0.0f</span> };<br><span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br><span class="hljs-type">float</span> x = <span class="hljs-built_in">scale</span>(i, N);<br>out[i] = <span class="hljs-built_in">distance</span>(x, ref);<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; i : out)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f "</span>, i);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></table></figure><p>接下来我们使用另外一种方式来编写这个程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">distanceArray</span><span class="hljs-params">(<span class="hljs-type">float</span> * out, <span class="hljs-type">float</span> * in, <span class="hljs-type">float</span> ref, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>{<br>out[i] = <span class="hljs-built_in">distance</span>(i, n);<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> * in = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-type">float</span> * out = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br>in[i] = <span class="hljs-built_in">scale</span>(i, N);<br>}<br><br><span class="hljs-built_in">distanceArray</span>(out, in, ref, N);<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;N;i++)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f "</span>, out[i]);<br>}<br><br><span class="hljs-built_in">free</span>(in);<br><span class="hljs-built_in">free</span>(out);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>我们来重新审视一下这两个程序，这两个程序都是使用串行的方式处理的，即每次处理一个数值，只是两个的写法不一样。</p><ul><li><p>第一个程序是在mian函数中手动处理每个点</p></li><li><p>而第二个程序则是提供了一个统一的抽象接口，mian函数只需要一次调用这个函数就能计算出所有的值</p></li></ul><p>表面上看这两个程序没有本质的区别，但是其标志性的指出了并行程序的编写思路：<strong><em>提供数据并调用接口，一次性获得所有的结果</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(5)</title>
    <link href="/2022/09/02/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/"/>
    <url>/2022/09/02/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/</url>
    
    <content type="html"><![CDATA[<h2 id="文件和io----来源于cookbook第五章">文件和IO----来源于cookbook第五章</h2><span id="more"></span><p><font color="#a0add0">记录第五章中比较有意思的部分</font></p><hr><h3 id="open函数打开文件的小技巧">open函数打开文件的小技巧</h3><div class="note note-primary">            <p>由于有些文件中会出现编码错误或与当前主机不匹配，使用<code>open</code>函数时可以增加<code>errors='ignore'</code>来忽略掉错误的编码。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>g = <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile.txt"</span>, <span class="hljs-string">'rt'</span>, encoding = <span class="hljs-string">'utf-8'</span>, errors = <span class="hljs-string">'ignore'</span>)<br><br></code></pre></td></tr></table></figure><h3 id="使用print函数重定向到文件">使用print函数重定向到文件</h3><div class="note note-primary">            <p>使用<code>print</code>函数的<code>file = handler</code>参数即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'3'</span>,(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"file"</span>,<span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(*l, sep = <span class="hljs-string">','</span>, file = f)<br><br></code></pre></td></tr></table></figure><h3 id="对不存在的文件进行写入操作">对不存在的文件进行写入操作</h3><div class="note note-primary">            <p>直接使用<code>xt</code>模式来操作文件即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile"</span>, <span class="hljs-string">'wt'</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 当somefile不存在时会报错</span><br>    ...<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile"</span>, <span class="hljs-string">'xt'</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 当somefile不存在时会创建，存在时不影响</span><br>    ...<br><br></code></pre></td></tr></table></figure><h3 id="将二进制文件做内存映射">将二进制文件做内存映射</h3><div class="note note-primary">            <p>使用<code>mmap</code>模块来创建映射，这样可以直接访问，而不需要频繁的seek、read等操作。</p><p>另外，由于虚拟内存的存在，多个python解释器可以映射到同一个文件上从而实现共享数据。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> mmap<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">memory_map</span>(<span class="hljs-params">filename, access = mmap.ACCESS_WRITE</span>):<br>    size = os.path.getsize(filename)<br>    fd = os.<span class="hljs-built_in">open</span>(filename, os.O_RDWR)<br>    <span class="hljs-keyword">return</span> mmap.mmap(fd, size, access = access)<br><br>m = memory_map(<span class="hljs-string">"data"</span>)<br><br><span class="hljs-comment"># 此时就可以像操作数组那样操作m</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(m))<br><span class="hljs-built_in">print</span>(m[:<span class="hljs-number">34</span>])<br>m[:<span class="hljs-number">11</span>] = <span class="hljs-string">b'hello world'</span><br>m.close()<br><br></code></pre></td></tr></table></figure><h3 id="将字节数据写入文本文件">将字节数据写入文本文件</h3><div class="note note-primary">            <p>只需要简答的将字节数据写入到文件底层buffer中就可以了。</p>          </div><div class="note note-warning">            <p>在python中调用print时，事实上调用了sys.stdout.write(obj+'\n')</p><p>而stdout就像是一个类文件对象，因为你可以将他赋值给任意的一个文件对象，重定向输出</p><p>原始的sys.stdout指向控制台，如果把文件的对象引用赋给sys.stdout，那么print调用的就是文件对象的write方法</p><p>而buffer是缓冲区，所以此操作就是不调用上层的write方法而直接写入底层的缓冲区</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 示例一</span><br><br><span class="hljs-keyword">import</span> sys<br><br>sys.stdout.buffer.write(<span class="hljs-string">b'hello\n'</span>)<br><br><br><span class="hljs-comment"># 示例二</span><br><br><span class="hljs-keyword">import</span> sys<br><br>sys.stdout = <span class="hljs-built_in">open</span>(<span class="hljs-string">"filename"</span>,<span class="hljs-string">"xt"</span>)<br><br>sys.stdout.buffer.write(<span class="hljs-string">b'hello\n'</span>)<br><br></code></pre></td></tr></table></figure><h3 id="创建临时文件与文件夹">创建临时文件与文件夹</h3><div class="note note-primary">            <p><code>tempfile</code>模块中有各种实现了上下文管理协议的函数来处理临时文件</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> tempfile <span class="hljs-keyword">import</span> TemporaryFile<br><br><span class="hljs-keyword">with</span> TemporaryFile(<span class="hljs-string">'w+t'</span>, encoding = <span class="hljs-string">'utf-8'</span>, errors = <span class="hljs-string">'ignore'</span>, delete = <span class="hljs-literal">True</span>):<br>    ...<br><br></code></pre></td></tr></table></figure><h3 id="序列化python对象">序列化python对象</h3><div class="note note-primary">            <p><code>pickle</code>模块的dump和load函数就足以处理这些</p>          </div><div class="note note-warning">            <p>注意不要对来源不明的对象进行load，因为这会产生副作用，严重甚至可能导致计算机被入侵。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> pickle<br><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"filename"</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(a,f)<br>    ...<br>    pickle.load(a,f)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webbench源码剖析</title>
    <link href="/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="webbench源码剖析">Webbench源码剖析</h2><span id="more"></span><p><a href="https://github.com/EZLippi/WebBench">项目地址</a></p><h3 id="webbench介绍">Webbench介绍</h3><div class="note note-primary">            <p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。</p><p>而其源码也相当的短，只有500行，读起来非常容易。</p>          </div><p>不过本项目虽然代码量很小，但是最好熟悉unix网络编程，以及linux下C语言多线程的实现(fork()函数)，否则可能看起来会比较吃力。</p><p>我们将代码拉下来后，可以发现，其只包含两个文件，我们首先分析代码行数较少的<code>socket.c</code>文件。</p><h3 id="socket.c源码剖析">socket.c源码剖析</h3><h4 id="文件说明">文件说明</h4><p>这个<code>socket.c</code>文件里仅有一个函数<code>int Socket(const char *host, int clientPort)</code>，这是对socket的一层封装，可以解析以字符串传入的<code>url地址</code>和<code>端口</code>，并返回一个指向服务器的socket套接字用于连接。</p><h4 id="函数工作流程">函数工作流程</h4><div class="note note-primary">            <ol type="1"><li><p>首先准备好必须的参数并对其进行初始化。</p></li><li><p>先将主机名转换成ip并存储（包括本身就是ip的主机和通过dns解析主机两部分）</p></li><li><p>根据主机IP和端口创建socket套接字</p></li><li><p>执行一次连接，如果连接成功就返回这个套接字，否则返回错误码</p></li></ol>          </div><h4 id="源码">源码</h4><p>这部分源码相对比较简单，主要懂一些linux下网络编程就不难看懂了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-comment">// host是目标主机名，clientPort为端口</span><br><span class="hljs-comment">// 建立与目标的TCP连接，返回客户端连接使用的套接字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Socket</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">int</span> clientPort)</span><br>{<br><br>    <span class="hljs-type">int</span> sock;              <span class="hljs-comment">// 本地套接字标识符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> inaddr;  <span class="hljs-comment">// 主机ip的数字形式（32位）</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ad</span>;</span> <span class="hljs-comment">// 处理网络通信套接字地址结构，存储地址族、套接字端口号、ip地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">hp</span>;</span>    <span class="hljs-comment">// 存储了主机名、主机别名、ip及其类型、长度等，是gethostbyname返回值</span><br><br>    <span class="hljs-built_in">memset</span>(&amp;ad, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ad)); <span class="hljs-comment">// 初始化套接字</span><br>    ad.sin_family = AF_INET;    <span class="hljs-comment">// TCP/IP协议</span><br><br>    inaddr = inet_addr(host); <span class="hljs-comment">// 先尝试将host转换成整型（不经过dns解析的ip形式主机）</span><br>    <span class="hljs-keyword">if</span> (inaddr != INADDR_NONE)<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="hljs-keyword">sizeof</span>(inaddr)); <span class="hljs-comment">// 成功则保存转换结果</span><br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 否则需要先经过dns解析</span><br>        hp = gethostbyname(host); <span class="hljs-comment">// hp是存储解析结果的结构体</span><br>        <span class="hljs-keyword">if</span> (hp == <span class="hljs-literal">NULL</span>)           <span class="hljs-comment">// 解析失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length); <span class="hljs-comment">// 解析成功同样需要保存整型结构的IP地址</span><br>    }<br>    ad.sin_port = htons(clientPort); <span class="hljs-comment">// htons是将整型变量从主机字节顺序转变成网络字节顺序</span><br><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// 创建套接字</span><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> sock; <span class="hljs-comment">// 创建失败</span><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ad, <span class="hljs-keyword">sizeof</span>(ad)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 创建成功但是不能连接成功也认为是失败</span><br>    <span class="hljs-keyword">return</span> sock;<br>}<br><br></code></pre></td></tr></table></figure><h3 id="webbench.c源码剖析">webbench.c源码剖析</h3><h4 id="文件说明-1">文件说明</h4><p>这个<code>webbench.c</code>文件是这个项目中最重要的文件，所有的处理操作都在这个文件中执行。</p><p>在这个文件头处可以看到可能令人疑惑的地方，在一行有一句<code>#include "socket.c"</code>，也就是把另一个.c文件给include进来了，但一般我们include都是.h文件。</p><p>其实在c语言中<code>#</code>开头的指令是预处理指令，我们知道，c语言进行编译的第一步就是预处理，而<code>include</code>指令就是把include后紧跟的文件原封不动的插入进来，而不做改变。而平时我们不这么做的原因就是当多个文件都include一个.c文件时，这个.c文件内的函数会被重定义。但这个项目就两个文件，所以不用考虑那么多。</p><div class="note note-info">            <p><strong><em>关于预处理</em></strong></p><p>在linux环境下执行<code>gcc -E webbench.c &gt; result.txt</code>就能看到预处理结果，当然为了便于观察，可以把除了<code>#include "socket.c"</code>的所有其他头文件都注释掉。</p>          </div><h4 id="源码-1">源码</h4><p>由于这个文件比较大，所以分函数来进行展示</p><p>先来看头文件部分和全局变量部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"socket.c"</span></span><br><span class="hljs-comment">// 这里include了一个.c文件可能会令人费解，但是理解C语言的编译过程就容易看懂了</span><br><span class="hljs-comment">// #include是一个预处理指令，在预处理过程中会用"socket.c"的内容来替换这个预处理</span><br><span class="hljs-comment">// 所以相当于完成了两个.c文件的拼接，等效于将"socket.c"直接写在这个文件前面</span><br><span class="hljs-comment">// 平时之所以不这样用是因为可能出现重定义的现象</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/param.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;getopt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> timerexpired = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计时器是否到期，到期为1，未到期为0</span><br><span class="hljs-type">int</span> speed = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 记录速度</span><br><span class="hljs-type">int</span> failed = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 记录失败次数</span><br><span class="hljs-type">int</span> bytes = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//记录传输的数据量</span><br><br><span class="hljs-type">int</span> http10 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0 - http/0.9, 1 - http/1.0, 2 - http/1.1</span><br><br><span class="hljs-comment">// 定义了http的方法和全局配置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_GET 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_HEAD 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_OPTIONS 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_TRACE 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROGRAM_VERSION <span class="hljs-string">"1.5"</span></span><br><span class="hljs-type">int</span> method = METHOD_GET; <span class="hljs-comment">// 默认请求方法</span><br><span class="hljs-type">int</span> clients = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 客户端连接数目</span><br><span class="hljs-type">int</span> force = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 是否不等待服务器响应，发送请求后直接关闭连接</span><br><span class="hljs-type">int</span> force_reload = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 是否强制代理服务器重新发送请求</span><br><span class="hljs-type">int</span> proxyport = <span class="hljs-number">80</span>;      <span class="hljs-comment">// 代理端口</span><br><span class="hljs-type">char</span> *proxyhost = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 代理地址</span><br><span class="hljs-type">int</span> benchtime = <span class="hljs-number">30</span>;      <span class="hljs-comment">// 持续时间</span><br><br><span class="hljs-comment">// 网络相关的变量</span><br><span class="hljs-type">int</span> mypipe[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 读写管道，0为读取端，1为写入端</span><br><span class="hljs-type">char</span> host[MAXHOSTNAMELEN];  <span class="hljs-comment">// 保存主机的字符串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REQUEST_SIZE 2048   <span class="hljs-comment">// 请求的最大长度</span></span><br><span class="hljs-type">char</span> request[REQUEST_SIZE]; <span class="hljs-comment">// 请求内容</span><br><br><span class="hljs-comment">// 静态数组，用于记录各个选项的需要求参数</span><br><span class="hljs-comment">// no_argument表示选项没有参数，required_argument表示选项需要参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">long_options</span>[] =</span><br>    {<br>        {<span class="hljs-string">"force"</span>, no_argument, &amp;force, <span class="hljs-number">1</span>},<br>        {<span class="hljs-string">"reload"</span>, no_argument, &amp;force_reload, <span class="hljs-number">1</span>},<br>        {<span class="hljs-string">"time"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'t'</span>},<br>        {<span class="hljs-string">"help"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'?'</span>},<br>        {<span class="hljs-string">"http09"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'9'</span>},<br>        {<span class="hljs-string">"http10"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'1'</span>},<br>        {<span class="hljs-string">"http11"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'2'</span>},<br>        {<span class="hljs-string">"get"</span>, no_argument, &amp;method, METHOD_GET},<br>        {<span class="hljs-string">"head"</span>, no_argument, &amp;method, METHOD_HEAD},<br>        {<span class="hljs-string">"options"</span>, no_argument, &amp;method, METHOD_OPTIONS},<br>        {<span class="hljs-string">"trace"</span>, no_argument, &amp;method, METHOD_TRACE},<br>        {<span class="hljs-string">"version"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'V'</span>},<br>        {<span class="hljs-string">"proxy"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'p'</span>},<br>        {<span class="hljs-string">"clients"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'c'</span>},<br>        {<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>}};<br><br><span class="hljs-comment">/* prototypes */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *request)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                     <span class="hljs-comment">// 执行压力测试的入口函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span>; <span class="hljs-comment">// 构造请求</span><br><br></code></pre></td></tr></table></figure><p>前面这里就是定义了一些用到的宏和全局变量。</p><p>接下来我们来分析三个辅助函数，一个是用于设置定时器过期，一个用于显示帮助信息，另一个用于构造请求头。</p><p>其中，构造请求头的函数看起来稍微有些复杂，但是其实就是一些逻辑处理，然后根据http协议的定义手动构造出了请求体并保存在全局变量里面，这并不是我们分析的重点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 静态函数，用于信号处理，用于设置定时器过期</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">alarm_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span><br>{<br>    timerexpired = <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">// 返回帮助信息的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-comment">// printf == fprintf(stdout, ...)</span><br>    <span class="hljs-comment">// 不过fprintf的功能更强大，支持重定向</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>            <span class="hljs-string">"webbench [option]... URL\n"</span><br>            <span class="hljs-string">"  -f|--force               Don't wait for reply from server.\n"</span><br>            <span class="hljs-string">"  -r|--reload              Send reload request - Pragma: no-cache.\n"</span><br>            <span class="hljs-string">"  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n"</span><br>            <span class="hljs-string">"  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n"</span><br>            <span class="hljs-string">"  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n"</span><br>            <span class="hljs-string">"  -9|--http09              Use HTTP/0.9 style requests.\n"</span><br>            <span class="hljs-string">"  -1|--http10              Use HTTP/1.0 protocol.\n"</span><br>            <span class="hljs-string">"  -2|--http11              Use HTTP/1.1 protocol.\n"</span><br>            <span class="hljs-string">"  --get                    Use GET request method.\n"</span><br>            <span class="hljs-string">"  --head                   Use HEAD request method.\n"</span><br>            <span class="hljs-string">"  --options                Use OPTIONS request method.\n"</span><br>            <span class="hljs-string">"  --trace                  Use TRACE request method.\n"</span><br>            <span class="hljs-string">"  -?|-h|--help             This information.\n"</span><br>            <span class="hljs-string">"  -V|--version             Display program version.\n"</span>);<br>}<br><br><span class="hljs-comment">// 构造请求头的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span><br>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    build_request的执行过程</span><br><span class="hljs-comment">    就是根据请求方式、http协议版本等等信息来构造处http的报文</span><br><span class="hljs-comment">    且这个报文是全局变量</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-type">char</span> tmp[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 先把保存主机的请求体部分的地址区域清空</span><br>    <span class="hljs-built_in">memset</span>(host, <span class="hljs-number">0</span>, MAXHOSTNAMELEN);<br>    <span class="hljs-built_in">memset</span>(request, <span class="hljs-number">0</span>, REQUEST_SIZE);<br><br>    <span class="hljs-comment">// 然后根据选项来判断请求的http协议版本</span><br>    <span class="hljs-keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="hljs-literal">NULL</span> &amp;&amp; http10 &lt; <span class="hljs-number">1</span>)<br>        http10 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_HEAD &amp;&amp; http10 &lt; <span class="hljs-number">1</span>)<br>        http10 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_OPTIONS &amp;&amp; http10 &lt; <span class="hljs-number">2</span>)<br>        http10 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_TRACE &amp;&amp; http10 &lt; <span class="hljs-number">2</span>)<br>        http10 = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 然后开始正式构造请求体</span><br>    <span class="hljs-comment">// 不过u1s1，这部分自己手动构造真是痛苦</span><br>    <span class="hljs-keyword">switch</span> (method)<br>    {<br>    <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">case</span> METHOD_GET: <span class="hljs-comment">// get请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"GET"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_HEAD: <span class="hljs-comment">// head请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"HEAD"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_OPTIONS: <span class="hljs-comment">// options请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"OPTIONS"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_TRACE: <span class="hljs-comment">// trace请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"TRACE"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" "</span>);<br><br>    <span class="hljs-comment">// 处理url地址，做一些错误检测，而且不支持https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == <span class="hljs-built_in">strstr</span>(url, <span class="hljs-string">"://"</span>))<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\n%s: is not a valid URL.\n"</span>, url);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(url) &gt; <span class="hljs-number">1500</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"URL is too long.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != strncasecmp(<span class="hljs-string">"http://"</span>, url, <span class="hljs-number">7</span>))<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nOnly HTTP protocol is directly supported, set --proxy for others.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br><br>    <span class="hljs-comment">// 计算出url去掉协议头的部分</span><br>    i = <span class="hljs-built_in">strstr</span>(url, <span class="hljs-string">"://"</span>) - url + <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 要求结尾以/来结尾，不知道为啥</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">'/'</span>) == <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nInvalid URL syntax - hostname don't ends with '/'.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br><br>    <span class="hljs-comment">// 处理使用代理的情况</span><br>    <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-comment">// 这种硬编码的东西看起来有点痛苦，就不考虑细节了</span><br>        <span class="hljs-keyword">if</span> (index(url + i, <span class="hljs-string">':'</span>) != <span class="hljs-literal">NULL</span> &amp;&amp; index(url + i, <span class="hljs-string">':'</span>) &lt; index(url + i, <span class="hljs-string">'/'</span>))<br>        {<br>            <span class="hljs-built_in">strncpy</span>(host, url + i, <span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">':'</span>) - url - i);<br>            <span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>            <span class="hljs-built_in">strncpy</span>(tmp, index(url + i, <span class="hljs-string">':'</span>) + <span class="hljs-number">1</span>, <span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">'/'</span>) - index(url + i, <span class="hljs-string">':'</span>) - <span class="hljs-number">1</span>);<br>            proxyport = atoi(tmp);<br>            <span class="hljs-keyword">if</span> (proxyport == <span class="hljs-number">0</span>)<br>                proxyport = <span class="hljs-number">80</span>;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-built_in">strncpy</span>(host, url + i, <span class="hljs-built_in">strcspn</span>(url + i, <span class="hljs-string">"/"</span>));<br>        }<br>        <span class="hljs-built_in">strcat</span>(request + <span class="hljs-built_in">strlen</span>(request), url + i + <span class="hljs-built_in">strcspn</span>(url + i, <span class="hljs-string">"/"</span>));<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-built_in">strcat</span>(request, url);<br>    }<br><br>    <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" HTTP/1.0"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" HTTP/1.1"</span>);<br><br>    <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"User-Agent: WebBench "</span> PROGRAM_VERSION <span class="hljs-string">"\r\n"</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span> &amp;&amp; http10 &gt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Host: "</span>);<br>        <span class="hljs-built_in">strcat</span>(request, host);<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br>    }<br><br>    <span class="hljs-keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Pragma: no-cache\r\n"</span>);<br>    }<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Connection: close\r\n"</span>);<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nRequest:\n%s\n"</span>, request);<br>}<br><br></code></pre></td></tr></table></figure><p>然后我们来进入main函数，main函数主要是解析选项，并构造url的请求头，然后调用bench函数来正式开始压力测试，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    main函数的处理过程就是先解析出所有的选项</span><br><span class="hljs-comment">    然后构造指向目标地址的url请求</span><br><span class="hljs-comment">    最后调用bench函数来执行压力测试</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 用于记录当前标志（其实是char）</span><br>    <span class="hljs-type">int</span> options_index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于标记当前选项处理到的索引未知</span><br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-comment">// 若如果不带任何参数执行此程序就直接退出</span><br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><br>    <span class="hljs-comment">// 否则循环解析命令</span><br>    <span class="hljs-comment">// getopt_long是解析命令的函数，此处不展开细🔒</span><br>    <span class="hljs-comment">// 就是通过这个步骤来解析所有的选项</span><br>    <span class="hljs-keyword">while</span> ((opt = getopt_long(argc, argv, <span class="hljs-string">"912Vfrt:p:c:?h"</span>, long_options, &amp;options_index)) != EOF)<br>    {<br>        <span class="hljs-keyword">switch</span> (opt)<br>        {<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:<br>            force = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'r'</span>:<br>            force_reload = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'9'</span>:<br>            http10 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:<br>            http10 = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'2'</span>:<br>            http10 = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'V'</span>:<br>            <span class="hljs-built_in">printf</span>(PROGRAM_VERSION <span class="hljs-string">"\n"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>:<br>            benchtime = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'p'</span>:<br>            <span class="hljs-comment">/* proxy server parsing server:port */</span><br>            <span class="hljs-comment">// 由于代理是server:port的格式</span><br>            <span class="hljs-comment">// 所以先查找处:的位置</span><br>            <span class="hljs-comment">// strrchr就是查找并返回指向:字符的指针</span><br>            tmp = <span class="hljs-built_in">strrchr</span>(optarg, <span class="hljs-string">':'</span>);<br>            proxyhost = optarg;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)<br>            {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (tmp == optarg)<br>            {<br>                <span class="hljs-comment">// 没有主机，即字符串是:....的形式</span><br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in option --proxy %s: Missing hostname.\n"</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (tmp == optarg + <span class="hljs-built_in">strlen</span>(optarg) - <span class="hljs-number">1</span>)<br>            {<br>                <span class="hljs-comment">// 没有端口，即字符串是...:的形式</span><br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in option --proxy %s Port number is missing.\n"</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            }<br>            <span class="hljs-comment">// 由于tmp指向了冒号，所以把冒号置'\0'就完成了分割操作</span><br>            *tmp = <span class="hljs-string">'\0'</span>;<br>            <span class="hljs-comment">// 然后获取端口号</span><br>            proxyport = atoi(tmp + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'h'</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:<br>            usage();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'c'</span>:<br>            <span class="hljs-comment">// atoi是把字符串转换成整型</span><br>            clients = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (optind == argc)<br>    {<br>        <span class="hljs-comment">// 最后一个被opt处理的选项与全部选项等长，就说明没有网址</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"webbench: Missing URL!\n"</span>);<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><br>    <span class="hljs-comment">// 修改默认的客户端数目与时间</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">0</span>)<br>        clients = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (benchtime == <span class="hljs-number">0</span>)<br>        benchtime = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">/* Copyright */</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Webbench - Simple Web Benchmark "</span> PROGRAM_VERSION <span class="hljs-string">"\n"</span><br>                    <span class="hljs-string">"Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n"</span>);<br><br>    <span class="hljs-comment">// 构造请求，存储在全局变量char request[REQUEST_SIZE]</span><br>    <span class="hljs-comment">// optind指向下一个未处理的字符串的索引</span><br>    <span class="hljs-comment">// 因此./webbench -c 5 -t 1 http://www.baidu.com/ wrong会被正常处理</span><br>    <span class="hljs-comment">// 而./webbench -c 5 -t 1 wrong http://www.baidu.com/ 不会被正常处理</span><br>    build_request(argv[optind]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Runing info: "</span>);<br><br>    <span class="hljs-comment">// 打印连接日志，为毛要写成这个样子？？</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 client"</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d clients"</span>, clients);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">", running %d sec"</span>, benchtime);<br><br>    <span class="hljs-keyword">if</span> (force)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", early socket close"</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", via proxy server %s:%d"</span>, proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (force_reload)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", forcing reload"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">".\n"</span>);<br><br>    <span class="hljs-comment">//调用bench函数，开始压力测试，bench() 为压力测试核心代码</span><br>    <span class="hljs-keyword">return</span> bench();<br>}<br><br></code></pre></td></tr></table></figure><p>然后我们分析用于作为测试入口的bench函数。</p><p>这个函数内是使用fork创建出子进程，同时分配管道用于主进程与子进程之间通信，最后还设定了主进程的逻辑为从管道中不断读取子进程的数据并汇总。</p><p>这里我们可以学到一点：<strong>所有需要处理的东西全部由子进程去做，主进程只负责汇总或打印报告之类的，这样处理的时候子进程崩了也不影响主进程</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 正式开始压力测试的入口函数，主要用于创建子进程、管道，以及主进程从管道中读取数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-number">0</span>;<br>    FILE *f;<br><br>    <span class="hljs-comment">// 构造一个socket套接字</span><br>    i = Socket(proxyhost == <span class="hljs-literal">NULL</span> ? host : proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nConnect to server failed. Aborting benchmark.\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br><br>    <span class="hljs-comment">// 关闭连接，这次连接不计入测试</span><br>    close(i);<br><br>    <span class="hljs-comment">// 创建管道，mypipe也是全局变量</span><br>    <span class="hljs-comment">// 管道用于两个进程之间数据交换</span><br>    <span class="hljs-keyword">if</span> (pipe(mypipe))<br>    {<br>        perror(<span class="hljs-string">"pipe failed."</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    }<br><br>    <span class="hljs-comment">// fork出子进程</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clients; i++)<br>    {<br>        pid = fork();<br><br>        <span class="hljs-keyword">if</span> (pid &lt;= (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 如果是子进程或者创建失败，休眠1s后退出循环，</span><br>            <span class="hljs-comment">// 让父进程先执行，完成初始化（因为创建子进程是很快的）</span><br>            <span class="hljs-comment">// 并且保证子进程中不会再fork出新的子进程</span><br>            <span class="hljs-comment">// 子进程不fork出新的子进程，所以总的子进程数目就很好控制了</span><br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">//主进程创建进程失败就退出</span><br>    <span class="hljs-keyword">if</span> (pid &lt; (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"problems forking worker no. %d\n"</span>, i);<br>        perror(<span class="hljs-string">"fork failed."</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (pid == (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-comment">// 子进程调用benchcore去尽可能发送请求</span><br>        <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>            benchcore(host, proxyport, request);<br>        <span class="hljs-keyword">else</span><br>            benchcore(proxyhost, proxyport, request);<br><br>        <span class="hljs-comment">// 同时写入管道</span><br>        f = fdopen(mypipe[<span class="hljs-number">1</span>], <span class="hljs-string">"w"</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        {<br>            perror(<span class="hljs-string">"open pipe for writing failed."</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        }<br><br>        <span class="hljs-comment">// 写入数据，来源于全局变量</span><br>        <span class="hljs-built_in">fprintf</span>(f, <span class="hljs-string">"%d %d %d\n"</span>, speed, failed, bytes);<br>        fclose(f);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 主进程读取管道</span><br>        f = fdopen(mypipe[<span class="hljs-number">0</span>], <span class="hljs-string">"r"</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        {<br>            perror(<span class="hljs-string">"open pipe for reading failed."</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        }<br><br>        <span class="hljs-comment">// 定义流 stream 应如何缓冲</span><br>        <span class="hljs-comment">// 设置不使用缓冲。每个I/O操作都被即时写入管道</span><br>        setvbuf(f, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 初始化主进程的变量</span><br>        speed = <span class="hljs-number">0</span>;<br>        failed = <span class="hljs-number">0</span>;<br>        bytes = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-comment">// 获取成功读取的参数个数</span><br>            pid = <span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d %d %d"</span>, &amp;i, &amp;j, &amp;k);<br>            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">2</span>)<br>            {<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Some of our childrens died.\n"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            }<br><br>            speed += i;<br>            failed += j;<br>            bytes += k;<br><br>            <span class="hljs-comment">// 客户端数减一后如果等于0，说明没有多的客户端数据读取，直接退出循环</span><br>            <span class="hljs-keyword">if</span> (--clients == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        }<br><br>        fclose(f);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n"</span>,<br>               (<span class="hljs-type">int</span>)((speed + failed) / (benchtime / <span class="hljs-number">60.0f</span>)),<br>               (<span class="hljs-type">int</span>)(bytes / (<span class="hljs-type">float</span>)benchtime),<br>               speed,<br>               failed);<br>    }<br><br>    <span class="hljs-keyword">return</span> i;<br>}<br><br></code></pre></td></tr></table></figure><p>最后是子进程发起请求的函数benchcore函数，这个函数其实逻辑也很简单，就是构造请求并发起，然后看看有没有错误，不过错误种类还挺多。</p><p>另外，这个函数还使用了信号量来作为定时器，这部分可以参考，即：<strong>在不影响程序执行的前提下进行定时</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 子进程发送请求的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *req)</span><br>{<br>    <span class="hljs-type">int</span> rlen;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br>    <span class="hljs-type">int</span> s, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br><br>    <span class="hljs-comment">// 当程序执行到指定的秒数之后，发送SIGALRM信号，</span><br>    <span class="hljs-comment">// 即设置alam_handler函数为信号处理函数</span><br>    sa.sa_handler = alarm_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br><br>    alarm(benchtime); <span class="hljs-comment">// after benchtime,then exit</span><br><br>    rlen = <span class="hljs-built_in">strlen</span>(req);<br>nexttry:<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">if</span> (timerexpired)<br>        {<br>            <span class="hljs-comment">// 定时器过期</span><br>            <span class="hljs-comment">// 减去由于定时器过期引起的失败</span><br>            <span class="hljs-keyword">if</span> (failed &gt; <span class="hljs-number">0</span>)<br>            {<br>                failed--;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        s = Socket(host, port);<br>        <span class="hljs-comment">// 构造并发起请求失败</span><br>        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>        {<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        <span class="hljs-comment">// 如果请求报文写入套接字失败</span><br>        <span class="hljs-keyword">if</span> (rlen != write(s, req, rlen))<br>        {<br>            failed++;<br>            close(s);<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        <span class="hljs-comment">// 如果使用HTTP/0.9协议，因为会在服务器回复后自动断开连接，所以可以先关闭写端</span><br>        <span class="hljs-comment">// 如果写端已经被关闭了，则说明异常连接</span><br>        <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (shutdown(s, <span class="hljs-number">1</span>))<br>            {<br>                failed++;<br>                close(s);<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>        <span class="hljs-keyword">if</span> (force == <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 读取服务器的数据</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            {<br>                <span class="hljs-keyword">if</span> (timerexpired)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 将数据读取进buf中</span><br>                i = read(s, buf, <span class="hljs-number">1500</span>);<br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                {<br>                    failed++;<br>                    close(s);<br>                    <span class="hljs-keyword">goto</span> nexttry;<br>                }<br>                <span class="hljs-comment">// 文件尾</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 如果读取到了数据，将总共传送的字节数加上读取到的数据的字节数</span><br>                <span class="hljs-keyword">else</span><br>                    bytes += i;<br>            }<br>        }<br>        <span class="hljs-comment">// 关闭连接，如果失败，测试失败数加一，继续循环</span><br>        <span class="hljs-keyword">if</span> (close(s))<br>        {<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        speed++;<br>    }<br>}<br><br><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><div class="note note-primary">            <p><strong>流程解析</strong></p><p><img src="/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic1.png" class="" title="_"></p>          </div><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>getopt_long() :其函数族成员有getopt、getopt_long、getopt_long_only，可以用来解析命令行参数，很实用。位于getopt.h，可以参阅<a href="https://blog.csdn.net/qq_33850438/article/details/80172275/"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>pipe() :管道是两个进程之间的连接，一个进程的标准输出成为另一个进程的标准输入。在UNIX操作系统中，管道用于进程间通信。可以参阅<a href="https://blog.51cto.com/u_15064646/3853841"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>fork() :用于创建出子进程，调用一次返回两次，子进程拥有父进程所有的打开的文件与变量。<strong>另外，在循环中使用fork会导致子进程继续fork，非常麻烦，为了计数方便可以让子进程在循环中break掉。</strong></p></li><li><p>fprintf() : printf() ==fprintf(stdout,...)这个函数功能更强大，支持重定向。</p></li><li><p>alarm() :alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号，可以设置对应的信号处理函数去处理这个信号。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>小型C语言项目源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>小型C语言项目源码剖析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(4)</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器----来源于cookbook第四章">迭代器----来源于cookbook第四章</h2><span id="more"></span><p><font color="#add0a0">记录第四章中比较有意思的部分</font></p><hr><h3 id="实现容器的委托迭代">实现容器的委托迭代</h3><div class="note note-primary">            <p>只需要为容器实现<code>__iter__</code>魔法方法即可。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,value</span>):<br>        self._value = value<br>        self._children = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Node({!r})"</span>.<span class="hljs-built_in">format</span>(self._value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self,value</span>):<br>        self._children.append(value)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self._children)<br><br>a = Node(<span class="hljs-string">"list"</span>)<br>a.append(<span class="hljs-number">1</span>)<br>a.append(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">""</span>) <span class="hljs-comment">## 12</span><br><br></code></pre></td></tr></table></figure><h3 id="简单的方法实现迭代协议">简单的方法实现迭代协议</h3><div class="note note-primary">            <p>使用<code>yield from</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    <span class="hljs-comment"># 注意，此处yield出去的仍然是一个迭代器，</span><br>    <span class="hljs-keyword">yield</span> (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span>)<br><br>a = gen()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># &lt;generator object gen.&lt;locals&gt;.&lt;genexpr&gt; at 0x000001C6FC019D60&gt;</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_good</span>():<br>    x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    <span class="hljs-comment"># 此时yield出去的是我们需要的整数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span>)<br><br>a = gen()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 4 5</span><br><br></code></pre></td></tr></table></figure><h3 id="反向迭代">反向迭代</h3><div class="note note-primary">            <p>只需要实现<code>__reversed__()</code>方法即可，实现反向迭代后的效率更高</p>          </div><h3 id="迭代器切片">迭代器切片</h3><div class="note note-primary">            <p>使用<code>itertools</code>的<code>islice()</code>方法即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> islice<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        <span class="hljs-keyword">yield</span> i<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> islice(gen(),<span class="hljs-number">10</span>,<span class="hljs-number">20</span>):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 10....19</span><br><br><span class="hljs-comment"># 但是注意，islice会消耗掉迭代器，所以没法倒回去访问数据</span><br><br></code></pre></td></tr></table></figure><h3 id="以索引-值的形式迭代序列">以索引-值的形式迭代序列</h3><div class="note note-primary">            <p>使用<code>enumerate()</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]<br><br><span class="hljs-keyword">for</span> index, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>    <span class="hljs-built_in">print</span>(index,word) <span class="hljs-comment"># 0 a  1 b  2 c</span><br><br></code></pre></td></tr></table></figure><h3 id="同时迭代多个序列">同时迭代多个序列</h3><div class="note note-primary">            <p>使用<code>zip()</code>函数即可，其返回一个迭代器，长度是参数中较短的一个</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(a,b):<br>    <span class="hljs-built_in">print</span>(x,y) <span class="hljs-comment"># 1 4  2 5  3 6</span><br><br></code></pre></td></tr></table></figure><h3 id="在多个容器中进行迭代">在多个容器中进行迭代</h3><div class="note note-primary">            <p>使用<code>itertools</code>的<code>chain()</code>函数即可，可以逐个迭代多个容器</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain<br><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chain(a,b):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1 2 3 4 5 6 7</span><br><br><br></code></pre></td></tr></table></figure><h3 id="使用迭代器取代while循环">使用迭代器取代while循环</h3><div class="note note-primary">            <p><code>iter(func,sentinal)</code>可以一直调用无参函数func直到其返回哨兵值sentinal为止</p><p>这样就可以将while循环转换成迭代器模式</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>times = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-keyword">global</span> times<br>    <span class="hljs-keyword">if</span> times==<span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    times +=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(gen,-<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(3)</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/</url>
    
    <content type="html"><![CDATA[<h2 id="处理数字时间和日期----来源于cookbook第三章">处理数字、时间和日期----来源于cookbook第三章</h2><span id="more"></span><p><font color="#a0a0dd">记录第三章中比较有意思的部分</font></p><hr><h3 id="精确的小数计算">精确的小数计算</h3><div class="note note-primary">            <p>使用<code>decimal</code>中的<code>Decimal</code>类就可以实现精确小数计算，而避免引入浮点数误差。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br><span class="hljs-comment"># 传统浮点数会引入误差</span><br>a = <span class="hljs-number">4.2</span><br>b = <span class="hljs-number">2.1</span><br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 6.300000000000001</span><br><span class="hljs-built_in">print</span>(a + b == <span class="hljs-number">6.3</span>) <span class="hljs-comment"># False</span><br><br><span class="hljs-comment"># 使用Decimal</span><br>a = Decimal(<span class="hljs-string">'4.2'</span>)<br>b = Decimal(<span class="hljs-string">'2.1'</span>)<br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 6.3</span><br><span class="hljs-built_in">print</span>(a + b == Decimal(<span class="hljs-string">'6.3'</span>)) <span class="hljs-comment"># True</span><br><br></code></pre></td></tr></table></figure><h3 id="精确的分数计算">精确的分数计算</h3><div class="note note-primary">            <p>使用<code>fractions</code>中的<code>Fraction</code>可以精确的计算分数</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> Fraction<br><br>a = Fraction(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br>b = Fraction(<span class="hljs-number">7</span>,<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 27/16</span><br><br></code></pre></td></tr></table></figure><h3 id="numpy的matrix与array在处理矩阵上的微妙区别">numpy的matrix与array在处理矩阵上的微妙区别</h3><div class="note note-primary">            <p><code>matrix</code>是矩阵，而<code>array</code>主要是数组，两者在运算上存在一些区别</p><ul><li><p>首先array的<code>*</code>，<code>**</code>都是点乘，其矩阵乘法需要使用<code>np.dot()</code></p></li><li><p>而matrix的<code>*</code>，<code>**</code>都是矩阵乘法，其点乘需要用到<code>np.multiply()</code></p></li><li><p>matrix求逆可以直接<code>.I</code>，而array求逆需要使用<code>np.linalg.inv()</code></p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(2)</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串与文本----来源于cookbook第二章">字符串与文本----来源于cookbook第二章</h2><span id="more"></span><p><font color="#a0dda0">记录第二章中比较有意思的部分</font></p><hr><div class="note note-info">            <p>其实这一章讲的方法挺多挺杂的，但是日常使用基本就正则和python自带的字符串方法，其他的感觉用不到的样子。</p><p>正则的话平时写多了自然就会了，这里就不记录了</p>          </div><h3 id="字符串开头结尾文本匹配">字符串开头结尾文本匹配</h3><div class="note note-primary">            <p>使用<code>str.startswith()</code>和<code>str.endwith()</code>即可。在写文件批处理脚本的时候用得到。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>files = [<span class="hljs-string">'a.h'</span>,<span class="hljs-string">'a.c'</span>,<span class="hljs-string">'a.exe'</span>]<br>selected = [file <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files <span class="hljs-keyword">if</span> file.endswith((<span class="hljs-string">".h"</span>,<span class="hljs-string">".c"</span>))]<br><span class="hljs-built_in">print</span>(selected) <span class="hljs-comment"># ['a.h', 'a.c']</span><br><br></code></pre></td></tr></table></figure><h3 id="字符串去除首尾不需要的字符">字符串去除首尾不需要的字符</h3><div class="note note-primary">            <p>使用<code>str.lstrip()</code>和<code>str.rstrip()</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>s = <span class="hljs-string">'-=-=hellp-=-world-=-=-='</span><br>s = s.lstrip(<span class="hljs-string">"-="</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment"># 'hellp-=-world-=-=-='</span><br>s = s.rstrip(<span class="hljs-string">"-="</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment"># 'hellp-=-world'</span><br><br></code></pre></td></tr></table></figure><h3 id="字符串拼接">字符串拼接</h3><div class="note note-primary">            <p><code>+</code>：效率最低，但是简单</p><p><code>join</code>：效率高，支持列表等</p><p><code>print(*args,sep=",")</code>：容易被遗忘的一种方法</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>c = <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">','</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [a,b,c])) <span class="hljs-comment"># 1,2,3</span><br><span class="hljs-built_in">print</span>(a,b,c,sep=<span class="hljs-string">","</span>) <span class="hljs-comment"># 1,2,3</span><br><br></code></pre></td></tr></table></figure><h3 id="给字符串中变量名做插值">给字符串中变量名做插值</h3><div class="note note-primary">            <p>作者在书中提到python没法直接处理字符串插值，并实现了一些复杂的方法，<br>幸运的是，新版本的python已经直接支持插值了，不需手动去实现了</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>name = <span class="hljs-string">'book'</span><br>price = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>' price is <span class="hljs-subst">{price}</span>"</span>) <span class="hljs-comment"># book' price is 10</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(1)</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据结构与算法----来源于cookbook第一章">基本数据结构与算法----来源于cookbook第一章</h2><span id="more"></span><p><font color="#dda0a0">记录第一章中比较有意思的部分</font></p><hr><h3 id="元素分解">元素分解</h3><div class="note note-primary">            <p>通过<code>*表达式</code>来解包裹实现分解</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)]<br><br>first, *_, (*__, last) = l<br><br><span class="hljs-built_in">print</span>(first,last) <span class="hljs-comment"># 1 7</span><br><br></code></pre></td></tr></table></figure><h3 id="将字典的键映射到多个值上">将字典的键映射到多个值上</h3><div class="note note-primary">            <ul><li><p>通过使用<code>collections</code>中的<code>defaultdict</code>来实现一键多值字典</p></li><li><p>通过<code>dict</code>类的<code>setdefault</code>方法来实现</p></li></ul>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一</span><br><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>d = defaultdict(<span class="hljs-built_in">list</span>) <span class="hljs-comment"># 或defaultdict(set)</span><br>d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">1</span>)<br>d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">2</span>)<br>d[<span class="hljs-string">'b'</span>].append(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(d) <span class="hljs-comment"># {'a': [1, 2], 'b': [3]}</span><br><br><br><span class="hljs-comment"># 方法二</span><br><br>d = {}<br>d.setdefault(<span class="hljs-string">'a'</span>,[]).append(<span class="hljs-number">1</span>)<br>d.setdefault(<span class="hljs-string">'a'</span>,[]).append(<span class="hljs-number">2</span>)<br>d.setdefault(<span class="hljs-string">'b'</span>,[]).append(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(d) <span class="hljs-comment"># {'a': [1, 2], 'b': [3]}</span><br><br></code></pre></td></tr></table></figure><h3 id="两个字典的集合运算">两个字典的集合运算</h3><div class="note note-primary">            <p>字典支持集合运算符，可以对其求交集、并集等</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = {<br>    <span class="hljs-string">'x'</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">'y'</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">'z'</span> : <span class="hljs-number">3</span><br>}<br><br>b={<br>    <span class="hljs-string">'x'</span> : <span class="hljs-number">10</span>,<br>    <span class="hljs-string">'w'</span> : <span class="hljs-number">11</span>,<br>    <span class="hljs-string">'z'</span> : <span class="hljs-number">3</span><br>}<br><br><span class="hljs-built_in">print</span>(a.keys() &amp; b.keys()) <span class="hljs-comment"># {'z', 'x'}</span><br><span class="hljs-built_in">print</span>(a.keys() - b.keys()) <span class="hljs-comment"># {'y'}</span><br><span class="hljs-built_in">print</span>(a.items() &amp; b.items()) <span class="hljs-comment"># {('z', 3)}</span><br><br></code></pre></td></tr></table></figure><h3 id="字典推导式">字典推导式</h3><div class="note note-primary">            <p>感觉字典推导式不如生成器推导式和列表推导式用的多</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>prices = {<br>    <span class="hljs-string">'a'</span> : <span class="hljs-number">45</span>,<br>    <span class="hljs-string">'b'</span> : <span class="hljs-number">32</span>,<br>    <span class="hljs-string">'c'</span> : <span class="hljs-number">10</span><br>}<br><br>p1 = {key:value <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> value &gt;<span class="hljs-number">20</span>}<br><span class="hljs-built_in">print</span>(p1) <span class="hljs-comment"># {'a': 45, 'b': 32}</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(4)</title>
    <link href="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/"/>
    <url>/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的编码格式">levelDB的编码格式</h2><span id="more"></span><hr><h3 id="存储方式">存储方式</h3><p>当数据库获取到内存后，其需要将数据插入到内存中，并在适当的时候读取出来，如何高效地利用申请到的内存就是一个比较重要的问题。</p><div class="note note-info">            <p>在levelDB中，数据是按照下列方法存储的：</p><ul><li><p>整数分为32位和64位定长整数</p></li><li><p>整数还使用变长整数存储</p></li><li><p>整数均为小端法存储</p></li><li><p>字符串采用长度前缀编码</p></li></ul>          </div><h4 id="变长整数与定长整数">变长整数与定长整数</h4><p>所谓定长整数就是我们平时在C语言中定义的数据类型，其长度是始终不变的。</p><p>而变长整数则顾名思义，其编码的原理是只使用一个字节的低7位去存储数据，而最高位的用于做标识：当最高位为1时表示需要继续读取下一个字节。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic1.jpg" class="" title="_"><p>如上图所示，这样变长整数就可以使用1-5字节去表示int32的所有整数，表面上看，虽然表示非常大的整数的时候变长整数编码会占用更多的空间，但是由于大整数出现的频率一般是比较小的，所以就普遍而言，使用变长整数会节省更多的内存。</p><h4 id="字符串">字符串</h4><p>字符串使用长度前缀编码，即在把字符串的长度放在字符串的前面，然后组合起来编码。</p><p>而同时，字符串长度使用变长整数进行编码，所以一个字符串的存储格式是<code>32位变长整数编码字符串长度 + 字符串本身</code></p><p>使用长度前缀编码的方式，字符串能够编码任意字符(比如C语言不能在字符串中包含'\0')，同时，字符串的长度可以预先知道，所以有利于读写操作。另外，对于大部分字符串的长度都比较短的时候，并不会造成大量内存损失。</p><h3 id="源码解析部分">源码解析部分</h3><div class="note note-primary">            <p>源码位置： <code>utils/coding.cc</code><code>utils/coding.h</code></p>          </div><h4 id="头文件">头文件</h4><p>首先，我们先来看一下编码解码和插入数据的头文件，这部分内容很简单，就是处理编码格式的一些方法。</p><p>其中要注意用到了一个类<code>Slice</code>，这个类是对字符串的封装，比<code>std::string</code>封装更加低级，所以效率会更高，后面的文章会细🔒它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span>;                 <span class="hljs-comment">// 插入定长32位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span>;                 <span class="hljs-comment">//插入定长64位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span>;                <span class="hljs-comment">//插入变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span>;                <span class="hljs-comment">//插入变长64位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutLengthPrefixedSlice</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">const</span> Slice &amp;value)</span></span>; <span class="hljs-comment">//插入字符串</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span>;          <span class="hljs-comment">// 获取变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint64</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint64_t</span> *value)</span></span>;          <span class="hljs-comment">// 获取变长64位整数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span>; <span class="hljs-comment">// 获取字符串</span><br><br><span class="hljs-comment">// 用于解码32/64位变长整数的函数，其中p是指向变长整数，limit是变长整数最大长度</span><br><span class="hljs-comment">// 而v存放的是解码后的值，如果不能解码则返回null</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint32_t</span> *v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint64_t</span> *v)</span></span>;<br><br><span class="hljs-comment">// 这是上面GetVarint32Ptr函数的内部回调函数，是实际处理变长整数的东西</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> *value)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VarintLength</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> v)</span></span>; <span class="hljs-comment">// 返回变长整数(32/64)的'长度'</span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span>; <span class="hljs-comment">// 编码变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span>; <span class="hljs-comment">// 编码变长64位整数</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span>; <span class="hljs-comment">// 编码定长32位整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span>; <span class="hljs-comment">// 编码定长64位整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">DecodeFixed32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span>;       <span class="hljs-comment">// 解码32位定长整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">DecodeFixed64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span>;       <span class="hljs-comment">// 解码64位定长整数</span><br><br></code></pre></td></tr></table></figure><p>头文件只是给出了函数接口，下面我们就来进一步去分析各个函数。</p><h4 id="实现文件">实现文件</h4><p>为了方便分析，我们将其分成：编码解码定长整数、编码解码变长整数、Put和Get方法。</p><p>这部分代码全部围绕编码解码来实现的，其中定长的编解码很简单，就不在此赘述了。关于变长整数的编解码，其关于编码和解码的相关函数都预留了类似迭代器一样的超尾元素(指针)，这种形式的接口可以很方便的确定所处理数据的区间(变长整数的Put和Get相关函数都使用到了预留的超尾元素)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-comment">// 内联函数本来是在头文件中的，但是此处将其当成一个函数来进行分析</span><br><br><span class="hljs-comment">/*=============编码解码定长整数=============*/</span><br><br><span class="hljs-comment">// 编码定长32位整数，实现思路就是类似结构体那样去分割uint32即可</span><br><span class="hljs-comment">// 但注意保证让dst有足够的空间去存储，否则会溢出或段错误</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// reinterpret_cast允许指针(引用)之间转换</span><br>    <span class="hljs-comment">// 整型与指针类型间的转换以及指针与足够大的整型之间的转换</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br><br>    buffer[<span class="hljs-number">0</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value);<br>    buffer[<span class="hljs-number">1</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">8</span>);<br>    buffer[<span class="hljs-number">2</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">16</span>);<br>    buffer[<span class="hljs-number">3</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">24</span>);<br>}<br><br><span class="hljs-comment">// 编码定长64位整数，思路与编码定长32位整数一致</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br><br>    buffer[<span class="hljs-number">0</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value);<br>    buffer[<span class="hljs-number">1</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">8</span>);<br>    buffer[<span class="hljs-number">2</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">16</span>);<br>    buffer[<span class="hljs-number">3</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">24</span>);<br>    buffer[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">32</span>);<br>    buffer[<span class="hljs-number">5</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">40</span>);<br>    buffer[<span class="hljs-number">6</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">48</span>);<br>    buffer[<span class="hljs-number">7</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">56</span>);<br>}<br><br><span class="hljs-comment">// 解码32位定长整数并返回，这同样不做边界检查</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">DecodeFixed32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(ptr);<br><br>    <span class="hljs-comment">// 注意是小端存储结构</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">0</span>])) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>);<br>}<br><br><span class="hljs-comment">// 解码64位定长整数并返回，与上类似</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">DecodeFixed64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(ptr);<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">0</span>])) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">4</span>]) &lt;&lt; <span class="hljs-number">32</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">5</span>]) &lt;&lt; <span class="hljs-number">40</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">6</span>]) &lt;&lt; <span class="hljs-number">48</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">7</span>]) &lt;&lt; <span class="hljs-number">56</span>);<br>}<br><br><span class="hljs-comment">/*=============编码解码变长整数=============*/</span><br><br><span class="hljs-comment">// 编码32位变长整数</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 这一部分的编码就是完全按照定义来的，用了5个if</span><br>    <span class="hljs-comment">// 分别对应了1-5个字节范围内的长度</span><br>    <span class="hljs-type">uint8_t</span> *ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>    <span class="hljs-comment">/* 仿照EncodeVarint64的循环写法来重写这一部分</span><br><span class="hljs-comment">    while(v&gt;=B)</span><br><span class="hljs-comment">    {</span><br><span class="hljs-comment">        *(ptr++) = v|B;</span><br><span class="hljs-comment">        v &gt;&gt;= 7;</span><br><span class="hljs-comment">    }</span><br><span class="hljs-comment">    *(ptr++) = static_cast&lt;uint8_t&gt;(v);</span><br><span class="hljs-comment">    return reinterpret_cast&lt;char *&gt;(ptr);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>))<br>    {<br>        *(ptr++) = v;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">7</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">14</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">28</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">14</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">21</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">14</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">21</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">28</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(ptr);<br>}<br><br><span class="hljs-comment">// 编码64位变长整数，此处没有使用循环，同样的，上面32位的也可以这样写</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 将函数内的常数设置为局部静态变量，减少每次调用函数时的分配与开销</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">uint8_t</span> *ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br>    <span class="hljs-comment">// B被设置成1&lt;&lt;7，当v&gt;=b时表示7位存不下</span><br>    <span class="hljs-keyword">while</span> (v &gt;= B)<br>    {<br>        *(ptr++) = v | B;<br>        v &gt;&gt;= <span class="hljs-number">7</span>;<br>    }<br>    *(ptr++) = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(ptr);<br>}<br><br><span class="hljs-comment">// 解码32位变长整数，这个函数只处理小于128的单字节变长整数</span><br><span class="hljs-comment">// 大于127的部分则调用GetVarint32PtrFallback处理</span><br><span class="hljs-comment">// 此函数将解码后的值放在value中</span><br><span class="hljs-comment">// limit总是为p+5，因为变长整数最多5个字节</span><br><span class="hljs-comment">// p是一个指向包含值得字符串</span><br><span class="hljs-comment">// 返回的是对变长整数解码后的一个字节，设置成这样的目的是用于get方法</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (p &lt; limit)<br>    {<br>        <span class="hljs-type">uint32_t</span> result = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        <span class="hljs-comment">// 内部只解码不超过127的整数，剩下的更长的交给GetVarint32PtrFallback处理</span><br>        <span class="hljs-keyword">if</span> ((result &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span>)<br>        {<br>            *value = result;<br>            <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetVarint32PtrFallback</span>(p, limit, value);<br>}<br><br><span class="hljs-comment">// 解码32位变长整数中大于127的数字，即存储超过1个字节的变长32位整数</span><br><span class="hljs-comment">// 被GetVarint32Ptr调用</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 由于32位变长整数只能由28位存储数字，所以偏移的上限就是28位</span><br>    <span class="hljs-comment">// 每个字节只能存储7位有效字符，所以每处理一字节就偏移7位</span><br>    <span class="hljs-comment">// shift同时也是每个字节中有效数字的权</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">28</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>)<br>    {<br>        <span class="hljs-comment">// 解码出一个字节</span><br>        <span class="hljs-type">uint32_t</span> byte = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        p++;<br>        <span class="hljs-comment">// 判断最高位，如果是1则继续取并执行，否则就返回解码的数据</span><br>        <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>)<br>        {<br>            result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            result |= (byte &lt;&lt; shift);<br>            *value = result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(p);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 当变长整数编码不正确就返回nullptr</span><br>    <span class="hljs-comment">// 不正确的原因只能是因为连续5个字节都是被标记为1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>}<br><br><span class="hljs-comment">// 解码64位变长整数的函数，与解码32位变长的那个函数类似</span><br><span class="hljs-comment">// 不过这个函数没有回调，是直接在本函数内进行全部的解码工作</span><br><span class="hljs-comment">// 原因我觉得是这样的：因为小整数比较多，而小整数一般就以32位变长存储</span><br><span class="hljs-comment">// 而解码最小整数的函数被设置成内联函数，这样效率就会提升很多</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint64_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint64_t</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这个函数内部与GetVarint32PtrFallback一致</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">63</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>)<br>    {<br>        <span class="hljs-type">uint64_t</span> byte = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        p++;<br>        <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>)<br>        {<br>            result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            result |= (byte &lt;&lt; shift);<br>            *value = result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(p);<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>}<br><br><span class="hljs-comment">/*=============Put与Get方法=============*/</span><br><br><span class="hljs-comment">// 把32位定长转换成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(value)];<br>    <span class="hljs-built_in">EncodeFixed32</span>(buf, value);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, <span class="hljs-built_in">sizeof</span>(buf));<br>}<br><br><span class="hljs-comment">// 把64位定长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(value)];<br>    <span class="hljs-built_in">EncodeFixed64</span>(buf, value);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, <span class="hljs-built_in">sizeof</span>(buf));<br>}<br><br><span class="hljs-comment">// 把32位变长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置最大的缓冲区，注意EncodeVarint32会返回指向编码后的一个字节的指针</span><br>    <span class="hljs-comment">// 所以就能根据指针偏移来计算出当前变长整数的长度</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">EncodeVarint32</span>(buf, v);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, ptr - buf);<br>}<br><br><span class="hljs-comment">// 把64位变长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 原理和PutVarint32一样，只是缓冲区大小大了一些</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">EncodeVarint64</span>(buf, v);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, ptr - buf);<br>}<br><br><span class="hljs-comment">// 把slice转化成字符串存储</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutLengthPrefixedSlice</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">const</span> Slice &amp;value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 字符串的编码格式是长度在前，然后是字符串本身</span><br>    <span class="hljs-comment">// 所以按照定义就可以插入了</span><br>    <span class="hljs-comment">// 先插入长度，然后把字符串移动过去</span><br>    <span class="hljs-comment">// 由于Slice末尾不需要'\0'，所以需要指定长度</span><br>    <span class="hljs-built_in">PutVarint32</span>(dst, value.<span class="hljs-built_in">size</span>());<br>    dst-&gt;<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br>}<br><br><span class="hljs-comment">// 计算变长整数的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VarintLength</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 这个函数思路很简单，不解析了</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (v &gt;= <span class="hljs-number">128</span>)<br>    {<br>        v &gt;&gt;= <span class="hljs-number">7</span>;<br>        len++;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br><br><span class="hljs-comment">// 从字符串中获取32位变长</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();                   <span class="hljs-comment">// 先拿到字符串的首指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();           <span class="hljs-comment">// 然后获取尾部地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, value); <span class="hljs-comment">//先解码出数据</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-comment">// 所请求元素不合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 由于一个字符串可能内部不止一个整数</span><br>        <span class="hljs-comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span><br>        <span class="hljs-comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span><br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 从字符串中获取64位变长</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint64</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint64_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 同上，只是部分接口不一样</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint64Ptr</span>(p, limit, value);<br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 解码出字符串</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-comment">// 先获取长度，然后根据长度去解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="hljs-built_in">size</span>() &gt;= len)<br>    {<br>        *result = <span class="hljs-built_in">Slice</span>(input-&gt;<span class="hljs-built_in">data</span>(), len);<br>        input-&gt;<span class="hljs-built_in">remove_prefix</span>(len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br><br></code></pre></td></tr></table></figure><p>其中，关于字符串的解码部分我认为还是很巧妙的，因为字符串编码后的长度在前，且长度是一个变长整数，所以解码时需要先提取出长度。正常情况下的写法可能是先对整个编码后字符串遍历，解析出前面的长度，记录下这个字符串长度以及变长整数的长度后再去处理后面的字符串。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic2.png" class="" title="_"><p>但是levelDB中的处理方式是让变长解码函数解码多少就把输入中解码的这段数据给弄掉(修改了源字符串的指针)，因为这部分需要解码的值已经被解析出来并返回了，也就不再需要了。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic3.png" class="" title="_"><p><strong><em>每个解码函数只处理字符串开头，并且处理完成后及时改变字符串的首地址(后移)，这样就不需要记录这部分的状态并考虑处理细节了</em></strong></p><p>能够这样做的原因就是通过传递超尾元素来标定界限，同时所有处理函数都以指针作为数据传递的方式(统一接口标准)。</p><p>而直接移动字符串指针很容易就引出另外一个问题：会不会内存泄漏呢？</p><p>答案是不会，因为内存并不由Slice管理，Slice只是对底层字符串做出了映射而已，其主要目的是用于传递，后续我们会对Slice进行解析。</p><p>再特意把这段代码贴出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();                   <span class="hljs-comment">// 先拿到字符串的首指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();           <span class="hljs-comment">// 然后获取尾部地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, value); <span class="hljs-comment">//先解码出数据，q是超尾元素(相对变长整数而言)</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-comment">// 所请求元素不合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 由于一个字符串可能内部不止一个整数</span><br>        <span class="hljs-comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span><br>        <span class="hljs-comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span><br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-comment">// 先获取长度，然后根据长度去解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="hljs-built_in">size</span>() &gt;= len)<br>    {<br>        *result = <span class="hljs-built_in">Slice</span>(input-&gt;<span class="hljs-built_in">data</span>(), len);<br>        input-&gt;<span class="hljs-built_in">remove_prefix</span>(len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br><br></code></pre></td></tr></table></figure><hr><h2 id="总结部分">总结部分</h2><table><thead><tr class="header"><th style="text-align: center;">函数/变量</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">inline void EncodeFixed32(char *dst,uint32_t value)</td><td style="text-align: center;">编码定长32位整数</td></tr><tr class="even"><td style="text-align: center;">inline void EncodeFixed64(char *dst,uint64_t value)</td><td style="text-align: center;">编码定长64位整数</td></tr><tr class="odd"><td style="text-align: center;">inline uint32_t DecodeFixed32(const char*ptr)</td><td style="text-align: center;">解码32位定长整数</td></tr><tr class="even"><td style="text-align: center;">inline uint64_t DecodeFixed64(const char*ptr)</td><td style="text-align: center;">解码64位定长整数</td></tr><tr class="odd"><td style="text-align: center;">char <em>EncodeVarint32(char </em>dst,uint32_t v)</td><td style="text-align: center;">编码32位变长整数</td></tr><tr class="even"><td style="text-align: center;">char <em>EncodeVarint64(char </em>dst,uint64_t v)</td><td style="text-align: center;">编码64位变长整数</td></tr><tr class="odd"><td style="text-align: center;">inline const char<em>GetVarint32Ptr(const char </em>p, const char <em>limit, uint32_t</em>value)</td><td style="text-align: center;">解码32位变长整数</td></tr><tr class="even"><td style="text-align: center;">const char<em>GetVarint32PtrFallback(const char </em>p, const char<em>limit,uint32_t </em>value)</td><td style="text-align: center;">解码32位变长整数中大于127的数字，被GetVarint32Ptr调用</td></tr><tr class="odd"><td style="text-align: center;">const char <em>GetVarint64Ptr(const char</em>p, const char <em>limit, uint64_t </em>value)</td><td style="text-align: center;">解码64位变长整数的函数</td></tr><tr class="even"><td style="text-align: center;">void PutFixed32(std::string *dst,uint32_t value)</td><td style="text-align: center;">把32位定长转换成字符串</td></tr><tr class="odd"><td style="text-align: center;">void PutFixed64(std::string *dst,uint64_t value)</td><td style="text-align: center;">把64位定长转化成字符串</td></tr><tr class="even"><td style="text-align: center;">void PutVarint32(std::string *dst,uint32_t v)</td><td style="text-align: center;">把32位变长转化成字符串</td></tr><tr class="odd"><td style="text-align: center;">void PutVarint64(std::string *dst,uint64_t v)</td><td style="text-align: center;">把64位变长转化成字符串</td></tr><tr class="even"><td style="text-align: center;">void PutLengthPrefixedSlice(std::string*dst, const Slice &amp;value)</td><td style="text-align: center;">把slice转化成字符串存储</td></tr><tr class="odd"><td style="text-align: center;">int VarintLength(uint64_t v)</td><td style="text-align: center;">计算变长整数的长度</td></tr><tr class="even"><td style="text-align: center;">bool GetVarint32(Slice <em>input,uint32_t </em>value)</td><td style="text-align: center;">从字符串中获取32位变长</td></tr><tr class="odd"><td style="text-align: center;">bool GetVarint64(Slice <em>input,uint64_t </em>value)</td><td style="text-align: center;">从字符串中获取64位变长</td></tr><tr class="even"><td style="text-align: center;">bool GetLengthPrefixedSlice(Slice<em>input, Slice </em>result)</td><td style="text-align: center;">解码出字符串</td></tr></tbody></table><p>编码解码部分使用到了很多位级编程，这部分都很有意思，可以做到四两拨千斤的作用。</p><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>在函数内需要用到的常量可以定义成内部静态常量<code>static const</code>，这样就避免了全局变量的额外开销与权限混乱、同时也能避免局部变量的每次都需要额外分配的开销。</p></li><li><p>当函数是处理连续的区间时，预留出超尾元素接口是很有必要的。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(3)</title>
    <link href="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/"/>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的内存管理策略">levelDB的内存管理策略</h2><span id="more"></span><hr><h3 id="leveldb的内存管理类arena">levelDB的内存管理类Arena</h3><div class="note note-primary">            <p>源代码位置：utils/arena.cc utils/arena.h</p>          </div><p>对于数据库而言，内存管理策略是十分重要的，因为其正是需要为存入的数据分配内存，倘若直接使用new/delete这样每次插入数据都单独去分配内存，效率是很低的，同时由于每条插入的数据的大小并不一致，导致会出现许多的内存碎片。</p><p>对于levelDB这样一个billion级别的数据库，显然其不能采取这样的策略。</p><p>在levelDB中，由于只有<code>MemTable</code>位于内存且需要频繁的插入，所以它最需要内存管理，levelDB中用于内存管理的类为<code>Arena</code>，每个<code>MemTable</code>都绑定一个<code>Arena</code>。而其余的部分则直接使用new/delete，因为这些部分要么是不频繁，要么是块本身就很大。</p><h4 id="arena类">Arena类</h4><div class="note note-info">            <p><strong>基本思想</strong>：先分配出一大块内存，然后当需要用到内存时，就在这一大块内存中移动指针，这样就能解决小块内存频繁调用new和内存碎片的问题，不过缺点是有一部分内存被浪费掉。</p>          </div><p>我们可以先来看一下arena类的头文件捏。从头文件中可以很明显的看到其用于内存分配的方法就是公有函数<code>Allocate</code>和<code>AllocateAligned</code>，区别是后者提供内存对齐，这对效率也有提升。</p><h5 id="头文件">头文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// utils/arena.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Arena</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Arena</span>();                                  <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Arena</span>(<span class="hljs-type">const</span> Arena &amp;) = <span class="hljs-keyword">delete</span>;            <span class="hljs-comment">//关闭复制构造函数</span><br>    Arena &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Arena &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//关闭使用=的拷贝构造函数</span><br>    ~<span class="hljs-built_in">Arena</span>();                                 <span class="hljs-comment">//析构函数</span><br><br>    <span class="hljs-comment">//返回一个指针指向新分配的内存区域，即内部的分配内存的方法</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>    <span class="hljs-comment">//同Allocate，但是提供了内存对齐策略</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>    <span class="hljs-comment">//返回目前从内存中申请的内存大小，由于memory_usage_是原子操作</span><br>    <span class="hljs-comment">//此处的memory_order_relaxed表示宽松内存序，即任何一个线程可以任意更新</span><br>    <span class="hljs-comment">//不用同步到其他线程中，下一个访问该元素的线程获取到更新之后的值</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">MemoryUsage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> memory_usage_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;       <span class="hljs-comment">//获取新分配的内存，被AllocateAligned和Allocate调用</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span></span>; <span class="hljs-comment">//new函数的包装，被AllocateFallback调用</span><br><br>    <span class="hljs-type">char</span> *alloc_ptr_;                  <span class="hljs-comment">//当前内存块未使用内存的首地址</span><br>    <span class="hljs-type">size_t</span> alloc_bytes_remaining_;     <span class="hljs-comment">//当前内存块中未使用空间的大小</span><br>    std::vector&lt;<span class="hljs-type">char</span> *&gt; blocks_;       <span class="hljs-comment">//存储每一次向系统请求分配的内存块的指针</span><br>    std::atomic&lt;<span class="hljs-type">size_t</span>&gt; memory_usage_; <span class="hljs-comment">//记录已申请全部内存使用的数目，注意此操作是原子的</span><br>};<br></code></pre></td></tr></table></figure><p>头文件定义了Arena这个类，在类中只有3个公有方法，分别用于返回小内存、对齐的小内存、当前类占用的空间。</p><h5 id="实现文件">实现文件</h5><p>分析完了头文件，我们接下来看一下它的cpp实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">/*=============类的构造析构等基础函数=============*/</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kBlockSize = <span class="hljs-number">4096</span>; <span class="hljs-comment">//一个内存块的大小</span><br><br><span class="hljs-comment">// 构造函数，默认的构造函数直接对内部的几个元素进行初始化</span><br>Arena::<span class="hljs-built_in">Arena</span>()<br>    : <span class="hljs-built_in">alloc_ptr_</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">alloc_bytes_remaining_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">memory_usage_</span>(<span class="hljs-number">0</span>) {}<br><br><span class="hljs-comment">// 析构函数，注意，由于类中存在一个vector数组存储了每次分配的内存的块的指针</span><br><span class="hljs-comment">// 所以析构的时候遍历这个数组然后逐个delete</span><br>Arena::~<span class="hljs-built_in">Arena</span>()<br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; blocks_.<span class="hljs-built_in">size</span>(); i++)<br>    {<br>        <span class="hljs-keyword">delete</span>[] blocks_[i];<br>    }<br>}<br><br><span class="hljs-comment">/*=============公有接口=============*/</span><br><br><span class="hljs-comment">// 分配小内存的函数，这个函数是此类对外的接口，被写成内联函数效率更高</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> *<span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 首先，断言申请的内存数目是否合法</span><br>    <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span><br>    <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_)<br>    {<br>        <span class="hljs-type">char</span> *result = alloc_ptr_;<br>        alloc_ptr_ += bytes;<br>        alloc_bytes_remaining_ -= bytes;<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>    <span class="hljs-comment">// 否则调用AllocateFallback进行分配（从内存中申请空间去分配）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>}<br><br><span class="hljs-comment">// 采用对齐的方式去分配内存，只比Allocate多出计算需要分配内存的步骤</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 首先设置对齐的字节数，(sizeof(void *)可以计算出当前机器的每个指针的字节数</span><br>    <span class="hljs-comment">// 最多8字节对齐，当当前机器指针的字节数不足8字节时，会使用当前机器的字节数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> align = (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *) &gt; <span class="hljs-number">8</span>) ? <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *) : <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 静态断言，在编译时执行断言</span><br>    <span class="hljs-comment">// a&amp;(a-1)的功能是去掉右边的1(二进制)，所以当不是2的幂次方时，去掉1后就非0</span><br>    <span class="hljs-built_in">static_assert</span>((align &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>,<br>                  <span class="hljs-string">"Pointer size should be a power of 2"</span>);<br><br>    <span class="hljs-comment">// 下面这里的位运算等价于求余运算</span><br>    <span class="hljs-comment">// 因为上面这个断言已经确保了align是2个幂次方，因此align-1是一个右侧均为1的掩模</span><br>    <span class="hljs-comment">// 两者相与的结果就可以快速求出alloc_ptr_%align</span><br>    <span class="hljs-comment">// 但注意，此时两者能够等价的重要原因是align是2的幂次方</span><br>    <span class="hljs-comment">// 此处还有强制类型转换，也就是把取模结果转换成uintptr_t</span><br>    <span class="hljs-type">size_t</span> current_mod = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 当取模结果不是0就表示需要分配的内存是2的整数幂，所以需要额外分配一些内存</span><br>    <span class="hljs-type">size_t</span> slop = (current_mod == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : align - current_mod);<br><br>    <span class="hljs-comment">// 计算出总的需要的内存</span><br>    <span class="hljs-type">size_t</span> needed = bytes + slop;<br><br>    <span class="hljs-comment">/*-------- 至此，计算出需要对齐时分配的内存后，就与Allocate无异 --------*/</span><br><br>    <span class="hljs-type">char</span> *result;<br><br>    <span class="hljs-comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span><br>    <span class="hljs-keyword">if</span> (needed &lt;= alloc_bytes_remaining_)<br>    {<br>        result = alloc_ptr_ + slop;<br>        alloc_ptr_ += needed;<br>        alloc_bytes_remaining_ -= needed;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 此处存在一点点区别，AllocateFallback申请的参数时bytes而不是对齐后的need</span><br>        <span class="hljs-comment">// 这是因为AllocateFallback调用的是new/delete，总是内存对齐的</span><br>        result = <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>    }<br><br>    <span class="hljs-comment">// 这里再做一下断言，保证对齐</span><br>    <span class="hljs-built_in">assert</span>((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(result) &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">/*=============私有接口=============*/</span><br><br><span class="hljs-comment">// 私有方法：回调函数，用于当当前块内内存不足时申请内存的策略</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 当需要的内存超过kBlockSize的1/4，（默认1kb时），申请和bytes相同大小的内存</span><br>    <span class="hljs-comment">// 这样做是因为当需要用到的内存已经超过块大小的1/4了，那么之前剩余的块可能还有不少</span><br>    <span class="hljs-comment">// 如果新分配一个块那么就可能会浪费比较多的内存</span><br>    <span class="hljs-keyword">if</span> (bytes &gt; kBlockSize / <span class="hljs-number">4</span>)<br>    {<br>        <span class="hljs-type">char</span> *result = <span class="hljs-built_in">AllocateNewBlock</span>(bytes);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">// 当需要的内存不足kBlockSize的1/4，（默认1kb时），就申请一个整个的块（默认4kb）</span><br>    <span class="hljs-comment">// 然后从这里面分配内存</span><br>    <span class="hljs-comment">// 但注意，进入到此函数里只说明原来的块不足以分配现在需要的内存，但其可能仍然剩余内存</span><br>    <span class="hljs-comment">// 此处的策略是直接把原来的内存块中可能剩余的内存给浪费掉</span><br>    <span class="hljs-comment">// 毕竟此时需要分配的内存不到1/4个块，说明原来的块也剩下不了多少内存了</span><br>    alloc_ptr_ = <span class="hljs-built_in">AllocateNewBlock</span>(kBlockSize);<br><br>    <span class="hljs-comment">// 下面这几部就是分配了一个块后做块内的内存分配</span><br>    alloc_bytes_remaining_ = kBlockSize;<br>    <span class="hljs-type">char</span> *result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">// 私有方法：向系统申请内存</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 就是对new的一层包装，同时更新一下类内的参数</span><br>    <span class="hljs-type">char</span> *result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[block_bytes];<br>    blocks_.<span class="hljs-built_in">push_back</span>(result);<br>    memory_usage_.<span class="hljs-built_in">fetch_add</span>(block_bytes + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *),<br>                            std::memory_order_relaxed);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/pic1.jpg" class="" title="_"><p>实际上总体来说思路如下:</p><p>1、当调用<code>AllocateAligned</code>或<code>Allocate</code>时，先判断当前分配内存块中剩余的内存是否有足够的内存去分配新的内存（以及计算内存对齐）；如果足以容纳，则直接从当前内存块中提取内存作为所需内存使用。若是不足以容纳则调用<code>AllocateFallback</code>去申请内存并分配。</p><p>2、在<code>AllocateFallback</code>中，先判断需要申请的内存是否大于1K，若是大于1K，直接<code>AllocateNewBlock</code>向系统申请足够的内存以供使用。若是小于1K，则调用<code>AllocateNewBlock</code>分配一个块，并在这个块中分配需要的内存。</p><p>3、<code>AllocateNewBlock</code>使用系统new操作符向系统申请内存，并更新类内参数。当所分配的内存为4kb时，会将这个申请的内存作为新的内存块(此时旧的内存块中即使还有内存未使用，也不会再拿来使用，因为alloc_ptr_会指向新申请的内存块)。然后再向新申请的内存块提取内存以供使用。</p><p>这里Level对于小于1K的内存申请才向内存池提取内存，主要是连续多次申请小的内存会容易导致内存碎片，影响系统的性能。并且多次的new和delete比较耗时(不断的构造和析构)，会付出额外的空间和时间。</p><hr><h2 id="总结部分">总结部分</h2><table><thead><tr class="header"><th style="text-align: center;">方法/变量</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Arena()</td><td style="text-align: center;">构造函数</td></tr><tr class="even"><td style="text-align: center;">~Arena()</td><td style="text-align: center;">析构函数</td></tr><tr class="odd"><td style="text-align: center;">char* Allocate(size_t bytes)</td><td style="text-align: center;">提供bytes大小的内存</td></tr><tr class="even"><td style="text-align: center;">char* AllocateAligned(size_t bytes)</td><td style="text-align: center;">提供内存对齐的bytes大小的内存</td></tr><tr class="odd"><td style="text-align: center;">size_t MemoryUsage() const</td><td style="text-align: center;">返回当前申请的内存大小</td></tr><tr class="even"><td style="text-align: center;">char* AllocateFallback(size_tbytes)</td><td style="text-align: center;">当块中内存不够时向系统申请内存接口，由Allocate或AllocateAligned调用</td></tr><tr class="odd"><td style="text-align: center;">char* AllocateNewBlock(size_tblock_bytes)</td><td style="text-align: center;">系统new的包装函数，由AllocateFallback调用</td></tr><tr class="even"><td style="text-align: center;">alloc_ptr_</td><td style="text-align: center;">当前内存块中未使用空间的首地址</td></tr><tr class="odd"><td style="text-align: center;">alloc_bytes_remaining_</td><td style="text-align: center;">当前内存块中剩余的空间</td></tr><tr class="even"><td style="text-align: center;">blocks_</td><td style="text-align: center;">new出来的内存的首地址组成的vector数组</td></tr><tr class="odd"><td style="text-align: center;">memory_usage_</td><td style="text-align: center;">向系统已申请的内存大小</td></tr></tbody></table><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><p><code>a &amp; (a - 1)</code>：去掉a在二进制表示中最右边的1</p><p><code>A &amp; (B - 1) = A % B</code>：此公式仅在B是2的幂次方时成立</p>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(2)</title>
    <link href="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/"/>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/</url>
    
    <content type="html"><![CDATA[<h2 id="分析leveldb的架构">分析levelDB的架构</h2><span id="more"></span><hr><h3 id="leveldb的组件">levelDB的组件</h3><p>levelDB由以下几个组件组成：<code>MemTable</code>，<code>Immutable MemTable</code>，<code>WAL</code>，<code>SSTable</code>，<code>Manifest</code>，<code>Current</code>，<code>Compaction</code></p><img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/pic1.jpg" class="" title="_"><div class="note note-primary">            <p><strong><em>MemTable</em></strong>：这个组件是操作的入口，是常驻内存的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>树，所有的写入操作都将被直接写入到此树中。另外这棵树是有序的，可以对其进行快速查找和遍历，也支持数据库的操作。</p><p>它本身就可以看成是一个数据库，相当于levelDB内置的redis。</p><p>当其占用空间到达一个阈值时，就转换成一个<code>Immutable MemTable</code>供后续合并，同时生成一个新的<code>MemTable</code>来继续执行下去。</p>          </div><div class="note note-primary">            <p><strong><em>ImmutableMemTable</em></strong>：这个组件是内存与磁盘的交互组件。它与<code>MemTable</code>完全一样，仅仅在于其是只读结构。</p><p>当生成<code>Immutable MemTable</code>后，后台线程会将其创建出一个<code>SSTable</code>，并归并到磁盘中。</p>          </div><div class="note note-primary">            <p><strong><em>WAL</em></strong>：即write aheadlog，在写入到数据库之前，先写入到日志文件。</p><p>这样做的目的是为了不丢失数据，由于<code>MemTable</code>位于内存中，写入一些数据后，其不能立刻同步到磁盘中，如果突然掉电，这样写入的数据就丢失了。而<code>WAL</code>位于磁盘中，不过由于日志结构是顺序写，因此其写入效率也是很高的。</p><p>每次数据库重启时都需要读取日志并进行恢复，如果日志结构太大，启动数据库的速度就会很慢。</p>          </div><div class="note note-primary">            <p><strong><em>SSTable</em></strong>：即Sorted StringTable。这是比较重要的结构，虽然数据库的读写是基于<code>MemTable</code>的，但是其位于内存中，内存不是无限大的，需要被持久化到磁盘中。当创建出<code>Immutable MemTable</code>后，就会对其创建出一个<code>SSTable</code>来保存数据到磁盘上。</p><p>其有序体现在键是有序的，同时各级的<code>SSTable</code>文件之间也是有序的，即键不重叠。这样做的目的是为了保持良好的读速度。由于levelDB不需要更新磁盘数据结构，因此不需要使用B+树。当数据存储在磁盘上键有序，这样就可以使用高效的二分查找；而键不重叠则避免二分查找读多个磁盘块。</p><p>同时，将<code>MemTable</code>写入到磁盘上的<code>SSTable</code>后就可以释放掉这部分的日志空间，减少下次启动时的恢复速度。</p><p>但是当<code>SSTable</code>数目变多时，可能会导致键的范围出现重叠，这时候可以进行合并，将多个小的<code>SSTable</code>合并成一个大的，由于<code>SSTable</code>是有序的，其合并速度也是十分的快。</p>          </div><div class="note note-primary">            <p><strong><em>Manifest</em></strong>：LevelDB中有版本Version的概念，一个版本Version主要记录了每一层Level中所有文件的元数据。随着Compaction的进行，元数据会改变，所以每次还需要将改变的元数据写到MANIFEST中。</p>          </div><div class="note note-primary">            <p><strong><em>Current</em></strong>：本文件指向当前的<code>Manifest</code>文件，由于可能存在多个<code>Manifest</code>文件，<code>Current</code>文件指向我们当前需要用到的<code>Manifest</code>文件。</p>          </div><div class="note note-primary">            <p><strong><em>Compaction</em></strong>：作用是将多个小的<code>SSTable</code>合并成一个大的<code>SSTable</code>。这样可以解决查找的效率问题。</p><p>每个大的<code>SSTable</code>是键有序的，可以将其再次分成多个小的键不重叠的<code>SSTable</code>，这样每次合并时只需要合并小的<code>SSTable</code>即可，而不需要去读取一个很大的<code>SSTable</code>。</p><p>另外，由于<code>level-0</code>是直接由内存写入的，其多个<code>SSTable</code>可能存在键重叠现象，但是更高层的<code>level</code>是不存在键重叠现象的。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TODO</title>
    <link href="/2022/08/28/TODO/"/>
    <url>/2022/08/28/TODO/</url>
    
    <content type="html"><![CDATA[<p>博客补全计划...</p><span id="more"></span><p>目前，本博客刚刚建成，因此后续打算将之前的笔记转移到此博客上，从而形成一个比较集中的管理。</p><h5 id="高优先级部分">高优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">levelDB源码剖析</li><li><input type="checkbox" disabled="">CSAPP读书笔记转移</li></ul><h5 id="中优先级部分">中优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">SICP读书笔记转移</li><li><input type="checkbox" disabled="">OpenCV源码剖析</li><li><input type="checkbox" disabled="">一些的工具使用与开发</li></ul><h5 id="低优先级部分">低优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">机器学习中的笔记</li><li><input type="checkbox" disabled="">python爬虫部分，涉及xpath、re、scrapy、selenium、splash、代理池等等</li><li><input type="checkbox" disabled="">计算机网络部分笔记</li><li><input type="checkbox" disabled="">Notability上的手写笔记转成md格式存储</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(1)</title>
    <link href="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/"/>
    <url>/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/</url>
    
    <content type="html"><![CDATA[<h2 id="概述leveldb项目结构">概述levelDB项目结构</h2><span id="more"></span><hr><p><em><a href="https://zhuanlan.zhihu.com/p/203578801">参考1</a></em></p><p><em><a href="https://zhuanlan.zhihu.com/p/436037845">参考2</a></em></p><p><em><a href="https://github.com/google/leveldb">项目地址</a></em></p><hr><h3 id="leveldb项目概述">levelDB项目概述</h3><p>levelDB是一个持久化<code>kv</code>存储数据库，<code>kv</code>均为任意的字节数组。</p><p>其随机写、顺序写/读的性能很高，但是随机读的性能一般。</p><h4 id="lsm-tree">LSM Tree</h4><p>其实现原理为<code>LSM Tree</code>，简单来说就是讲磁盘的随机写转换成顺序写.</p><p>由于磁盘的寻址非常耗时，因此顺序写的速度远远超过随机写.</p><p><code>LSM Tree</code>由两部分组成分别是<code>Log structed</code>和<code>Merge Tree</code>.</p><p>其中<code>Log structed</code>是日志结构，而日志本身是不会修改的，只需要追加写.</p><p><code>Merge Tree</code>是合并树，即将多个树合并成一个更大的树.</p><p><em>所以，<code>LSM Tree</code>是数据以追加写的方式写入文件，成为一颗小树，然后合并成更大的树.</em></p><p>在<code>LSM Tree</code>中，<strong>更新一个数据不需要修改过去的旧数据</strong>，但是此时，<br>其写的性能很强大，但是需要支付额外的存储空间来作为代价。为了同步提升其读的性能，levelDB也同样支付了一些存储空间作为读性能提升的代价。</p><p>具体而言，将索引树结构拆分成多个大小逐渐变大的结构<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>，其均为有序的。</p><p>最小的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>位于内存，是所有操作数据的落脚点，保存了最近写入的kv，其也可以随时原地更新，支持随时查询。</p><img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic1.jpg" class="" title="_"><p>其余的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>均位于磁盘中，但是每棵树也是有序的。</p><p><strong><em>当执行写操作时</em></strong>：首先将数据加入到<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层索引树中，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层数据大小达到一定程度时，会执行<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>与<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>层的合并。由于两者均为有序的，所以这个过程类似一个归并，而归并这个操作只需要用到有序写，合并出来的新的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>会取代掉旧的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>到达指定大小后，也会同样向后合并。</p><img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic2.jpg" class="" title="_"><p><strong><em>当执行读操作时</em></strong>：在<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>中逐层查找，直到找到为止，因此，即使数据没有更新到较高的层中，也不影响数据的正确性。</p><p>当然，levelDB具体的实现还是存在一些细节的。</p><hr><h3 id="leveldb的项目结构">levelDB的项目结构</h3><h4 id="一些头文件及其作用">一些头文件及其作用</h4><p><code>include</code>: 函数库的头文件</p><p><code>port</code>: 可移植性相关的功能</p><p><code>util</code>: 项目用到的一些功能函数</p><p><code>table</code>: SSTable的实现</p><p><code>helpers/memenv</code>：简单完全内存的文件系统，提供操作目录文件接口</p><p><code>benchmarks</code>：性能测试相关代码</p><p><code>db</code>:数据库实现，版本管理，Compaction，WAL和MemTable实现</p><h4 id="接口文件的对应功能">接口文件的对应功能</h4><p><code>cache.h</code>:缓存接口，提供了默认的LRU缓存，也可以自己实现缓存</p><p><code>comparator.h</code>:定以数据库比较器的接口，用来比较键，可以使用默认的基于字节的比较，可以定义自己的比较器</p><p><code>dumpfile.h</code>: 以可读文本形式导出一个文件，调试使用</p><p><code>export.h</code>: 可移植性相关</p><p><code>iterator.h</code>: 迭代器接口</p><p><code>slice.h</code>: 实现一个字符串，存储指针和长度，指向字符串</p><p><code>table_builder.h</code>: 构造一个SSTable</p><p><code>write_batch.h</code>: 实现批量写入的接口</p><p><code>c.h</code>: 实现C语言相关的接口</p><p><code>db.h</code>: 操作数据库的主要接口</p><p><code>env.h</code>: 定义操作系统相关的功能，如读写文件之类的</p><p><code>filter_policy.h</code>: 定义布隆过滤器接口</p><p><code>options.h</code>: 配置选项</p><p><code>status.h</code>: 定义数据库操作的返回状态</p><p><code>table.h</code>: SSTable相关的接口</p>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

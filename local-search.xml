<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>将python中同步函数转换成多线程非阻塞函数</title>
    <link href="/2022/10/14/%E5%B0%86python%E4%B8%AD%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/14/%E5%B0%86python%E4%B8%AD%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="使用一个装饰器来将python中的同步函数转化成多线程函数">使用一个装饰器来将python中的同步函数转化成多线程函数</h2><span id="more"></span><div class="note note-info">            <p>python由于GIL锁的原因，不支持真正的多线程，但是可以利用多线程来利用由于IO引起的阻塞问题，也算是曲线多线程了。</p>          </div><h3 id="缘由">缘由</h3><p>目前我正在写一个基于<code>Requests</code>的多线程图像下载库框架，<a href="https://github.com/ppxxxg22/anime_crawler">可以查看这里，目前已经基本写完</a>。爬虫可以异步来实现高并发以充分利用网络IO的等待，但是众所周知，<code>Requests</code>库是不支持异步的，但是可以通过多线程的方式来为其实现异步，不过使用线程的开销会稍微大一些。</p><h3 id="实现方式">实现方式</h3><p>实现方式很简单，只需要一个装饰器即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_async</span>(<span class="hljs-params">callback</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exec</span>():<br>                out = func(*args, **kwargs)<br>                callback(out)<br>                <span class="hljs-keyword">return</span> out<br>            <span class="hljs-keyword">return</span> asyncio.get_event_loop().run_in_executor(<span class="hljs-literal">None</span>, __<span class="hljs-built_in">exec</span>)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_callback</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(args)<br><br><span class="hljs-meta">@run_async(<span class="hljs-params">_callback</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">return</span> requests.get(url)<br><br><br>get(<span class="hljs-string">"https://baidu.com"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"done!"</span>) <span class="hljs-comment"># 注意这里是无阻塞的</span><br><br></code></pre></td></tr></table></figure><p>只需要这样实现一个装饰器就能实现<code>requests.get()</code>函数的并发。</p><h3 id="使用线程池来进行改进">使用线程池来进行改进</h3><p>但是在时间过程中，上述代码不能长时间运行，否则内存占用会不断飙升。</p><p>原因是每次都创建出一个开销比较高的线程，但是没有进行回收，所以不断驻留在内存中导致占用过高。</p><p>不过我们可以使用线程池来修改它，将其资源限制在一定范围内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br>pool = ThreadPoolExecutor(<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_async</span>(<span class="hljs-params">callback</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exec</span>():<br>                out = func(*args, **kwargs)<br>                callback(out) <br>                <span class="hljs-keyword">return</span> out<br>            <span class="hljs-keyword">return</span> pool.submit(__<span class="hljs-built_in">exec</span>)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> inner<br><br></code></pre></td></tr></table></figure><p>这样每次都会从线程池拿一个线程出来进行处理。</p><h3 id="使其能用于类方法">使其能用于类方法</h3><p>上述代码虽然解决了内存占用问题，但是还有一个问题没有解决。</p><p>比如我定义了一个<code>Downloader</code>类，里面有<code>callback(self, *args)</code>和<code>download(self, *args)</code>函数。其中<code>download(self, *args)</code>函数负责下载任务，然后返回下载结果并交给<code>callback(self, *args)</code>处理，由于下载是并发的，所以装饰器会在<code>download(self, *args)</code>头上，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Donwloader</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,**kwargs</span>):<br>        ...<br><br><span class="hljs-meta">    @run_async(<span class="hljs-params">callback</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-comment"># 下载一些东西</span><br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-comment"># 回调函数</span><br>        ...<br><br></code></pre></td></tr></table></figure><p>但这样是不能正常工作的，因为self没有被正常传递</p><p>改成下面这样就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">from</span> anime_crawler.settings <span class="hljs-keyword">import</span> MAX_CONCURRENT_REQUESTS<br><br>pool = ThreadPoolExecutor(MAX_CONCURRENT_REQUESTS)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_async_c</span>(<span class="hljs-params">callback</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exec</span>():<br>                out = func(*args, **kwargs)<br>                callback(args[<span class="hljs-number">0</span>], out)  <span class="hljs-comment"># args[0]是self</span><br>                <span class="hljs-keyword">return</span> out<br>            <span class="hljs-keyword">return</span> pool.submit(__<span class="hljs-built_in">exec</span>)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Donwloader</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,**kwargs</span>):<br>        ...<br><br><span class="hljs-meta">    @run_async_c(<span class="hljs-params">callback</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-comment"># 下载一些东西</span><br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-comment"># 回调函数</span><br>        ...<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>异步</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(11)--内部的key结构</title>
    <link href="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/"/>
    <url>/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/</url>
    
    <content type="html"><![CDATA[<h2 id="内部的key结构">内部的key结构</h2><span id="more"></span><div class="note note-primary">            <p>源码位置与说明</p><p>db/dbformat.h db/dbformat.cc: 定义了Internal Key、LookupKey、InternalKeyComparator和InternalFilterPolicy</p>          </div><p>在levelDB中，存在着多种类型的key，而由于levelDB本身又是kv型的数据库，所以弄清楚这些key的结构与作用都是十分重要的。</p><p>其中，在levelDB中主要有以下三种类型的key，分别是<code>User Key</code>、<code>Internal Key</code>和<code>Lookup Key</code>，我们后面就针对这三种类型的key进行阐述。</p><h3 id="user-key">User Key</h3><p>UserKey顾名思义，其实就是用户插入的key-value中的key，是原始的key的形式，这种是最简单的情况，也就是读写键值对时提供的键，只是一个简单的字符串，一般用Slice来表示。</p><p>程序与levelDB交互式，使用的key就是Usr Key。</p><h3 id="internal-key">Internal Key</h3><p>第二种类型的key是InternalKey，这是SSTable中实际存储的key，也就是这个持久化有序的Map的键。但同时InternalKey是一个复合概念，是有几个部分组合成的一个key，ParsedInternalKey就是对Internal Key分拆后的结果，先来看看ParsedInternalKey的定义，这是一个结构体struct：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ParsedInternalKey</span><br>{<br>    Slice user_key;<br>    SequenceNumber sequence;<br>    ValueType type;<br><br>    <span class="hljs-built_in">ParsedInternalKey</span>() {} <span class="hljs-comment">// Intentionally left uninitialized (for speed)</span><br>    <span class="hljs-built_in">ParsedInternalKey</span>(<span class="hljs-type">const</span> Slice &amp;u, <span class="hljs-type">const</span> SequenceNumber &amp;seq, ValueType t)<br>        : <span class="hljs-built_in">user_key</span>(u), <span class="hljs-built_in">sequence</span>(seq), <span class="hljs-built_in">type</span>(t) {}<br>    <span class="hljs-function">std::string <span class="hljs-title">DebugString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>这个结构体说明ParsedInternalKey由三部分组成：user_key、序列号以及类型组成。<strong>而实际上ParsedInternalKey本身就可以看成是Internalkey。</strong></p><p>然后我们看一个比较重要的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 把ParsedInternalKey编码成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppendInternalKey</span><span class="hljs-params">(std::string *result, <span class="hljs-type">const</span> ParsedInternalKey &amp;key)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 先把user key放进去</span><br>    result-&gt;<span class="hljs-built_in">append</span>(key.user_key.<span class="hljs-built_in">data</span>(), key.user_key.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// 再把序列号和类型编码后放入</span><br>    <span class="hljs-built_in">PutFixed64</span>(result, <span class="hljs-built_in">PackSequenceAndType</span>(key.sequence, key.type));<br>}<br><br><span class="hljs-comment">// 编码序列号和类型</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">PackSequenceAndType</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> seq, ValueType t)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">assert</span>(seq &lt;= kMaxSequenceNumber);<br>    <span class="hljs-built_in">assert</span>(t &lt;= kValueTypeForSeek);<br>    <span class="hljs-keyword">return</span> (seq &lt;&lt; <span class="hljs-number">8</span>) | t;<br>}<br><br></code></pre></td></tr></table></figure><p>这两个函数是将ParsedInternalKey编码成字符串，也就是把一个结构体编码成字符串，这样就成为了真正的Internalkey。我们接来下看一下Internal key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InternalKey</span><br>{<br><span class="hljs-keyword">private</span>:<br>    std::string rep_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数，让rep_为空就说明其为非法的</span><br>    <span class="hljs-built_in">InternalKey</span>() {}<br>    <span class="hljs-comment">// 构造一个Internal Key，由userkey，序列号和类型组成</span><br>    <span class="hljs-comment">// 先把后面的部分存储到结构体中，然后调用AppendInternalKey</span><br>    <span class="hljs-comment">// 将ParsedInternalKey封装进rep_中</span><br>    <span class="hljs-built_in">InternalKey</span>(<span class="hljs-type">const</span> Slice &amp;user_key, SequenceNumber s, ValueType t)<br>    {<br>        <span class="hljs-built_in">AppendInternalKey</span>(&amp;rep_, <span class="hljs-built_in">ParsedInternalKey</span>(user_key, s, t));<br>    }<br><br>    <span class="hljs-comment">// 解码字符串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DecodeFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;s)</span></span><br><span class="hljs-function">    </span>{<br>        rep_.<span class="hljs-built_in">assign</span>(s.<span class="hljs-built_in">data</span>(), s.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> !rep_.<span class="hljs-built_in">empty</span>();<br>    }<br><br>    <span class="hljs-comment">// 返回编码信息</span><br>    <span class="hljs-function">Slice <span class="hljs-title">Encode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-built_in">assert</span>(!rep_.<span class="hljs-built_in">empty</span>());<br>        <span class="hljs-keyword">return</span> rep_;<br>    }<br><br>    <span class="hljs-comment">// 返回出user key</span><br>    <span class="hljs-function">Slice <span class="hljs-title">user_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">ExtractUserKey</span>(rep_); }<br><br>    <span class="hljs-comment">// 使用p来更新rep_</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> ParsedInternalKey &amp;p)</span></span><br><span class="hljs-function">    </span>{<br>        rep_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">AppendInternalKey</span>(&amp;rep_, p);<br>    }<br><br>    <span class="hljs-comment">// 清理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>{ rep_.<span class="hljs-built_in">clear</span>(); }<br><br>    <span class="hljs-function">std::string <span class="hljs-title">DebugString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>};<br><br><br></code></pre></td></tr></table></figure><p>InternalKey类中的私有对象就是存放编码后的Internalkey，通过上面那两个函数，我们已经知道ParsedInternalKey是怎么转换成Internalkey的，所以此处就给出Internal key的编码格式：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><br>| <span class="hljs-keyword">User</span> <span class="hljs-title">key</span> (<span class="hljs-keyword">string</span>) | sequence <span class="hljs-keyword">number</span> (<span class="hljs-number">7</span> bytes) | value <span class="hljs-keyword">type</span> (<span class="hljs-number">1</span> byte) |<br><br></code></pre></td></tr></table></figure><p>可以看到Internal Key在UserKey的后面增加了一个64位的整数，并且将这个整数分为两部分，低位的一个字节是一个ValueType，高位的7个字节是一个SequenceNumber。</p><p>ValueType是为了区分一个键是插入还是删除，删除其实也是一条数据的插入，但是是一条特殊的插入，通过在UserKey后面附上kTypeDeletion来说明要删除这个键，而kTypeValue说明是插入这个键。</p><p>SequenceNumber是一个版本号，是全局的，每次有一个键写入时，都会加一，每一个InternalKey里面都包含了不同的SequenceNumber。SequenceNumber是单调递增的，SequenceNumber越大，表示这键越新，如果UserKey相同，就会覆盖旧的键。所以就算User Key相同，对应的InternalKey也是不同的，Internal Key是全局唯一的。当我们更新一个UserKey多次时，数据库里面可能保存了多个User Key，但是它们所在的InternalKey是不同的，并且SequenceNumber可以决定写入的顺序。</p><p>当用户写入时，将User Key封装成InternalKey，保留版本信息，存储到SSTable里，当需要读取时，将User Key从InternalKey里提取出来，所有User Key相同的InternalKey里面SequenceNumber最大的InternalKey就是当前的键，它对应的值就是当前值。</p><p><strong>另外Internal Key的比较方式和UserKey是不一样的，Options提供的是UserKey的比较方式，而LevelDB内部会生成一个根据这个UserKey的比较方式得到的Internal Key的比较方式。</strong></p><p>当Internal Key里面包含的User Key不同时，直接用UserKey的比较方式即可。否则，根据SequenceNumber比较，按SequenceNumber倒序排序。这样的好处就是，在全局有序的Map里，根据UserKey排序，User Key相同的会排在一起，SequenceNumber大的InternalKey排在前面。当Seek一个User Key时，会定位到第一个符合条件的InternalKey，也就是具有最大的SequenceNumber的Internal Key。</p><p>除了比较器，布隆过滤器也会被改造，以适应User Key到InternalKey的转换。</p><p>我们再来分析以下Internal key向userkey和ParsedInternalKey转换的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 解码出user key，其实就是去掉末尾的8字节</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> Slice <span class="hljs-title">ExtractUserKey</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;internal_key)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">assert</span>(internal_key.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(internal_key.<span class="hljs-built_in">data</span>(), internal_key.<span class="hljs-built_in">size</span>() - <span class="hljs-number">8</span>);<br>}<br><br><span class="hljs-comment">// 把InternalKey转换成ParsedInternalKey</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ParseInternalKey</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;internal_key,</span></span><br><span class="hljs-params"><span class="hljs-function">                             ParsedInternalKey *result)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = internal_key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">uint64_t</span> num = <span class="hljs-built_in">DecodeFixed64</span>(internal_key.<span class="hljs-built_in">data</span>() + n - <span class="hljs-number">8</span>);<br>    <span class="hljs-type">uint8_t</span> c = num &amp; <span class="hljs-number">0xff</span>;<br>    result-&gt;sequence = num &gt;&gt; <span class="hljs-number">8</span>;<br>    result-&gt;type = <span class="hljs-built_in">static_cast</span>&lt;ValueType&gt;(c);<br>    result-&gt;user_key = <span class="hljs-built_in">Slice</span>(internal_key.<span class="hljs-built_in">data</span>(), n - <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span> (c &lt;= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(kTypeValue));<br>}<br><br></code></pre></td></tr></table></figure><p>这部分其实也是很简单的，就是对应关系而已。</p><h3 id="lookup-key">Lookup Key</h3><p>Lookup Key其实就是简单的在InternalKey前面加上键的长度，使用varint32编码，主要用在MemTable的查找上。</p><img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic1.png" class=""><p>由于MemTable的底层是一个Skiplist，而LevelDB的Skiplist只存储了一个键，而没有值。LevelDB在存储Kv时，又是将键和值编码在一起存储的，使用的就是字符串的长度前缀编码。所以在MemTable里查找Key时，提供的LookupKey就是编码值的一个前缀，刚好可以定位MemTable里相应的键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LookupKey</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// We construct a char array of the form:</span><br>    <span class="hljs-comment">//    klength  varint32               &lt;-- start_</span><br>    <span class="hljs-comment">//    userkey  char[klength]          &lt;-- kstart_</span><br>    <span class="hljs-comment">//    tag      uint64</span><br>    <span class="hljs-comment">//                                    &lt;-- end_</span><br>    <span class="hljs-comment">// The array is a suitable MemTable key.</span><br>    <span class="hljs-comment">// The suffix starting with "userkey" can be used as an InternalKey.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *start_;  <span class="hljs-comment">// 指向开头</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *kstart_; <span class="hljs-comment">// 指向internal_key</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *end_;    <span class="hljs-comment">//指向结尾</span><br>    <span class="hljs-type">char</span> space_[<span class="hljs-number">200</span>];    <span class="hljs-comment">// Avoid allocation for short keys</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数析构函数</span><br>    <span class="hljs-built_in">LookupKey</span>(<span class="hljs-type">const</span> Slice &amp;user_key, SequenceNumber sequence);<br>    <span class="hljs-built_in">LookupKey</span>(<span class="hljs-type">const</span> LookupKey &amp;) = <span class="hljs-keyword">delete</span>;<br>    LookupKey &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LookupKey &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">LookupKey</span>();<br><br>    <span class="hljs-comment">// 返回memtable_key，其实就是全部</span><br>    <span class="hljs-function">Slice <span class="hljs-title">memtable_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(start_, end_ - start_); }<br><br>    <span class="hljs-comment">// 返回internal_key，从internal_key开始到计数</span><br>    <span class="hljs-function">Slice <span class="hljs-title">internal_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(kstart_, end_ - kstart_); }<br><br>    <span class="hljs-comment">// 返回user_key，就是internal_key的前面</span><br>    <span class="hljs-function">Slice <span class="hljs-title">user_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(kstart_, end_ - kstart_ - <span class="hljs-number">8</span>); }<br>};<br><br><span class="hljs-comment">// 构造函数，使用userkey和序列号来构造looupkey</span><br>LookupKey::<span class="hljs-built_in">LookupKey</span>(<span class="hljs-type">const</span> Slice &amp;user_key, SequenceNumber s)<br>{<br>    <span class="hljs-type">size_t</span> usize = user_key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">size_t</span> needed = usize + <span class="hljs-number">13</span>; <span class="hljs-comment">// 7(序列号) + 1(类型) + 5(最长5字节可变整数编码)</span><br>    <span class="hljs-type">char</span> *dst;<br>    <span class="hljs-keyword">if</span> (needed &lt;= <span class="hljs-built_in">sizeof</span>(space_))<br>    {<br>        dst = space_;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        dst = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[needed];<br>    }<br>    start_ = dst;<br>    dst = <span class="hljs-built_in">EncodeVarint32</span>(dst, usize + <span class="hljs-number">8</span>);<br>    kstart_ = dst;<br>    std::<span class="hljs-built_in">memcpy</span>(dst, user_key.<span class="hljs-built_in">data</span>(), usize);<br>    dst += usize;<br>    <span class="hljs-built_in">EncodeFixed64</span>(dst, <span class="hljs-built_in">PackSequenceAndType</span>(s, kValueTypeForSeek));<br>    dst += <span class="hljs-number">8</span>;<br>    end_ = dst;<br>}<br><br></code></pre></td></tr></table></figure><p>我们可以看到LookupKey类中的接口可以返回memtable_key、internal_key和user_key。为了理解这一点，我们先来看一下LookupKey的构造。</p><img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic2.png" class=""><p>其内部成员作为指针分别指向了memtable_key开头、internal_key开头和结束位置。通过这几个特殊位置的指针就可以解析出所有的三种类型key。</p><p>从memtable_key()可知MemtableKey就是LookupKey，即：memtableKey ==lookupKey，而不是internalKey，是klength+internalKey。</p><p><strong>有一个部分感觉需要重点说一下</strong>，就是虽然跳表说是不存储值，只存储键(key)，但是MemTable的Add方法会把需要保存的key-value编码成长度前缀码，即相当于将key-value编码成一个'key'放入跳表中存储。</p><img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic3.png" class=""><p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分(lookupkey)，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p><h3 id="几种key的联系与区别">几种key的联系与区别</h3><p>首先，用户直接插入的key就是userkey，这个key没有经过任何的变化和编码。</p><p>然后在levelDB中，会将user key的后面添加上序列号和类型，编程Internalkey，这个key是用于SSTable的存储的。序列号是一个单调递增的数字，类型分为插入类型和删除类型。因为levelDB中不存在删除数据的说法，想要实现删除就需要插入一条类型为删除的数据。由于越大的序列号数据越新，所以读取时会返回序列号最大的数据。</p><p>在Internal key前面插入Internal key的长度，就形成了lookupkey。这个lookupkey用于MemTable，因为MemTable内部是跳表，只存储键(<strong>注意这句话该如何理解，按照上面的说法，其实是键和值都被编码成键了</strong>)。构造出lookupkey后就可以用于查找，迭代器会被定位到大于等于lookupkey的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p><img src="/2022/10/01/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-11/pic4.jpg" class=""><h2 id="总结">总结</h2><p>以上就是LevelDB的三种键，是包含的关系：</p><ul><li>User Key是用户提供的键，是我们看到的键</li><li>Internal Key是实际存储的键，支持版本号和Tag的功能</li><li>Lookup Key则是为了查找MemTable而构造的键</li></ul>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(10)--MemTable结构</title>
    <link href="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/"/>
    <url>/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/</url>
    
    <content type="html"><![CDATA[<h2 id="memtable结构">MemTable结构</h2><span id="more"></span><div class="note note-primary">            <p>源码位置与说明<br>db/skiplist.h : 跳跃表实现<br>db/memtable.h db/memtable.cc : MemTable的实现</p>          </div><p>MemTable是levelDB的存储结构，并且其是内存中的组织结构，其内部是有序的。只有当大小到达一定程度时才会被写入到磁盘上的SSTable中，这也就是为什么SSTable中写入kv时要求key是按顺序排布的，因为key再内存中就已经被组织好了。</p><img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic1.jpg" class=""><p>由于MemTable需要是按照键值对存储，且必须是有序的，所以就不能使用哈希表。对于SortedMap的实现，一般会采用红黑树，不过LevelDB采用的是Skiplist。Skiplist是一种概率性的数据结构，支持SortedMap的所有功能，性能和红黑树相当。</p><h3 id="skiplist">Skiplist</h3><p>我们先来说一下跳跃表这种数据结构，跳跃表的本体其实就是一个链表，这个链表是有序的。但是链表的查找非常慢，需要从头开始一个一个遍历，考虑到链表本身也是有序的，我们可以为其增加一些索引。</p><img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic2.jpg" class=""><p>每次查找时，先从最上层的索引开始查找，并且由于链表有序，其实这些索引相当于了二分查找，效率很高。不过这些索引其实是在插入key-value时有一定概率创建出来的，所以不是严格的二分查找。</p><p>另外，由于键是不重复的，所以不能保存相同的键。</p><p>跳跃表比红黑树的实现简单太多了，所以我们就看一下这部分的源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>; <span class="hljs-comment">// 结点</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span><br>    {<br>        kMaxHeight = <span class="hljs-number">12</span> <span class="hljs-comment">// 跳跃表的最大索引高度</span><br>    };<br><br>    <span class="hljs-comment">// 获取当前的最大高度，宽松内存序</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">GetMaxHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> max_height_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    }<br><br>    <span class="hljs-comment">// 在高度height处创建新的key</span><br>    <span class="hljs-function">Node *<span class="hljs-title">NewNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key, <span class="hljs-type">int</span> height)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RandomHeight</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;a, <span class="hljs-type">const</span> Key &amp;b)</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> (<span class="hljs-built_in">compare_</span>(a, b) == <span class="hljs-number">0</span>); }<br><br>    <span class="hljs-comment">// 如果档key在结点后面就返回true</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">KeyIsAfterNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key, Node *n)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 返回在key后面最小的结点</span><br>    <span class="hljs-function">Node *<span class="hljs-title">FindGreaterOrEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key, Node **prev)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 返回比key小的最大结点</span><br>    <span class="hljs-function">Node *<span class="hljs-title">FindLessThan</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 返回最后一个结点</span><br>    <span class="hljs-function">Node *<span class="hljs-title">FindLast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    Comparator <span class="hljs-type">const</span> compare_; <span class="hljs-comment">// 比较用比较器</span><br>    Arena *<span class="hljs-type">const</span> arena_;       <span class="hljs-comment">// 使用Arena类来为结点分配内存</span><br><br>    Node *<span class="hljs-type">const</span> head_; <span class="hljs-comment">// 头结点</span><br><br>    <span class="hljs-comment">// 最大索引高度</span><br>    std::atomic&lt;<span class="hljs-type">int</span>&gt; max_height_;<br><br>    <span class="hljs-comment">// Read/written only by Insert(). ？</span><br>    Random rnd_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 跳表使用cmp来进行比较key，使用arena来进行内存管理</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkipList</span><span class="hljs-params">(Comparator cmp, Arena *arena)</span></span>;<br><br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">const</span> SkipList &amp;) = <span class="hljs-keyword">delete</span>;<br>    SkipList &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SkipList &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 插入key，需要保证没有重复的key</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span></span>;<br><br>    <span class="hljs-comment">// 如果包含就返回true</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Contains</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;key)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 迭代器类，迭代key-value</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span><br>    {<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// Initialize an iterator over the specified list.</span><br>        <span class="hljs-comment">// The returned iterator is not valid.</span><br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(<span class="hljs-type">const</span> SkipList *list)</span></span>;<br><br>        <span class="hljs-comment">// Returns true iff the iterator is positioned at a valid node.</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>        <span class="hljs-comment">// Returns the key at the current position.</span><br>        <span class="hljs-comment">// REQUIRES: Valid()</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> Key &amp;<span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>        <span class="hljs-comment">// Advances to the next position.</span><br>        <span class="hljs-comment">// REQUIRES: Valid()</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">// Advances to the previous position.</span><br>        <span class="hljs-comment">// REQUIRES: Valid()</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prev</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">// Advance to the first entry with a key &gt;= target</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;target)</span></span>;<br><br>        <span class="hljs-comment">// Position at the first entry in list.</span><br>        <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToFirst</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">// Position at the last entry in list.</span><br>        <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> SkipList *list_;<br>        Node *node_;<br>        <span class="hljs-comment">// Intentionally copyable</span><br>    };<br>};<br><br></code></pre></td></tr></table></figure><p>跳表是一个类模板，可以传递用于比较keys的比较器和结点的内存管理器，另外，其中还存在可以迭代跳表的迭代器，由于迭代器的实现比较简单，此处就不再赘诉了。由于MemTable位于内存中，所以需要考虑到多个线程对其进行读写的情况。</p><p>跳表的内部实现全部是内联函数，且涉及到迭代器和Node结点的成员，数目比较多但是相对比较简单。</p><p>需要注意的是，在levelDB中，跳表没有删除key-value的接口。</p><p>SkipList插入一个键时，需要分配内存给一个节点，malloc是一个比较耗时的系统调用，尤其对于小内存分配来说，而且会产生很多内存碎片。</p><p>LevelDB里面的SkipList和一般的Skiplist使用有很大的不同，只会分配内存，而不需要回收小部分内存。SkipList的内存是等待MemTable写满后，转换为ImmutableMemTable，写入SSTable，写入完成后，一起被销毁。也就是内存的回收是针对整个Skiplist的。</p><p>可能会觉得传递一个管理内存的类很奇怪，我们来具体看一下调用arena类的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">NewNode</span>(<br>    <span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">int</span> height) {<br>  <span class="hljs-type">char</span>* <span class="hljs-type">const</span> node_memory = arena_-&gt;<span class="hljs-built_in">AllocateAligned</span>(<br>      <span class="hljs-built_in">sizeof</span>(Node) + <span class="hljs-built_in">sizeof</span>(std::atomic&lt;Node*&gt;) * (height - <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> (node_memory) <span class="hljs-built_in">Node</span>(key);<br>}<br><br></code></pre></td></tr></table></figure><p>我们可以看到，arena类内部是通过new来分配出一整块内存(4kb)，然后NewNode在进行内存申请时，调用arena类的分配对齐内存的接口，这其实是arena类在内部移动已经申请的内存块的指针，并不涉及到系统调用，所以会节省时间。SkipList类没有定义析构函数，所以在结束时会调用默认的析构函数，默认析构函数又会调用arena类的析构函数，而arena类的析构函数会释放arena类在生存期间申请的所有内存，这样就避免了内存泄漏的问题。</p><h3 id="memtable">MemTable</h3><p>MemTable其实就是对跳跃表的一层封装，并且其是一个智能指针的形式，采用了引用计数，将对键的查找和插入的请求，代理到相应的SkipList，调用相应的接口。</p><p>在实现中有一点值得注意，LevelDB存储的是Kv，而SkipList存储的是键，所以在MemTable里需要做一个转换。</p><p>对于插入操作，MemTable会把键和值编码在一个字符串里面，如下图所示，先是键，再是值，使用了字符串的长度前缀编码，然后将这个字符串插入到SkipList里。这里面涉及到了很多的key类型，我们先搁置在一边，大致了解一下就可以了，后面会具体阐述的。</p><img src="/2022/09/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-10/pic3.png" class=""><p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTable</span><br>{<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTableIterator</span>; <span class="hljs-comment">// 友元类，正反迭代器</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTableBackwardIterator</span>;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyComparator</span> <span class="hljs-comment">// key比较器，有好多的key，这部分后面具体说</span><br>    {<br>        <span class="hljs-type">const</span> InternalKeyComparator comparator;<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">KeyComparator</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator &amp;c)</span> : comparator(c) {</span>}<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *b)</span> <span class="hljs-type">const</span></span>;<br>    };<br><br>    <span class="hljs-keyword">typedef</span> SkipList&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, KeyComparator&gt; Table; <span class="hljs-comment">// Table是跳表的typedef</span><br><br>    <span class="hljs-comment">// 私有析构函数，因为只有Unref能调用它</span><br>    ~<span class="hljs-built_in">MemTable</span>();<br><br>    KeyComparator comparator_; <span class="hljs-comment">// key比较器</span><br>    <span class="hljs-type">int</span> refs_;                 <span class="hljs-comment">// 引用次数</span><br>    Arena arena_;              <span class="hljs-comment">// 内存管理类</span><br>    Table table_;              <span class="hljs-comment">// memtable</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// MemTables会执行引用计数，初始计数为0，调用者必须主席那个Ref()函数至少一次</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemTable</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator &amp;comparator)</span></span>;<br><br>    <span class="hljs-built_in">MemTable</span>(<span class="hljs-type">const</span> MemTable &amp;) = <span class="hljs-keyword">delete</span>;<br>    MemTable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MemTable &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 增加引用计数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>{ ++refs_; }<br><br>    <span class="hljs-comment">// 当没有引用计数时释放内存，就是一个智能指针</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        --refs_;<br>        <span class="hljs-built_in">assert</span>(refs_ &gt;= <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (refs_ &lt;= <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">// 返回大约占用了多少内存，因为是多线程的，所以只能估计</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ApproximateMemoryUsage</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 返回一个迭代器</span><br>    <span class="hljs-function">Iterator *<span class="hljs-title">NewIterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Add an entry into memtable that maps key to value at the</span><br>    <span class="hljs-comment">// specified sequence number and with the specified type.</span><br>    <span class="hljs-comment">// Typically value will be empty if type==kTypeDeletion.</span><br>    <span class="hljs-comment">// 添加一个key，type可以用来指示删除key，即把对应的value设置为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(SequenceNumber seq, ValueType type, <span class="hljs-type">const</span> Slice &amp;key,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">const</span> Slice &amp;value)</span></span>;<br><br>    <span class="hljs-comment">// If memtable contains a value for key, store it in *value and return true.</span><br>    <span class="hljs-comment">// If memtable contains a deletion for key, store a NotFound() error</span><br>    <span class="hljs-comment">// in *status and return true.</span><br>    <span class="hljs-comment">// Else, return false.</span><br>    <span class="hljs-comment">// 查找一个key，如果是被删除的key不会返回success</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey &amp;key, std::string *value, Status *s)</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>在头文件中，我们可以观察到，如果需要删除一个key，其实就是插入一条k-v，并且标注是删除即可。另外，由于levelDB中不存在相同的key，所以需要保证key-value是唯一的。下面我们来看一下具体的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 解析levelDB 中Varint32 类型的数据，在levelDB中数据一般先存储数据大小，然后存储真实的数据。</span><br><span class="hljs-comment">// p ：Varint32数据的起始地址；</span><br><span class="hljs-comment">// limit : Varint32数据最多用5位，所以limit 为p+5;</span><br><span class="hljs-comment">// v ：数据的长度；</span><br><span class="hljs-comment">// return 返回真实数据的起始地址</span><br><span class="hljs-function"><span class="hljs-type">static</span> Slice <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = data;<br>    p = <span class="hljs-built_in">GetVarint32Ptr</span>(p, p + <span class="hljs-number">5</span>, &amp;len); <span class="hljs-comment">// +5: we assume "p" is not corrupted</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(p, len);<br>}<br><br><span class="hljs-comment">// 构造函数</span><br>MemTable::<span class="hljs-built_in">MemTable</span>(<span class="hljs-type">const</span> InternalKeyComparator &amp;comparator)<br>    : <span class="hljs-built_in">comparator_</span>(comparator), <span class="hljs-built_in">refs_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">table_</span>(comparator_, &amp;arena_) {}<br><br><span class="hljs-comment">// 析构函数</span><br>MemTable::~<span class="hljs-built_in">MemTable</span>() { <span class="hljs-built_in">assert</span>(refs_ == <span class="hljs-number">0</span>); }<br><br><span class="hljs-comment">// 返回大约占用了多少字节</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">MemTable::ApproximateMemoryUsage</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> arena_.<span class="hljs-built_in">MemoryUsage</span>(); }<br><br><span class="hljs-comment">// 比较keys</span><br><span class="hljs-type">int</span> MemTable::KeyComparator::<span class="hljs-built_in">operator</span>()(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *aptr,<br>                                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *bptr) <span class="hljs-type">const</span><br>{<br>    <span class="hljs-comment">// Internal keys are encoded as length-prefixed strings.</span><br>    Slice a = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(aptr);<br>    Slice b = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(bptr);<br>    <span class="hljs-keyword">return</span> comparator.<span class="hljs-built_in">Compare</span>(a, b);<br>}<br><br><span class="hljs-comment">// 完成数据的编码，前缀码，长度在前，数据在后</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">EncodeKey</span><span class="hljs-params">(std::string *scratch, <span class="hljs-type">const</span> Slice &amp;target)</span></span><br><span class="hljs-function"></span>{<br>    scratch-&gt;<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">PutVarint32</span>(scratch, target.<span class="hljs-built_in">size</span>());<br>    scratch-&gt;<span class="hljs-built_in">append</span>(target.<span class="hljs-built_in">data</span>(), target.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> scratch-&gt;<span class="hljs-built_in">data</span>();<br>}<br><br><span class="hljs-comment">// 迭代器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTableIterator</span> : <span class="hljs-keyword">public</span> Iterator<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemTableIterator</span><span class="hljs-params">(MemTable::Table *table)</span> : iter_(table) {</span>}<br><br>    <span class="hljs-built_in">MemTableIterator</span>(<span class="hljs-type">const</span> MemTableIterator &amp;) = <span class="hljs-keyword">delete</span>;<br>    MemTableIterator &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MemTableIterator &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    ~<span class="hljs-built_in">MemTableIterator</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> iter_.<span class="hljs-built_in">Valid</span>(); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;k)</span> <span class="hljs-keyword">override</span> </span>{ iter_.<span class="hljs-built_in">Seek</span>(<span class="hljs-built_in">EncodeKey</span>(&amp;tmp_, k)); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToFirst</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ iter_.<span class="hljs-built_in">SeekToFirst</span>(); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToLast</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ iter_.<span class="hljs-built_in">SeekToLast</span>(); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ iter_.<span class="hljs-built_in">Next</span>(); }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prev</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ iter_.<span class="hljs-built_in">Prev</span>(); }<br>    <span class="hljs-function">Slice <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetLengthPrefixedSlice</span>(iter_.<span class="hljs-built_in">key</span>()); }<br>    <span class="hljs-function">Slice <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        Slice key_slice = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(iter_.<span class="hljs-built_in">key</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetLengthPrefixedSlice</span>(key_slice.<span class="hljs-built_in">data</span>() + key_slice.<span class="hljs-built_in">size</span>());<br>    }<br><br>    <span class="hljs-function">Status <span class="hljs-title">status</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>(); }<br><br><span class="hljs-keyword">private</span>:<br>    MemTable::Table::Iterator iter_;<br>    std::string tmp_; <span class="hljs-comment">// For passing to EncodeKey</span><br>};<br><br><span class="hljs-function">Iterator *<span class="hljs-title">MemTable::NewIterator</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">MemTableIterator</span>(&amp;table_); }<br><br><span class="hljs-comment">// 添加一个key-value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MemTable::Add</span><span class="hljs-params">(SequenceNumber s, ValueType type, <span class="hljs-type">const</span> Slice &amp;key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> Slice &amp;value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// Format of an entry is concatenation of:</span><br>    <span class="hljs-comment">//  key_size     : varint32 of internal_key.size()</span><br>    <span class="hljs-comment">//  key bytes    : char[internal_key.size()]</span><br>    <span class="hljs-comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span><br>    <span class="hljs-comment">//  value_size   : varint32 of value.size()</span><br>    <span class="hljs-comment">//  value bytes  : char[value.size()]</span><br>    <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">size_t</span> val_size = value.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">size_t</span> internal_key_size = key_size + <span class="hljs-number">8</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> encoded_len = <span class="hljs-built_in">VarintLength</span>(internal_key_size) +<br>                               internal_key_size + <span class="hljs-built_in">VarintLength</span>(val_size) +<br>                               val_size;<br>    <span class="hljs-type">char</span> *buf = arena_.<span class="hljs-built_in">Allocate</span>(encoded_len);<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">EncodeVarint32</span>(buf, internal_key_size);<br>    std::<span class="hljs-built_in">memcpy</span>(p, key.<span class="hljs-built_in">data</span>(), key_size);<br>    p += key_size;<br>    <span class="hljs-built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="hljs-number">8</span>) | type);<br>    p += <span class="hljs-number">8</span>;<br>    p = <span class="hljs-built_in">EncodeVarint32</span>(p, val_size);<br>    std::<span class="hljs-built_in">memcpy</span>(p, value.<span class="hljs-built_in">data</span>(), val_size);<br>    <span class="hljs-built_in">assert</span>(p + val_size == buf + encoded_len);<br>    table_.<span class="hljs-built_in">Insert</span>(buf);<br>}<br><br><span class="hljs-comment">// 获取一个key</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemTable::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey &amp;key, std::string *value, Status *s)</span></span><br><span class="hljs-function"></span>{<br>    Slice memkey = key.<span class="hljs-built_in">memtable_key</span>();<br>    <span class="hljs-function">Table::Iterator <span class="hljs-title">iter</span><span class="hljs-params">(&amp;table_)</span></span>;<br>    iter.<span class="hljs-built_in">Seek</span>(memkey.<span class="hljs-built_in">data</span>());<br>    <span class="hljs-keyword">if</span> (iter.<span class="hljs-built_in">Valid</span>())<br>    {<br>        <span class="hljs-comment">// entry format is:</span><br>        <span class="hljs-comment">//    klength  varint32</span><br>        <span class="hljs-comment">//    userkey  char[klength]</span><br>        <span class="hljs-comment">//    tag      uint64</span><br>        <span class="hljs-comment">//    vlength  varint32</span><br>        <span class="hljs-comment">//    value    char[vlength]</span><br>        <span class="hljs-comment">// Check that it belongs to same user key.  We do not check the</span><br>        <span class="hljs-comment">// sequence number since the Seek() call above should have skipped</span><br>        <span class="hljs-comment">// all entries with overly large sequence numbers.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *entry = iter.<span class="hljs-built_in">key</span>();<br>        <span class="hljs-type">uint32_t</span> key_length;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key_ptr = <span class="hljs-built_in">GetVarint32Ptr</span>(entry, entry + <span class="hljs-number">5</span>, &amp;key_length);<br>        <span class="hljs-keyword">if</span> (comparator_.comparator.<span class="hljs-built_in">user_comparator</span>()-&gt;<span class="hljs-built_in">Compare</span>(<br>                <span class="hljs-built_in">Slice</span>(key_ptr, key_length - <span class="hljs-number">8</span>), key.<span class="hljs-built_in">user_key</span>()) == <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// Correct user key</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tag = <span class="hljs-built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="hljs-number">8</span>);<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="hljs-number">0xff</span>))<br>            {<br>            <span class="hljs-keyword">case</span> kTypeValue:<br>            {<br>                Slice v = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);<br>                value-&gt;<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">data</span>(), v.<span class="hljs-built_in">size</span>());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">case</span> kTypeDeletion:<br>                *s = Status::<span class="hljs-built_in">NotFound</span>(<span class="hljs-built_in">Slice</span>());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>而对于查找操作，只会按照前缀编码键，构造上面图的前半部分，而SkipList::Iterator::Seek的实现，会将迭代器定位到大于等于查找键的第一个键的位置，读出这个键，然后比对里面的键和查找的键是否相同，相同的话，才会读取对应的值，否则就是键不存在。</p><p>总体而言，MemTable结构还是比较简单的。</p><h2 id="总结">总结</h2><div class="note note-primary">            <p><strong>编程技巧</strong></p><ul><li>使用引用计数的类的析构函数可以作为私有成员来使用。</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(9)--WAL日志</title>
    <link href="/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/"/>
    <url>/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/</url>
    
    <content type="html"><![CDATA[<h2 id="wal日志的格式与构建">WAL日志的格式与构建</h2><span id="more"></span><div class="note note-primary">            <p>源码位置与说明</p><p>db/log_format.h : 定义了RecordType和一些常量<br>db/log_writer.h db/log_writer.cc :主要实现Writer::AddRecord，写一条记录到日志中<br>db/log_reader.h db/log_reader.cc :主要实现Reader::ReadRecord，读取一条日志记录</p>          </div><p>LevelDB写入一个kv时，都会先向日志里写入一条记录，这种日志一般称为WAL，也就是WriteAheadLog。这种日志最大的作用就是将对磁盘的随机写转换成了顺序写。当故障宕机时，可以通过WAL进行故障恢复。控制每次WAL写入磁盘的方式，可以控制最多可能丢失的数据量。</p><p>WAL里的内容实际就是内存里MemTable内容的持久化，当一个MemTable写满后，开启一个新的MemTable时，也同时会开启一个新的WAL，当MemTable被Dump到磁盘后，相应的WAL可以被删除。</p><p>WAL的格式很简单，由一系列32KB的Block组成，当然最后一个块可能是不满的，正在写入中。</p><img src="/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/pic1.jpg" class=""><p>而每个Block包含连续的Record，其中每个Record的格式为crc+长度+类型+value。一条记录可能全部写到一个块上，也可能跨几个块。且其中每个Record可以是不同的类型的，有以下几种类型。</p><ul><li>kZeroType：为预分配的文件保留。</li><li>kFullType：表示一条记录完整地写到了一个块上。</li><li>kFirstType：表示该条记录的第一部分。</li><li>kMiddleType：表示该条记录的中间部分。</li><li>kLastType：表示该条记录的最后一部分。</li></ul><p>可能感觉为什么需要设置这么多Record类型，原因很简单。因为WAL是由Block组成的，<strong>注意这个Block不是前面SSTable中的Block类，这里的Block指的是一种逻辑上的结构</strong>，为了便于读取，WAL中的Block大小都是固定的，为<code>kBlockSize = 32768</code>。而每条Record的大小不是固定的，因此可能会出现当前Block中放不下插入的Record，所以需要将Record进行分块插入到不同的Block中，这个类型就是为了标识出这条Record是不是被拆分之后的结果，如果是的话，那么这条Record位于未被拆分的Record中的哪部分。</p><img src="/2022/09/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-9/pic2.png" class=""><div class="note note-info">            <p>这部分可以在<code>doc/log_format.md</code>中找到</p>          </div><h4 id="源码部分">源码部分</h4><p>我们先来看一下头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writer</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 执行的操作就是构造Header，</span><br>    <span class="hljs-comment">// 调用WritableFile的append和flush，将record刷到物理磁盘上</span><br>    <span class="hljs-function">Status <span class="hljs-title">EmitPhysicalRecord</span><span class="hljs-params">(RecordType type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr, <span class="hljs-type">size_t</span> length)</span></span>;<br><br>    WritableFile *dest_;                    <span class="hljs-comment">// 可写入的WAL文件</span><br>    <span class="hljs-type">int</span> block_offset_;                      <span class="hljs-comment">// 当前的偏移值</span><br>    <span class="hljs-type">uint32_t</span> type_crc_[kMaxRecordType + <span class="hljs-number">1</span>]; <span class="hljs-comment">// CRC校验</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，此时要求dest是空的或存在dest_length长度的内容</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Writer</span><span class="hljs-params">(WritableFile *dest)</span></span>;<br>    <span class="hljs-built_in">Writer</span>(WritableFile *dest, <span class="hljs-type">uint64_t</span> dest_length);<br>    <span class="hljs-built_in">Writer</span>(<span class="hljs-type">const</span> Writer &amp;) = <span class="hljs-keyword">delete</span>;<br>    Writer &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Writer &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Writer</span>();<br><br>    <span class="hljs-comment">// 添加一条记录</span><br>    <span class="hljs-function">Status <span class="hljs-title">AddRecord</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;slice)</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>其实这个Writer接口还是非常简单的，只有一个AddRecord函数可以用来添加日志。我们来看一下它的具体实现是什么样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 初始化CRC，每个构造函数都调用这个函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">InitTypeCrc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *type_crc)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= kMaxRecordType; i++)<br>    {<br>        <span class="hljs-type">char</span> t = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(i);<br>        type_crc[i] = crc32c::<span class="hljs-built_in">Value</span>(&amp;t, <span class="hljs-number">1</span>);<br>    }<br>}<br><br><span class="hljs-comment">// 构造函数</span><br>Writer::<span class="hljs-built_in">Writer</span>(WritableFile *dest) : <span class="hljs-built_in">dest_</span>(dest), <span class="hljs-built_in">block_offset_</span>(<span class="hljs-number">0</span>)<br>{<br>    <span class="hljs-built_in">InitTypeCrc</span>(type_crc_);<br>}<br><br><span class="hljs-comment">// 构造函数2</span><br>Writer::<span class="hljs-built_in">Writer</span>(WritableFile *dest, <span class="hljs-type">uint64_t</span> dest_length)<br>    : <span class="hljs-built_in">dest_</span>(dest), <span class="hljs-built_in">block_offset_</span>(dest_length % kBlockSize)<br>{<br>    <span class="hljs-built_in">InitTypeCrc</span>(type_crc_);<br>}<br><br><span class="hljs-comment">// 析构函数</span><br>Writer::~<span class="hljs-built_in">Writer</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-comment">// 接口，添加一个Record</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::AddRecord</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;slice)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr = slice.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 获取record的数据和长度</span><br>    <span class="hljs-type">size_t</span> left = slice.<span class="hljs-built_in">size</span>();<br><br>    Status s;<br>    <span class="hljs-comment">// begin表明本条记录是第一次写入，即当前块中第一条记录</span><br>    <span class="hljs-type">bool</span> begin = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">do</span><br>    {<br>        <span class="hljs-comment">// 当前块剩余空间，用于判断头部能否完整写入</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> leftover = kBlockSize - block_offset_;<br>        <span class="hljs-built_in">assert</span>(leftover &gt;= <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize)<br>        {<br>            <span class="hljs-comment">// 如果块剩余空间小于七个字节且不等于0，说明当前无法完整写入数据</span><br>            <span class="hljs-comment">// 此时填充\x00，从下一个块写入</span><br>            <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>)<br>            {<br>                <span class="hljs-built_in">static_assert</span>(kHeaderSize == <span class="hljs-number">7</span>, <span class="hljs-string">""</span>);<br>                dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(<span class="hljs-string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));<br>            }<br>            <span class="hljs-comment">// 此时块正好写满，将block_offset_置为0，表明开始写入新的块</span><br>            block_offset_ = <span class="hljs-number">0</span>;<br>        }<br><br>        <span class="hljs-comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span><br>        <span class="hljs-built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 计算块剩余空间</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<br>        <span class="hljs-comment">// 计算当前块能够写入的数据大小（块剩余空间和记录剩余内容中最小的）</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;<br><br>        RecordType type;<br>        <span class="hljs-comment">// end表明该记录是否已经完整写入，即最后一条记录</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> end = (left == fragment_length);<br><br>        <span class="hljs-comment">// 下面判断是哪一种类型</span><br>        <span class="hljs-keyword">if</span> (begin &amp;&amp; end)<br>        {<br>            <span class="hljs-comment">// 记录为第一条且同时又是最后一条，说明当前是完整的记录，状态为kFullType</span><br>            type = kFullType;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (begin)<br>        {<br>            <span class="hljs-comment">// 只有头部</span><br>            type = kFirstType;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end)<br>        {<br>            <span class="hljs-comment">// 只有结尾</span><br>            type = kLastType;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-comment">// 既不是头也不是结尾</span><br>            type = kMiddleType;<br>        }<br><br>        <span class="hljs-comment">// 把已经写入的Record部分发射到物理磁盘中</span><br>        s = <span class="hljs-built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);<br>        ptr += fragment_length;<br>        left -= fragment_length;<br>        begin = <span class="hljs-literal">false</span>;<br>    } <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> s;<br>}<br><br><span class="hljs-comment">// 把一条Record发射保存到物理磁盘中</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::EmitPhysicalRecord</span><span class="hljs-params">(RecordType t, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> length)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">assert</span>(length &lt;= <span class="hljs-number">0xffff</span>); <span class="hljs-comment">// Must fit in two bytes</span><br>    <span class="hljs-built_in">assert</span>(block_offset_ + kHeaderSize + length &lt;= kBlockSize);<br><br>    <span class="hljs-comment">// 缓存header并计算出crc</span><br>    <span class="hljs-type">char</span> buf[kHeaderSize];<br>    buf[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &amp; <span class="hljs-number">0xff</span>);<br>    buf[<span class="hljs-number">5</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &gt;&gt; <span class="hljs-number">8</span>);<br>    buf[<span class="hljs-number">6</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(t);<br><br>    <span class="hljs-comment">// 计算crc</span><br>    <span class="hljs-type">uint32_t</span> crc = crc32c::<span class="hljs-built_in">Extend</span>(type_crc_[t], ptr, length);<br>    crc = crc32c::<span class="hljs-built_in">Mask</span>(crc);<br>    <span class="hljs-built_in">EncodeFixed32</span>(buf, crc); <span class="hljs-comment">// 编码</span><br><br>    <span class="hljs-comment">// 调用文件的相关方法来把header写入磁盘，然后把剩余部分也写入文件</span><br>    Status s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(buf, kHeaderSize));<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>())<br>    {<br>        s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(ptr, length));<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>())<br>        {<br>            s = dest_-&gt;<span class="hljs-built_in">Flush</span>();<br>        }<br>    }<br>    block_offset_ += kHeaderSize + length; <span class="hljs-comment">// 更新block的偏移位置</span><br>    <span class="hljs-keyword">return</span> s;<br>}<br><br></code></pre></td></tr></table></figure><p>其实写入逻辑也是很简单的，就是看一下当前的Block够不够，如果够的话就直接把Record写入并将类型设置为kFullType。如果当前块剩余空间小于7字节(小于header需要的字节数目)就新开一个块，并重复执行上述操作。如果当前块能够写下一部分，就把Record的一部分写入到这个块中，并设置类型为kFirstType，剩余的部分继续执行上述操作，可能会被设置为kMiddleType、kLastType这些类型，直到一条Record写完。</p><h2 id="总结">总结</h2><p>WAL日志部分的写入还是很简单的，这个类的设计的接口其实只有一个，使用起来非常方便。</p><p>另外AddRecord这个函数中的循环写入部分也是非常有意思的。</p>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(8)--Block和SSTable的构建</title>
    <link href="/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/"/>
    <url>/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/</url>
    
    <content type="html"><![CDATA[<h2 id="block和sstable的构建">Block和SSTable的构建</h2><span id="more"></span><p>我们在之前提到了SSTable和内部的各类Block的结构，也初步分析了其在源码中的类级别的组织结构，但是我们也能注意到类结构和实际写入文件的结构是存在明显差异的，所以我们现在就需要进一步了解levelDB是如何构建这些Block与SSTable的。</p><div class="note note-primary">            <p>源码位置与说明:</p><p>table/block_builder.cc table/block_builder.h : Block构建相关<br>include/leveldb/table_builder.h table/table_builder.cc :table构建相关<br>include/leveldb/table.h table/table.cc :读取一个Table的内容，产生迭代器，或者根据一个键读取一个值</p>          </div><h3 id="block的构建--blockbuilder">Block的构建--BlockBuilder</h3><p>我们之前看到的Block的类其实只有存储的数据类型、迭代器和查询相关的东西，那么Block获取到的数据是哪里来的呢？也就是哪个类来负责把一个一个kv插入到data_中呢？其实这个类就是BlockBuilder。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockBuilder</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> Options *options_;         <span class="hljs-comment">// Options选项</span><br>    std::string buffer_;             <span class="hljs-comment">// 缓冲区，是存放kv的位置</span><br>    std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; restarts_; <span class="hljs-comment">// Restart points</span><br>    <span class="hljs-type">int</span> counter_;                    <span class="hljs-comment">// 将此类重启后的元素数目</span><br>    <span class="hljs-type">bool</span> finished_;                  <span class="hljs-comment">// 是否构建完成</span><br>    std::string last_key_;           <span class="hljs-comment">//上一个key</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造析构函数相关</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BlockBuilder</span><span class="hljs-params">(<span class="hljs-type">const</span> Options *options)</span></span>;<br>    <span class="hljs-built_in">BlockBuilder</span>(<span class="hljs-type">const</span> BlockBuilder &amp;) = <span class="hljs-keyword">delete</span>;<br>    BlockBuilder &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> BlockBuilder &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 重启此类，其实就是开启新的构建，因为每个Block内的数据大小是有限制的</span><br>    <span class="hljs-comment">// 但是不需要为每个Block都创建一个BlockBuilder</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 把key-value加入，要求构建过程没有结束且key比之前加入的key要大</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;key, <span class="hljs-type">const</span> Slice &amp;value)</span></span>;<br><br>    <span class="hljs-comment">// 结束此次构建，返回一个构建结果，即data_，包含数据区和偏执区两部分</span><br>    <span class="hljs-comment">// 返回的字符串一直到下次Finish()被调用前都有效</span><br>    <span class="hljs-function">Slice <span class="hljs-title">Finish</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 返回构建的Block大小</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">CurrentSizeEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 当前构建是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> buffer_.<span class="hljs-built_in">empty</span>(); }<br>};<br><br></code></pre></td></tr></table></figure><p>我们可以看到一个BlockBuilder的作用其实就是不断把key-value添加到缓冲区中，然后在完成构建时返回这个缓冲区。由于没有必须要为每个Block都生成一个BlockBuilder类，所以BlockBuilder类是可以复用的。</p><p>下面我们来看一下具体的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>BlockBuilder::<span class="hljs-built_in">BlockBuilder</span>(<span class="hljs-type">const</span> Options *options)<br>    : <span class="hljs-built_in">options_</span>(options), <span class="hljs-built_in">restarts_</span>(), <span class="hljs-built_in">counter_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">finished_</span>(<span class="hljs-literal">false</span>)<br>{<br>    <span class="hljs-built_in">assert</span>(options-&gt;block_restart_interval &gt;= <span class="hljs-number">1</span>);<br>    restarts_.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第一个重启点就是0偏置位置</span><br>}<br><br><span class="hljs-comment">// 重启BlockBuilder类</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockBuilder::Reset</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    buffer_.<span class="hljs-built_in">clear</span>();<br>    restarts_.<span class="hljs-built_in">clear</span>();<br>    restarts_.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第一个重启点就是0偏置位置</span><br>    counter_ = <span class="hljs-number">0</span>;<br>    finished_ = <span class="hljs-literal">false</span>;<br>    last_key_.<span class="hljs-built_in">clear</span>();<br>}<br><br><span class="hljs-comment">// 返回当前的构建大小，包含三部分组成：data_[] restart_[] restart_num</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">BlockBuilder::CurrentSizeEstimate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> (buffer_.<span class="hljs-built_in">size</span>() +                      <span class="hljs-comment">// Raw data buffer</span><br>            restarts_.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>) + <span class="hljs-comment">// Restart array</span><br>            <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>));                    <span class="hljs-comment">// Restart array length</span><br>}<br><br><span class="hljs-comment">// 结束当次构建</span><br><span class="hljs-function">Slice <span class="hljs-title">BlockBuilder::Finish</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 需要把所有的重启点插入到数据后面</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; restarts_.<span class="hljs-built_in">size</span>(); i++)<br>    {<br>        <span class="hljs-built_in">PutFixed32</span>(&amp;buffer_, restarts_[i]);<br>    }<br>    <span class="hljs-built_in">PutFixed32</span>(&amp;buffer_, restarts_.<span class="hljs-built_in">size</span>());<br>    finished_ = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Slice</span>(buffer_);<br>}<br><br><span class="hljs-comment">// 插入key-value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;key, <span class="hljs-type">const</span> Slice &amp;value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">Slice <span class="hljs-title">last_key_piece</span><span class="hljs-params">(last_key_)</span></span>; <span class="hljs-comment">// 获取上一个key，需要保证当前key大于上一个key</span><br>    <span class="hljs-built_in">assert</span>(!finished_);<br>    <span class="hljs-built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);<br>    <span class="hljs-built_in">assert</span>(buffer_.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// No values yet?</span><br>           || options_-&gt;comparator-&gt;<span class="hljs-built_in">Compare</span>(key, last_key_piece) &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-type">size_t</span> shared = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算出与上一个key之间的前缀长度</span><br>    <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval)<br>    {<br>        <span class="hljs-comment">// See how much sharing to do with previous string</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_length = std::<span class="hljs-built_in">min</span>(last_key_piece.<span class="hljs-built_in">size</span>(), key.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared]))<br>        {<br>            shared++;<br>        }<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 如果某个重启点后共享key数目到达预定值就新建重启点</span><br>        restarts_.<span class="hljs-built_in">push_back</span>(buffer_.<span class="hljs-built_in">size</span>());<br>        counter_ = <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> non_shared = key.<span class="hljs-built_in">size</span>() - shared; <span class="hljs-comment">// 非共享key长度</span><br><br>    <span class="hljs-comment">// 下面就是按照key的格式插入到data_中</span><br>    <span class="hljs-comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span><br>    <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, shared);<br>    <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, non_shared);<br>    <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, value.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">// Add string delta to buffer_ followed by value</span><br>    buffer_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>    buffer_.<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br><br>    <span class="hljs-comment">// 更新类内数据</span><br>    last_key_.<span class="hljs-built_in">resize</span>(shared);<br>    last_key_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">Slice</span>(last_key_) == key);<br>    counter_++;<br>}<br><br></code></pre></td></tr></table></figure><p>我们可以看到，BlockBuilder还是很简单的，主要就是创建重启点、插入key-value，不过需要注意的是这个插入key-value的时候需要保证keys是有序的。</p><h3 id="table类">Table类</h3><p>在之前我们讲述SSTable的时候，我们其实是没有提到Table这个类的，因为前面的内容有点多，下面我们就来具体看一下这个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Table<br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TableCache</span>; <span class="hljs-comment">// 友元缓存类</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rep</span>;              <span class="hljs-comment">// 这个是一个结构体，存放xxxhandler、Block之类的</span><br><br>    <span class="hljs-comment">// 把xxxindex Block中的内容给提取出来</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Iterator *<span class="hljs-title">BlockReader</span><span class="hljs-params">(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> ReadOptions &amp;, <span class="hljs-type">const</span> Slice &amp;)</span></span>;<br><br>    <span class="hljs-comment">// 关闭构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Table</span><span class="hljs-params">(Rep *rep)</span> : rep_(rep) {</span>}<br><br>    <span class="hljs-comment">// Calls (*handle_result)(arg, ...) with the entry found after a call</span><br>    <span class="hljs-comment">// to Seek(key).  May not make such a call if filter policy says</span><br>    <span class="hljs-comment">// that key is not present.</span><br>    <span class="hljs-function">Status <span class="hljs-title">InternalGet</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions &amp;, <span class="hljs-type">const</span> Slice &amp;key, <span class="hljs-type">void</span> *arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span> *arg, <span class="hljs-type">const</span> Slice &amp;k,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> Slice &amp;v))</span></span>;<br><br>    <span class="hljs-comment">// 读取Meta Block和Filter Block</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadMeta</span><span class="hljs-params">(<span class="hljs-type">const</span> Footer &amp;footer)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;filter_handle_value)</span></span>;<br><br>    Rep *<span class="hljs-type">const</span> rep_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Attempt to open the table that is stored in bytes [0..file_size)</span><br>    <span class="hljs-comment">// of "file", and read the metadata entries necessary to allow</span><br>    <span class="hljs-comment">// retrieving data from the table.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If successful, returns ok and sets "*table" to the newly opened</span><br>    <span class="hljs-comment">// table.  The client should delete "*table" when no longer needed.</span><br>    <span class="hljs-comment">// If there was an error while initializing the table, sets "*table"</span><br>    <span class="hljs-comment">// to nullptr and returns a non-ok status.  Does not take ownership of</span><br>    <span class="hljs-comment">// "*source", but the client must ensure that "source" remains live</span><br>    <span class="hljs-comment">// for the duration of the returned table's lifetime.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// *file must remain live while this Table is in use.</span><br><br>    <span class="hljs-comment">// 打开一个可以随机读取的SSTable文件，并返回从这个文件中读取的Table类</span><br>    <span class="hljs-comment">// RandomAccessFile可以看成是一个随机读写迭代器</span><br>    <span class="hljs-comment">// 这里的原文我保留下来，写的很详细</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">Open</span><span class="hljs-params">(<span class="hljs-type">const</span> Options &amp;options, RandomAccessFile *file,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">uint64_t</span> file_size, Table **table)</span></span>;<br><br>    <span class="hljs-comment">// 构造析构函数相关</span><br>    <span class="hljs-built_in">Table</span>(<span class="hljs-type">const</span> Table &amp;) = <span class="hljs-keyword">delete</span>;<br>    Table &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Table &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Table</span>();<br><br>    <span class="hljs-comment">// 返回一个指向Table内的数据的迭代器，初始生成的迭代器不可用，需要手动初始化</span><br>    <span class="hljs-function">Iterator *<span class="hljs-title">NewIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions &amp;)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 用于估算key值所在记录的偏移，目前作用不是很清楚</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">ApproximateOffsetOf</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;key)</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>头文件中定义了缓存用的友元类、迭代器这些，说明Table类其实也没有定义怎么构建SSTable，而主要的目的是从文件中读取一个SSTable出来。</p><p>由于这其中涉及到了迭代器和缓存类，所以具体的实现我们就先略过，等到后面再详细看。</p><h3 id="table的构建--tablebuilder">Table的构建--TableBuilder</h3><p>Block的构建是通过BlockBuilder类来完成的，而Table的构建则是通过TableBuilder类来完成的。我们先来看一下其头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> TableBuilder<br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 返回构建器状态</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">status</span>().<span class="hljs-built_in">ok</span>(); }<br>    <span class="hljs-comment">// 写入Block的封装函数，对WriteRawBlock的封装</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteBlock</span><span class="hljs-params">(BlockBuilder *block, BlockHandle *handle)</span></span>;<br>    <span class="hljs-comment">// 将Block实际写入文件的函数，包含压缩类型</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteRawBlock</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;data, CompressionType, BlockHandle *handle)</span></span>;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rep</span>; <span class="hljs-comment">// 这个Rep与Table类中的Rep不一样，其声明位置是不同的</span><br>    Rep *rep_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 创建一个Builder类来完成文件的写入</span><br>    <span class="hljs-built_in">TableBuilder</span>(<span class="hljs-type">const</span> Options &amp;options, WritableFile *file);<br>    <span class="hljs-built_in">TableBuilder</span>(<span class="hljs-type">const</span> TableBuilder &amp;) = <span class="hljs-keyword">delete</span>;<br>    TableBuilder &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> TableBuilder &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">TableBuilder</span>();<br><br>    <span class="hljs-comment">// 改变Builder类的Options，只有部分选项可以被更改</span><br>    <span class="hljs-function">Status <span class="hljs-title">ChangeOptions</span><span class="hljs-params">(<span class="hljs-type">const</span> Options &amp;options)</span></span>;<br><br>    <span class="hljs-comment">// 添加一个key-value需要保证key比之前的都大</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;key, <span class="hljs-type">const</span> Slice &amp;value)</span></span>;<br><br>    <span class="hljs-comment">// 这个函数的作用是把缓存区中的key-value持久化到磁盘中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Flush</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 返回构建器的状态</span><br>    <span class="hljs-function">Status <span class="hljs-title">status</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 结束当前构建，和BlockTable中一样</span><br>    <span class="hljs-function">Status <span class="hljs-title">Finish</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 抛弃掉当前构建器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Abandon</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Add的次数</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">NumEntries</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 返回构建的文件大小</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">FileSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>我们可以看到TableBuilder的头文件中定义了将Key写入文件的部分。以及，虽然这个类中也存在一个类型为Req的东西，但是和Table类中的不是同一个东西，我们看一下其定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TableBuilder</span>::Rep<br>{<br>    <span class="hljs-built_in">Rep</span>(<span class="hljs-type">const</span> Options &amp;opt, WritableFile *f)<br>        : <span class="hljs-built_in">options</span>(opt),<br>          <span class="hljs-built_in">index_block_options</span>(opt),<br>          <span class="hljs-built_in">file</span>(f),<br>          <span class="hljs-built_in">offset</span>(<span class="hljs-number">0</span>),<br>          <span class="hljs-built_in">data_block</span>(&amp;options),<br>          <span class="hljs-built_in">index_block</span>(&amp;index_block_options),<br>          <span class="hljs-built_in">num_entries</span>(<span class="hljs-number">0</span>),<br>          <span class="hljs-built_in">closed</span>(<span class="hljs-literal">false</span>),<br>          <span class="hljs-built_in">filter_block</span>(opt.filter_policy == <span class="hljs-literal">nullptr</span><br>                           ? <span class="hljs-literal">nullptr</span><br>                           : <span class="hljs-keyword">new</span> <span class="hljs-built_in">FilterBlockBuilder</span>(opt.filter_policy)),<br>          <span class="hljs-built_in">pending_index_entry</span>(<span class="hljs-literal">false</span>)<br>    {<br>        index_block_options.block_restart_interval = <span class="hljs-number">1</span>;<br>    }<br><br>    Options options;                  <span class="hljs-comment">// 选项</span><br>    Options index_block_options;      <span class="hljs-comment">// index_block的选项</span><br>    WritableFile *file;               <span class="hljs-comment">// 写入的文件</span><br>    <span class="hljs-type">uint64_t</span> offset;                  <span class="hljs-comment">// 偏移值</span><br>    Status status;                    <span class="hljs-comment">// 状态</span><br>    BlockBuilder data_block;          <span class="hljs-comment">// data_block构建器</span><br>    BlockBuilder index_block;         <span class="hljs-comment">// index_block构建器</span><br>    std::string last_key;             <span class="hljs-comment">// 上一个写入的key</span><br>    <span class="hljs-type">int64_t</span> num_entries;              <span class="hljs-comment">// 写入的key次数</span><br>    <span class="hljs-type">bool</span> closed;                      <span class="hljs-comment">// Table构建器是否关闭</span><br>    FilterBlockBuilder *filter_block; <span class="hljs-comment">// 过滤器block</span><br><br>    <span class="hljs-comment">// We do not emit the index entry for a block until we have seen the</span><br>    <span class="hljs-comment">// first key for the next data block.  This allows us to use shorter</span><br>    <span class="hljs-comment">// keys in the index block.  For example, consider a block boundary</span><br>    <span class="hljs-comment">// between the keys "the quick brown fox" and "the who".  We can use</span><br>    <span class="hljs-comment">// "the r" as the key for the index block entry since it is &gt;= all</span><br>    <span class="hljs-comment">// entries in the first block and &lt; all entries in subsequent</span><br>    <span class="hljs-comment">// blocks.</span><br>    <span class="hljs-comment">// 这里的原注释可以好好看一下</span><br>    <span class="hljs-comment">// Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span><br>    <span class="hljs-type">bool</span> pending_index_entry;   <span class="hljs-comment">// 当data_block为空时是true否则为false</span><br>    BlockHandle pending_handle; <span class="hljs-comment">// 是一个为index_block添加数据时使用的handler</span><br><br>    std::string compressed_output; <span class="hljs-comment">// 压缩输出</span><br>};<br><br></code></pre></td></tr></table></figure><p>这个结构体中定义了table中包含的各个部分，这些部分没有直接在Table类中定义，是因为那样就会让Table类十分冗长，使用类内的一个结构体会清晰很多。实际上，TableBuilder类在进行构建的时候也是直接处理这个结构体的。</p><p>下面我们来看一下TableBuiler类的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 构造函数</span><br>TableBuilder::<span class="hljs-built_in">TableBuilder</span>(<span class="hljs-type">const</span> Options &amp;options, WritableFile *file)<br>    : <span class="hljs-built_in">rep_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Rep</span>(options, file))<br>{<br>    <span class="hljs-keyword">if</span> (rep_-&gt;filter_block != <span class="hljs-literal">nullptr</span>)<br>    {<br>        rep_-&gt;filter_block-&gt;<span class="hljs-built_in">StartBlock</span>(<span class="hljs-number">0</span>);<br>    }<br>}<br><br><span class="hljs-comment">// 析构函数</span><br>TableBuilder::~<span class="hljs-built_in">TableBuilder</span>()<br>{<br>    <span class="hljs-built_in">assert</span>(rep_-&gt;closed); <span class="hljs-comment">// Catch errors where caller forgot to call Finish()</span><br>    <span class="hljs-keyword">delete</span> rep_-&gt;filter_block;<br>    <span class="hljs-keyword">delete</span> rep_;<br>}<br><br><span class="hljs-comment">// 改变TableBudiler类的选项</span><br><span class="hljs-function">Status <span class="hljs-title">TableBuilder::ChangeOptions</span><span class="hljs-params">(<span class="hljs-type">const</span> Options &amp;options)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (options.comparator != rep_-&gt;options.comparator)<br>    {<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">InvalidArgument</span>(<span class="hljs-string">"changing comparator while building table"</span>);<br>    }<br><br>    rep_-&gt;options = options;<br>    rep_-&gt;index_block_options = options;<br>    rep_-&gt;index_block_options.block_restart_interval = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>}<br><br><span class="hljs-comment">// 添加一个key-value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;key, <span class="hljs-type">const</span> Slice &amp;value)</span></span><br><span class="hljs-function"></span>{<br>    Rep *r = rep_;<br>    <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>())<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 如果之前有添加过，则需要保证现在的key比之前的key要大</span><br>    <span class="hljs-keyword">if</span> (r-&gt;num_entries &gt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="hljs-built_in">Compare</span>(key, <span class="hljs-built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="hljs-number">0</span>);<br>    }<br><br>    <span class="hljs-comment">// pending_index_entry当data_block为空时是true，其实就是标识出重启点</span><br>    <span class="hljs-comment">// 目的是把block加入index中</span><br>    <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry)<br>    {<br>        <span class="hljs-built_in">assert</span>(r-&gt;data_block.<span class="hljs-built_in">empty</span>());<br>        <span class="hljs-comment">// 压缩一下key长度，这个压缩与重启点的压缩其实不冲突</span><br>        r-&gt;options.comparator-&gt;<span class="hljs-built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);<br>        std::string handle_encoding;<br>        r-&gt;pending_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>        <span class="hljs-comment">// 把block中的起始位置和偏移编码后存入index，因为每个重启点处相当于datablock起点</span><br>        r-&gt;index_block.<span class="hljs-built_in">Add</span>(r-&gt;last_key, <span class="hljs-built_in">Slice</span>(handle_encoding));<br>        r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>)<br>    {<br>        r-&gt;filter_block-&gt;<span class="hljs-built_in">AddKey</span>(key);<br>    }<br><br>    <span class="hljs-comment">// 更新一下参数并把key-value加入到data_block中</span><br>    r-&gt;last_key.<span class="hljs-built_in">assign</span>(key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>());<br>    r-&gt;num_entries++;<br>    r-&gt;data_block.<span class="hljs-built_in">Add</span>(key, value);<br><br>    <span class="hljs-comment">// 如果目前缓冲区数据长度比较长就持久化到文件</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="hljs-built_in">CurrentSizeEstimate</span>();<br>    <span class="hljs-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size)<br>    {<br>        <span class="hljs-built_in">Flush</span>();<br>    }<br>}<br><br><span class="hljs-comment">// 持久化到文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Flush</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Rep *r = rep_;<br>    <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>())<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (r-&gt;data_block.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">assert</span>(!r-&gt;pending_index_entry);<br>    <span class="hljs-built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle); <span class="hljs-comment">// 调用TableBuilder写入文件的函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>())<br>    {<br>        r-&gt;pending_index_entry = <span class="hljs-literal">true</span>;<br>        r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Flush</span>(); <span class="hljs-comment">// 调用文件的持久化函数</span><br>    }<br>    <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>)<br>    {<br>        r-&gt;filter_block-&gt;<span class="hljs-built_in">StartBlock</span>(r-&gt;offset); <span class="hljs-comment">// 布隆过滤器</span><br>    }<br>}<br><br><span class="hljs-comment">// 把Table中的Block写入文件，只是这个函数是一层封装，内部只执行了压缩步骤</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::WriteBlock</span><span class="hljs-params">(BlockBuilder *block, BlockHandle *handle)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 写入文件的格式block_data, type, crc</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">ok</span>());<br>    Rep *r = rep_;<br>    Slice raw = block-&gt;<span class="hljs-built_in">Finish</span>(); <span class="hljs-comment">// 拿出Block的数据</span><br><br>    Slice block_contents;<br>    CompressionType type = r-&gt;options.compression; <span class="hljs-comment">// 压缩类型</span><br>    <span class="hljs-keyword">switch</span> (type)                                  <span class="hljs-comment">// 根据压缩类型来执行压缩</span><br>    {<br>    <span class="hljs-keyword">case</span> kNoCompression: <span class="hljs-comment">// 不压缩</span><br>        block_contents = raw;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> kSnappyCompression: <span class="hljs-comment">// Snappy压缩</span><br>    {<br>        std::string *compressed = &amp;r-&gt;compressed_output;<br>        <span class="hljs-keyword">if</span> (port::<span class="hljs-built_in">Snappy_Compress</span>(raw.<span class="hljs-built_in">data</span>(), raw.<span class="hljs-built_in">size</span>(), compressed) &amp;&amp;<br>            compressed-&gt;<span class="hljs-built_in">size</span>() &lt; raw.<span class="hljs-built_in">size</span>() - (raw.<span class="hljs-built_in">size</span>() / <span class="hljs-number">8u</span>))<br>        {<br>            block_contents = *compressed;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-comment">// Snappy not supported, or compressed less than 12.5%, so just</span><br>            <span class="hljs-comment">// store uncompressed form</span><br>            block_contents = raw;<br>            type = kNoCompression;<br>        }<br>        <span class="hljs-keyword">break</span>;<br>    }<br>    }<br>    <span class="hljs-comment">// 调用WriteRawBlock来真正写入文件中</span><br>    <span class="hljs-built_in">WriteRawBlock</span>(block_contents, type, handle);<br>    r-&gt;compressed_output.<span class="hljs-built_in">clear</span>();<br>    block-&gt;<span class="hljs-built_in">Reset</span>();<br>}<br><br><span class="hljs-comment">// 写入文件的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::WriteRawBlock</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;block_contents,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 CompressionType type, BlockHandle *handle)</span></span><br><span class="hljs-function"></span>{<br>    Rep *r = rep_;<br>    handle-&gt;<span class="hljs-built_in">set_offset</span>(r-&gt;offset);<br>    handle-&gt;<span class="hljs-built_in">set_size</span>(block_contents.<span class="hljs-built_in">size</span>());<br>    r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Append</span>(block_contents); <span class="hljs-comment">// 调用文件写入的函数</span><br>    <span class="hljs-keyword">if</span> (r-&gt;status.<span class="hljs-built_in">ok</span>())<br>    {<br>        <span class="hljs-type">char</span> trailer[kBlockTrailerSize]; <span class="hljs-comment">// block的尾部由压缩类型与crc组成</span><br>        trailer[<span class="hljs-number">0</span>] = type;<br>        <span class="hljs-type">uint32_t</span> crc = crc32c::<span class="hljs-built_in">Value</span>(block_contents.<span class="hljs-built_in">data</span>(), block_contents.<span class="hljs-built_in">size</span>());<br>        crc = crc32c::<span class="hljs-built_in">Extend</span>(crc, trailer, <span class="hljs-number">1</span>); <span class="hljs-comment">// Extend crc to cover block type</span><br>        <span class="hljs-built_in">EncodeFixed32</span>(trailer + <span class="hljs-number">1</span>, crc32c::<span class="hljs-built_in">Mask</span>(crc));<br>        <span class="hljs-comment">// 然后把尾部添加进文件中</span><br>        r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(trailer, kBlockTrailerSize));<br>        <span class="hljs-keyword">if</span> (r-&gt;status.<span class="hljs-built_in">ok</span>())<br>        {<br>            r-&gt;offset += block_contents.<span class="hljs-built_in">size</span>() + kBlockTrailerSize;<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 返回状态</span><br><span class="hljs-function">Status <span class="hljs-title">TableBuilder::status</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> rep_-&gt;status; }<br><br><span class="hljs-comment">// 结束构建</span><br><span class="hljs-function">Status <span class="hljs-title">TableBuilder::Finish</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Rep *r = rep_;<br>    <span class="hljs-built_in">Flush</span>();<br>    <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>    r-&gt;closed = <span class="hljs-literal">true</span>;<br><br>    BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;<br><br>    <span class="hljs-comment">// 写入filter_block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="hljs-built_in">Finish</span>(), kNoCompression,<br>                      &amp;filter_block_handle);<br>    }<br><br>    <span class="hljs-comment">// 写入metaindex_block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>())<br>    {<br>        <span class="hljs-function">BlockBuilder <span class="hljs-title">meta_index_block</span><span class="hljs-params">(&amp;r-&gt;options)</span></span>;<br>        <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>)<br>        {<br>            std::string key = <span class="hljs-string">"filter."</span>;<br>            key.<span class="hljs-built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="hljs-built_in">Name</span>());<br>            std::string handle_encoding;<br>            filter_block_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>            meta_index_block.<span class="hljs-built_in">Add</span>(key, handle_encoding);<br>        }<br>        <span class="hljs-built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);<br>    }<br><br>    <span class="hljs-comment">// 写入index_block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>())<br>    {<br>        <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry)<br>        {<br>            r-&gt;options.comparator-&gt;<span class="hljs-built_in">FindShortSuccessor</span>(&amp;r-&gt;last_key);<br>            std::string handle_encoding;<br>            r-&gt;pending_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>            r-&gt;index_block.<span class="hljs-built_in">Add</span>(r-&gt;last_key, <span class="hljs-built_in">Slice</span>(handle_encoding));<br>            r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-built_in">WriteBlock</span>(&amp;r-&gt;index_block, &amp;index_block_handle);<br>    }<br><br>    <span class="hljs-comment">// 写入table的Footer</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>())<br>    {<br>        Footer footer;<br>        footer.<span class="hljs-built_in">set_metaindex_handle</span>(metaindex_block_handle);<br>        footer.<span class="hljs-built_in">set_index_handle</span>(index_block_handle);<br>        std::string footer_encoding;<br>        footer.<span class="hljs-built_in">EncodeTo</span>(&amp;footer_encoding);<br>        r-&gt;status = r-&gt;file-&gt;<span class="hljs-built_in">Append</span>(footer_encoding);<br>        <span class="hljs-keyword">if</span> (r-&gt;status.<span class="hljs-built_in">ok</span>())<br>        {<br>            r-&gt;offset += footer_encoding.<span class="hljs-built_in">size</span>();<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> r-&gt;status;<br>}<br><br><span class="hljs-comment">// 放弃构建</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Abandon</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Rep *r = rep_;<br>    <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>    r-&gt;closed = <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// Add的次数</span><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TableBuilder::NumEntries</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> rep_-&gt;num_entries; }<br><br><span class="hljs-comment">// 文件的大小</span><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TableBuilder::FileSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> rep_-&gt;offset; }<br><br></code></pre></td></tr></table></figure><p>通过这个TableBuilder类，我们就可以很清晰地看出一个Table是怎么构建的了。下面给出构建一个Table的流程。</p><ul><li>TableBuilder类首先在类内创建出各类BlockBuilder，包括dataBlock，metadataBlock，filterBlock等等。</li><li>然后当每次需要插入一个key时就会调用TableBuilder的add方法，这个方法会自动负责处理index_block、重启点、filter_block以及对每个key进行长度压缩(这个压缩不是共享key，而是调用comparator中的FindShortestSeparator方法)。另外TableBuilder类插入key-value会首先写入内存中，只有当内存部分的大小超过一定长度才会写持久化到硬盘。</li><li>Flush函数负责将目前的数据区追加写到磁盘中，它会调用WriteBlock函数，注意Flush不会把非data_block的block持久化。</li><li>WriteBlock函数是对WriteRawBlock函数的封装。它主要是处理了数据压缩的部分，然后把压缩后的数据和压缩类型以及数据的crc校验码传递给WriteRawBlock函数。</li><li>WriteRawBlock函数是真正写入数据的函数，每个Block都由数据区和偏置区、压缩类型以及crc校验组成。</li><li>当一个table完成构建时就会调用finish函数，这个函数会负责追加写filter_block、metaindex_block、index_block和Footer。其中写入每个Block时会调用对应handler的encode函数来将每个block编码成字符串。</li></ul><p>我们继续来审视一下SSTable和Block的结构图，这样我们会更加清楚其结构。</p><img src="/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/pic1.jpg" class=""><img src="/2022/09/27/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-8/pic2.jpg" class=""><h2 id="总结">总结</h2><p>不得不说，Block的统一的设计还是非常的巧妙，所有的Block结构都是一样的，只是提供了统一的接口(Add)，内部设计包含了key的前缀压缩、偏置区、重启点等等优化设计。而filterBlock和IndexBlock等等也是包含这些偏置区和重启点的，可能会感觉有些奇怪，因为这些存储的都是过滤器或者是索引。但是由于我们不需要关心这些内部的细节，所以可以看成是数据结构内部优化即可。</p>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(7)--SSTable结构</title>
    <link href="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/"/>
    <url>/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/</url>
    
    <content type="html"><![CDATA[<h2 id="sstable结构">SSTable结构</h2><span id="more"></span><p>之前我们也提到过，levelDB的存储单元是SSTable，就即Sorted StringTable，是一个持久化的、有序的SortedMap，存储在磁盘上(除了一颗驻留在内存中)。</p><p>但是每次进行写操作时，不是直接写入SSTable，而是先写入WAL，即WriteAheadLog。这样做的目的是保存日志，因为可能会短时间内写入多条数据，而由于内存中的表项都是有序的，所以写每条数据之前必须找到其对应位置，且假如此时发生掉电或宕机，那么内存中的数据都没有了。而WAL写入的是硬盘，且其是日志结构，所以只需要进行磁盘的顺序写即可，这样一方面做了持久化，一方面也因为是顺序写不会产生明显的耗时。</p><p>SSTable是数据最终落盘的地方，而WAL保存了最近写入的数据，持久化到磁盘上，MemTable则是WAL里数据的内存表示，因为日志的格式不便于查询，在内存中才便于快速查询。</p><p>LevelDB的键值对都持久化到扩展名为ldb的文件中，一个ldb文件存储了一定键范围内的键值对，一个ldb文件就是我们的SSTable。</p><p>我们需要着重介绍一下这个SSTable。</p><h3 id="sstable的组成结构">SSTable的组成结构</h3><div class="note note-primary">            <p>源码位置与说明</p><p>table/format.h table/format.cc:编解码BlockHandler，编解码Footer，根据BlockHandler读取一个键的内容<br>table/block_builder.h table/block_builder.cc:不断添加键值对，逐渐构建一个Block，主要是添加键值对，然后生成Block的数据<br>table/block.h table/block.cc: 对一个Block进行读取相关的功能<br>table/filter_block.h table/filter_block.ccinclude/leveldb/filter_policy.h util/bloom.cc:构建布隆过滤器数据，判断键是否存在的<br>include/leveldb/table.htable/table.cc：读取一个Table的内容，产生迭代器，或者根据一个键读取一个值<br>include/leveldb/table_builder.htable/table_builder.cc：不断添加键值对，逐渐构建一个Table<br>db/build.h db/build.cc：根据一个Iterator生成一个SSTable文件</p>          </div><p>SSTable由以下几部分组成：</p><ul><li><code>Data Block</code> : 存储数据。DataBlock有多个，LevelDB将一个ldb文件里的键值对划分为多个DataBlock进行存储，每个DataBlock具有一定的大小，并且按照键的顺序进行排序，也就是后面一个DataBlock的第一个键大于前面一个Data Block的最后一个键，DataBlock可支持压缩。</li><li><code>Filter Block</code> :用于过滤数据。也设计成为多个，目前只使用了一个，存储了布隆过滤器的二进制数据。目的是当查找一个键的时候，先查一下这个过滤器，如果不在，则去别处查，这样速度会快很多。</li><li><code>Meta Index Block</code> : 存储了指向FilterBlock的指针，根据这个指针可以找到某个FilterBlock开始的位置，以及其所占用的空间，这个指针的键是MetaBlock的名称，值是一个BlockHandler，是一个文件指针。</li><li><code>Index Block</code> : 存储了指向每一个DataBlock的指针的数组，这个指针的键大于等于对应的DataBlock的最后一个键，并且小于下一个Data Block的第一个键，通过IndexBlock可以实现二分搜索，快速定位键属于哪个DataBlock，而不需要扫描所有的Data Block。</li><li><code>Footer</code> : 因为Meta Index Block和IndexBlock的大小是不固定的，没法直接定位到这两个Block，所以最后有一个大小固定的Footer，保存两个BlockHandler，分别指向MetaIndex Block和Index Block。</li></ul><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic1.jpg" class=""><p>下面我们就来分别介绍每一个组件。</p><h4 id="footer">Footer</h4><div class="note note-primary">            <p>源码位置 : <code>table/format.h</code><code>table/format.cc</code></p>          </div><p>Footer的位置是固定的，在一个SSTable的结尾。但是由于Footer中使用了一些变长整数，为了确定Footer的位置，因此需要把Footer的大小固定下来，也就是对其做一些填充。所以Footer的格式如下所示</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic2.jpg" class=""><p>最后最后还存在一个Magicnumber，这个魔数的作用是用于校验，生成的方法如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// table/format.h</span><br><br><span class="hljs-comment">// kTableMagicNumber was picked by running</span><br><span class="hljs-comment">//    echo http://code.google.com/p/leveldb/ | sha1sum</span><br><span class="hljs-comment">// and taking the leading 64 bits.</span><br><span class="hljs-comment">// 即使用echo http://code.google.com/p/leveldb/ | sha1sum生成然后截取了一部分</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kTableMagicNumber = <span class="hljs-number">0xdb4775248b80fb57</span>ull;<br><br></code></pre></td></tr></table></figure><p><strong>但是需要注意的是，这个只是文件中的存储格式，我们在Footer类中是看不到填充和魔数的</strong></p><p>我们接下来看一下Footer类的源码，由于Footer类中出现了<code>BlockHandle</code>，我们顺便把BlockHandle的类也看一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/*================BlockHandle================*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockHandle</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">uint64_t</span> offset_; <span class="hljs-comment">// Block在文件中的偏移量</span><br>    <span class="hljs-type">uint64_t</span> size_;   <span class="hljs-comment">// Block的大小</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// length of a BlockHandle最大长度</span><br>    <span class="hljs-comment">// 之所以存在最大长度是因为使用的变长整数编码</span><br>    <span class="hljs-keyword">enum</span><br>    {<br>        kMaxEncodedLength = <span class="hljs-number">10</span> + <span class="hljs-number">10</span><br>    };<br><br>    <span class="hljs-built_in">BlockHandle</span>();<br><br>    <span class="hljs-comment">// offset相关的一些方法</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">offset</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> offset_; }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_offset</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> offset)</span> </span>{ offset_ = offset; }<br><br>    <span class="hljs-comment">// size相关的一些方法</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> size_; }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_size</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> size)</span> </span>{ size_ = size; }<br><br>    <span class="hljs-comment">// 编码解码相关，把offset、size放入字符串或从字符串中解码</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EncodeTo</span><span class="hljs-params">(std::string *dst)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">Status <span class="hljs-title">DecodeFrom</span><span class="hljs-params">(Slice *input)</span></span>;<br>};<br><br><span class="hljs-comment">/*================Footer================*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Footer</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 可以理解成广义指针，指向indexblock和metaindexblock</span><br>    BlockHandle metaindex_handle_;<br>    BlockHandle index_handle_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 长度，由于有两个BlockHandle，以及一个魔数，所以总共48字节</span><br>    <span class="hljs-comment">// Footer的长度始终是固定的，如果BlockHandle没有占满，会额外引入填充</span><br>    <span class="hljs-keyword">enum</span><br>    {<br>        kEncodedLength = <span class="hljs-number">2</span> * BlockHandle::kMaxEncodedLength + <span class="hljs-number">8</span><br>    };<br><br>    <span class="hljs-built_in">Footer</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 处理metaindex_handle相关函数</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> BlockHandle &amp;<span class="hljs-title">metaindex_handle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> metaindex_handle_; }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_metaindex_handle</span><span class="hljs-params">(<span class="hljs-type">const</span> BlockHandle &amp;h)</span> </span>{ metaindex_handle_ = h; }<br><br>    <span class="hljs-comment">// 处理index_handle相关函数</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> BlockHandle &amp;<span class="hljs-title">index_handle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> index_handle_; }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_index_handle</span><span class="hljs-params">(<span class="hljs-type">const</span> BlockHandle &amp;h)</span> </span>{ index_handle_ = h; }<br><br>    <span class="hljs-comment">// 编码解码函数，填充就是在这里引入的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EncodeTo</span><span class="hljs-params">(std::string *dst)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">Status <span class="hljs-title">DecodeFrom</span><span class="hljs-params">(Slice *input)</span></span>;<br><br>};<br><br></code></pre></td></tr></table></figure><p>我们可以看到，这个BlockHandle类其中就只有两个私有成员:offset_和size_，其中offset_表示当前的这个Block位于的位置，而size_则说明了这个块的长度，即通过起始位置+长度这两个坐标就指明了一个Block。</p><p>而Footer这个类，其私有成员只有两个BlockHandle，分别指向了metaindexblock和indexblock这两个block。但是我们之前说过在文件中的Footer部分是存在填充和魔数的，可我们在类的成员中并没有看到，这是因为填充和魔数是在将类编码到文件时才会被引入，其实就是<code>Footer::EncodeTo</code>和<code>Footer::DecodeFrom</code>这两个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/*================BlockHandle================*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockHandle::EncodeTo</span><span class="hljs-params">(std::string *dst)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// Sanity check that all fields have been set</span><br>    <span class="hljs-built_in">assert</span>(offset_ != ~<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">assert</span>(size_ != ~<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 其实就是把offset和size变长整数编码后放入字符串中</span><br>    <span class="hljs-built_in">PutVarint64</span>(dst, offset_);<br>    <span class="hljs-built_in">PutVarint64</span>(dst, size_);<br>}<br><br><span class="hljs-function">Status <span class="hljs-title">BlockHandle::DecodeFrom</span><span class="hljs-params">(Slice *input)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 解码变长整数</span><br>    <span class="hljs-comment">// 还是要赞美一下这个GetVarint64中直接移动Slice的设计，太优雅了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVarint64</span>(input, &amp;offset_) &amp;&amp; <span class="hljs-built_in">GetVarint64</span>(input, &amp;size_))<br>    {<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">"bad block handle"</span>);<br>    }<br>}<br><br><span class="hljs-comment">/*================Footer================*/</span><br><br><span class="hljs-comment">// 这就是编码Footer到字符串的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Footer::EncodeTo</span><span class="hljs-params">(std::string *dst)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> original_size = dst-&gt;<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 这里调用BlockHandle的编码函数</span><br>    metaindex_handle_.<span class="hljs-built_in">EncodeTo</span>(dst);<br>    index_handle_.<span class="hljs-built_in">EncodeTo</span>(dst);<br>    <span class="hljs-comment">// 填充是在这里引入的，就是调用了string.resize()函数</span><br>    dst-&gt;<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * BlockHandle::kMaxEncodedLength);<br>    <span class="hljs-comment">// 然后插入魔数，但是不是很清楚为什么要分两次插入而不用PutFixed64</span><br>    <span class="hljs-comment">// 也许是考虑了32位机器？</span><br>    <span class="hljs-built_in">PutFixed32</span>(dst, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="hljs-number">0xffffffff</span>u));<br>    <span class="hljs-built_in">PutFixed32</span>(dst, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">assert</span>(dst-&gt;<span class="hljs-built_in">size</span>() == original_size + kEncodedLength);<br>    (<span class="hljs-type">void</span>)original_size; <span class="hljs-comment">// Disable unused variable warning.</span><br>}<br><br><span class="hljs-comment">// 从字符串中解码出Footer的函数</span><br><span class="hljs-function">Status <span class="hljs-title">Footer::DecodeFrom</span><span class="hljs-params">(Slice *input)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 获取魔数并校验</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *magic_ptr = input-&gt;<span class="hljs-built_in">data</span>() + kEncodedLength - <span class="hljs-number">8</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> magic_lo = <span class="hljs-built_in">DecodeFixed32</span>(magic_ptr);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> magic_hi = <span class="hljs-built_in">DecodeFixed32</span>(magic_ptr + <span class="hljs-number">4</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> magic = ((<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(magic_hi) &lt;&lt; <span class="hljs-number">32</span>) |<br>                            (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(magic_lo)));<br>    <span class="hljs-keyword">if</span> (magic != kTableMagicNumber)<br>    {<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">"not an sstable (bad magic number)"</span>);<br>    }<br><br>    <span class="hljs-comment">// 然后解码出两个handle，继续赞叹一下GetVarint64的那个设计(第三次了)</span><br>    Status result = metaindex_handle_.<span class="hljs-built_in">DecodeFrom</span>(input);<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">ok</span>())<br>    {<br>        result = index_handle_.<span class="hljs-built_in">DecodeFrom</span>(input);<br>    }<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">ok</span>())<br>    {<br>        <span class="hljs-comment">// 这里需要让输入的字串跳过填充和魔数</span><br>        <span class="hljs-comment">// 从而保持了处理一部分丢弃一部分的良好的特征</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *end = magic_ptr + <span class="hljs-number">8</span>;<br>        *input = <span class="hljs-built_in">Slice</span>(end, input-&gt;<span class="hljs-built_in">data</span>() + input-&gt;<span class="hljs-built_in">size</span>() - end);<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br></code></pre></td></tr></table></figure><p>通过上述代码，我们就能很清晰地看到Footer和BlcokHandle是如何处理的了。</p><h4 id="blcok">Blcok</h4><p>其实其余的所有部分都可以看成是Block，其中BlockHandler可以看成是指向Block的指针，可以用其来读取出Blcok的内容。之前也阐述过BlockHandler的结构了，下面我们来看以下Block的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Block</span><br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iter</span>;                   <span class="hljs-comment">// 迭代器类</span><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">NumRestarts</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 读取restarts的数量，这个值是放在Block块的尾部的</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data_;            <span class="hljs-comment">// 存放数据的指针</span><br>    <span class="hljs-type">size_t</span> size_;                 <span class="hljs-comment">// 长度</span><br>    <span class="hljs-type">uint32_t</span> restart_offset_;     <span class="hljs-comment">// 是restart偏移的位置</span><br>    <span class="hljs-type">bool</span> owned_;                  <span class="hljs-comment">// 表示是否拥有这个数据，自己负责数据的申请和释放</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数等类基本函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Block</span><span class="hljs-params">(<span class="hljs-type">const</span> BlockContents &amp;contents)</span></span>;<br>    <span class="hljs-built_in">Block</span>(<span class="hljs-type">const</span> Block &amp;) = <span class="hljs-keyword">delete</span>;<br>    Block &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Block &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Block</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> size_; }<br><br>    <span class="hljs-comment">// 迭代器接口</span><br>    <span class="hljs-function">Iterator *<span class="hljs-title">NewIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> Comparator *comparator)</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>我们发现这个Block的类内部还是十分简洁的，不过还是要关于其私有成员做一些说明。</p><p>首先是<code>owned_</code>这个成员，之前我们说过，levelDB的内存管理是由Arena来管理的，当数据小于1kb时直接放入Arena分配的内存块中，否则就自己new一个内存出来存放。这里的owned_成员其实就说明了data中存放的数据是自己new出来的还是Arena分配出来的，如果是自己new出来的，则需要自己进行内存管理。</p><p>然后还有一个<code>restart_offset_</code>成员，我们先不说这个成员是干什么的，我们先来看一下Block内部的存储结构(<strong>此处说的不是DataBlock</strong>)。首先，所有的有效数据都存放在<code>data_</code>中，但是一个data_肯定存放不止一个数据，而且这些数据大小也未必相同，所以为了能够准确找到这些数据，我们还额外需要记录每条数据的头部的位置，或者成为每条数据头部距离起始位置的偏移，但是数据总数不知道，所以偏移的总数也不知道，因此还需要记录偏移的总数目。就构成了下图所示的结构。</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic3.jpg" class=""><p>上图可以看成是<code>data_</code>成员的结构(<strong>这是Block内部成员的关系，跟xxxhandler无关</strong>)，前面一部分是数据区，存放了各种数据；往下是偏移区，这部分分别指向了数据，但是我们实际上存放的有序的数据，所以没必要指向所有的数据区的内容(这里后面对DataBlock继续详细说明)，<strong>最后一个是偏移区大小也称为NumRestarts</strong>。</p><p>由于其他的xxxBlock都是一个Block结构，所以都具有Block的成员，所以关于Block的具体实现我们放在后面。</p><h4 id="data-block">Data Block</h4><p>我们先来看看Data Block中的数据存放。DataBlock的默认大小是4K，但这不是固定的，有可能会超过4K，每次插入一个键值对时都会判断是否超过了4KB，如果插入一个大一点的键值对，就会超过4KB，不过一个键值对只会保存在一个DataBlock里面，不会横跨两个Data Block。</p><p>由于相邻的键有可能存在相同的前缀，考虑到这一点，LevelDB设置了前缀压缩法，也就是后面的键只需要记录与前一个键不同的部分，以及跟前一个键相同部分的长度，这样通过前一个键就可以还原出后一个键的完整Key，为何要这么设计呢？之所以这样设计是为了节省存储空间，因为Keys之间有相同部分的概率是存在的(这也是之前compare类中的两个用于压缩的方法的用武之地)。</p><p>一个KV的格式如下：共享key的长度+非共享key的长度+值value的长度+非共享key的内容+值value。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br>shared_length | non_shared_length | value_length | non_shared_contents | value<br><br></code></pre></td></tr></table></figure><p>通过shared_length和前一个键可以得到当前键的前缀，然后根据这个KV里面的后缀non_shared_contents，便可以拼接得到这个完整的键Key。通过这种前缀压缩的方式将多个KV连续存放在DataBlock里，但是这样会有一个问题，无论想查找哪一个键Key的值，都需要从Block的第一个键Key开始遍历，依次构造拼接出最终想要的key，那么搜索一个键Key就需要遍历整个Block，这样显然效率会比较低。那怎么办呢？怎么去优化？既然KV的格式已经定了（压缩共享key），要搜索一个Key就需要拼接，那能不能拼接不要无限长，把key一组一组的划分，同一组内key是可以共享的，每一组的第一个key作为起始key就不要共享，该组内后续的key与第一个key共享key，这样key的拼接就是有限次的，查找一个key不需要遍历整个Block，只需要遍历有限个Key，这样效率不会受影响。于是就引入一个叫restartpoint的概念，记录每个分组的第一个KV的位置，这个位置的KV的shared_length为0，non_shared_length就是整个Key的长度，non_shared_contents就是完整的Key。<strong>这个restartpoint其实就是之前的偏移区中的东西，这也是为什么上图中没有每个数据都被偏移区的指针指到；而我们之前说的data_中数据区，其中就是存放的多个kv。</strong>可以参考下面这张图，这里面还有一些crc校验和压缩类型之类的，我们先略过。</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic4.jpg" class=""><p>下面我们来看一下Block类的一些实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 读取numrestarts的函数，numrestarts放在data的最后</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">Block::NumRestarts</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">assert</span>(size_ &gt;= <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DecodeFixed32</span>(data_ + size_ - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>}<br><br><span class="hljs-comment">// 构造函数</span><br>Block::<span class="hljs-built_in">Block</span>(<span class="hljs-type">const</span> BlockContents &amp;contents)<br>    : <span class="hljs-built_in">data_</span>(contents.data.<span class="hljs-built_in">data</span>()),<br>      <span class="hljs-built_in">size_</span>(contents.data.<span class="hljs-built_in">size</span>()),<br>      <span class="hljs-built_in">owned_</span>(contents.heap_allocated)<br>{<br>    <span class="hljs-keyword">if</span> (size_ &lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>))<br>    {<br>        size_ = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error marker</span><br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-type">size_t</span> max_restarts_allowed = (size_ - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>)) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NumRestarts</span>() &gt; max_restarts_allowed)<br>        {<br>            <span class="hljs-comment">// The size is too small for NumRestarts()</span><br>            size_ = <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            restart_offset_ = size_ - (<span class="hljs-number">1</span> + <span class="hljs-built_in">NumRestarts</span>()) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 析构函数</span><br>Block::~<span class="hljs-built_in">Block</span>()<br>{<br>    <span class="hljs-keyword">if</span> (owned_)<br>    {<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    }<br>}<br><br><span class="hljs-comment">// 辅助函数，用于提取从p内存位置开始的entry. 也就是内容块，即data_数据区各个条目</span><br><span class="hljs-comment">// 将长度分别记录到传进来的指针里面</span><br><span class="hljs-comment">// limit是不能超出的内存的长度</span><br><span class="hljs-comment">// 如果遇到什么错误，就返回空指针</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">DecodeEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">uint32_t</span> *shared,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">uint32_t</span> *non_shared,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">uint32_t</span> *value_length)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 如果已经不足三个bytes，那么肯定是没有内容或者出错了。</span><br>    <span class="hljs-comment">// 为什么这里写明是3 bytes?</span><br>    <span class="hljs-comment">// 这是因为shared key length, non-shared key length</span><br>    <span class="hljs-comment">// value length三个长度即使是0,也会分别占用3 bytes.</span><br>    <span class="hljs-comment">// 这里相当于做了一个优化，如果三个值之和都小于128，那肯定是每个值只占一个字节</span><br>    <span class="hljs-keyword">if</span> (limit - p &lt; <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 分虽取出三个长度</span><br>    *shared = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *&gt;(p)[<span class="hljs-number">0</span>];<br>    *non_shared = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *&gt;(p)[<span class="hljs-number">1</span>];<br>    *value_length = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *&gt;(p)[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// 如查所有的长度都是小于128的。那么在压缩编码的时候，就是直接按照</span><br>    <span class="hljs-comment">// 一个byte来存放。不需要解码</span><br>    <span class="hljs-keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="hljs-number">128</span>)<br>    {<br>        <span class="hljs-comment">// Fast path: all three values are encoded in one byte each</span><br>        p += <span class="hljs-number">3</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 如果已经是整数压缩存放的，那么在编解码的时候，就需要用Varint来处理一下</span><br>        <span class="hljs-comment">// 注意每个的出错处理</span><br>        <span class="hljs-keyword">if</span> ((p = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, shared)) == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> ((p = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, non_shared)) == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> ((p = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, value_length)) == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    }<br>    <span class="hljs-comment">// 读出来的条目的长度肯定是non_shared_key_length + value_length</span><br>    <span class="hljs-comment">// 如果余下的空间没有这么多了</span><br>    <span class="hljs-comment">// 那么肯定是出错了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length))<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    }<br>    <span class="hljs-comment">// 返回non_shared_key + value 内容的超始点</span><br>    <span class="hljs-comment">// 后面在使用的时候</span><br>    <span class="hljs-comment">// (p, non_shared_key)就是非共享的key的内容</span><br>    <span class="hljs-comment">// (p+non_shared_key, value_length)就是value的内容。</span><br>    <span class="hljs-keyword">return</span> p;<br>}<br><br></code></pre></td></tr></table></figure><p>这里面的辅助函数就是用于辅助读取每个kv的key和value的，可以解析出shared、non_shared、value_length。</p><p>我们来看一下Block与Data Block的关系</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic5.jpg" class=""><p>Block中还定义了自己的迭代器类，不过这个东西与DataBlock结构无关，主要适用于遍历和构建的，我们后面再说他。</p><p>另外需要注意的是，Block本身不涉及kv的插入与删除，其只涉及到Bolck的存储、查找。</p><p>从Block的构造函数我们可以看到Block的构建来自于结构体BlockContents，这部分我们后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BlockContents</span> {<br>  Slice data;           <span class="hljs-comment">// Actual contents of data</span><br>  <span class="hljs-type">bool</span> cachable;        <span class="hljs-comment">// True iff data can be cached</span><br>  <span class="hljs-type">bool</span> heap_allocated;  <span class="hljs-comment">// True iff caller should delete[] data.data()</span><br>};<br><br></code></pre></td></tr></table></figure><h4 id="index-block">Index Block</h4><p>知道Data Block的结构后，IndexBlock就非常简单了，它其实就是存储了一个Kv数组，每一个Kv对应一个DataBlock，其中键大于等于对应的DataBlock中最后一个键，值为一个BlockHandler，可以定位到一个Data Block。IndexBlock就是Data Block的索引，搜索时可以对IndexBlock二分搜索，找到键对应的Data Block。</p><p>Index Block里面每一个Kv都是一个restartpoint，也就是没有采用前缀压缩，相当于restartpoint是一个稠密索引，每一个Kv都有一个restart point对应。</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic6.jpg" class=""><h4 id="meta-index-block">Meta Index Block</h4><p>和Index Block指向Data Block一样，Meta Index Block指向FilterBlock，是Filter Block的索引。不过目前只有一个FilterBlock，也就是里面只有一个Kv。键是FilterBlock的名字，而值是一个BlockHandler，指向对应的Filter Block。</p><p>对于目前存在的BloomFilter而言，键是<code>filter.leveldb.BuiltinBloomFilter2</code>。</p><img src="/2022/09/23/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-7/pic7.jpg" class=""><h4 id="filter-block">Filter Block</h4><p>Filter Block就是Meta Index Block中记录的布隆过滤器了。</p><p>为什么要在SSTable文件中放置一个布隆过滤器？</p><p>我们知道布隆过滤器是一种概率型的数据结构，特点是高效的插入和查询，它的作用是为了快速判定一个Key是否存在。这不是精确判断：如果一个Key判定存在，实际不一定存在；但是，如果判定一个Key不存在，那就一定不存在，其结果是假阳性的。利用这个特性，可以快速的判定一个Key是否存在，如果不存在，就不需要再去查找了，直接返回错误；如果判定存在，则需要进一步查到确定Key是否存在。</p><p>在一个SSTable文件中，正常的查找流程如下：</p><ol type="1"><li>对Index Block进行二分搜索，查到键所属的Data Block；</li><li>读取Data Block，对restartpoint进行二分搜索，查找对应的键所属的restart point；</li><li>定位到restart point处，再遍历16个Keys进行键的查找。</li></ol><p>理想情况下，Index Block可以缓存在内存中，但是DataBlock数据量太大，可能不会缓存在内存中，这样就需要一次磁盘IO，查询效率必然不高。</p><p>如何避免磁盘IO呢？怎么才能放到内存中来查找呢？布隆过滤器可以解决这个问题。布隆过滤器比较小，可以缓存在内存中，这样就可以通过布隆过滤器快速判断对应的键有没有在这个SSTable里。如果判断键在SSTable，那也只有很小的概率是键不在这个SSTable里。这是典型的用空间换时间的思想，选择布隆过滤器是因为布隆过滤器的空间占用非常小，可以加载到内存中，进行快速判定。</p><p>LevelDB采用了多个布隆过滤器，默认情况下，每2KB的数据开启一个布隆过滤器（如下定义），因此，布隆过滤器也必然组成一个数组结构，last_word就是偏移数组的位置，数组的每个值指向一个布隆过滤器的位置。</p><p>由于布隆过滤器不是重点，此处只给出头文件，实现就暂且略过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterBlockReader</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// REQUIRES: "contents" and *policy must stay live while *this is live.</span><br>    <span class="hljs-built_in">FilterBlockReader</span>(<span class="hljs-type">const</span> FilterPolicy *policy, <span class="hljs-type">const</span> Slice &amp;contents);<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">KeyMayMatch</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> block_offset, <span class="hljs-type">const</span> Slice &amp;key)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> FilterPolicy *policy_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data_;   <span class="hljs-comment">// 过滤器的起始位置</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *offset_; <span class="hljs-comment">// 偏移位置</span><br>    <span class="hljs-type">size_t</span> num_;         <span class="hljs-comment">// 偏移总数</span><br>    <span class="hljs-type">size_t</span> base_lg_;     <span class="hljs-comment">// Encoding parameter (see kFilterBaseLg in .cc file)</span><br>};<br><br></code></pre></td></tr></table></figure><h3 id="读取一个键的步骤">读取一个键的步骤</h3><p>过上面对SSTable的介绍，来总结一下在SSTable读取一个键的步骤。</p><p>要读取一个SSTable，首先需要打开这个SSTable，打开会有以下步骤:</p><ul><li>读取Footer，根据里面的读取Meta Index Block和Index Block，将IndexBlock的内容缓存到内存中；</li><li>根据Meta Index Block读取布隆过滤器的数据，缓存到内存中。</li></ul><p>至于具体的读取函数和构建函数我们后面会详细阐述。</p><p>读取一个键的步骤如下：</p><ul><li>根据键对Index Block的restart point进行二分搜索，找到这个键对应的DataBlock的BlockHandler；</li><li>根据BlockHandler的偏移计算出布隆过滤器的编号，读取相应的布隆过滤器；</li><li>通过布隆过滤器的数据判断键是否存在，不存在就结束，否则读取对应的DataBlock；</li><li>对Data Block里的restart point进行二分搜索，找到搜索键对应的restartpoint;</li><li>对这个restartpoint对应的键进行搜索，最多搜索16个键，找到键或者找不到键。</li></ul><p>通过以上步骤可以看到IndexBlock和布隆过滤器的内容都是缓存在内存里的，所以当一个键在SSTable不存在时，99%的概率是不需要磁盘IO的。</p><h2 id="总结">总结</h2><p>SSTable的实现还是相当复杂的，而且这部分涉及到了很多个类，这部分的技巧主要在数据结构上。SSTable和B+树的思想很像，就好像一个3层的B+树，Footer是根节点，定位到IndexBlock，Index Block是第二层，可以定位到Data Block。</p><p>SSTable的文件布局比较紧凑，查询效率也比较高，不需要像B+树这样复杂，因为SSTable只会整体生成，而不会增量修改，也就是SSTable是只读，这个结构就是利用了这个特性。</p>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(6)--levelDB组件</title>
    <link href="/2022/09/22/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-6/"/>
    <url>/2022/09/22/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-6/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的组件comparatorstatusenvoptions">levelDB的组件Comparator、Status、Env、Options</h2><span id="more"></span><p>levelDB中有很多常用的组件，下面我们来对其进行介绍。</p><ul><li>Comparator : 定义了比较的规则，是一个虚基类。</li><li>Status : 定义函数执行的结果信息。</li><li>Env : 封装系统相关的调用，比如文件操作，线程操作。</li><li>Options : 指定数据库选项。</li></ul><h3 id="comparator">Comparator</h3><div class="note note-primary">            <p>源码位置与说明：</p><p><code>utils/comparator.h</code> <code>utils/comparator.cc</code> :虚基类与BytewiseComparatorImpl类头文件与实现</p><p><code>db/dbformat.h</code> <code>db/format.cc</code> :InternalKeyComparator类头文件与实现</p>          </div><p>Comparator定义了比较规则，这个是一个虚基类，所以如果想要实现自定义的接口需要实现自己的类。</p><p>其中levelDB基于Comparator实现了一些内置比较类：<code>BytewiseComparatorImpl</code>和<code>InternalKeyComparator</code>，两者的作用是不同的。</p><ul><li>BytewiseComparatorImpl : 实现key的按二进制来进行比较。</li><li>InternalKeyComparator :用于内部的key比较器，基于BytewiseComparatorImpl。</li></ul><div class="note note-primary">            <p>由于levelDB是key-value的结构，其中key就是Slice对象。所以BytewiseComparatorImpl用于key之间的比较，这个key称为usr-key。</p><p>但是levelDB内部的存储的key结构并不是usr-key，所以需要默认定义两种比较类。</p>          </div><h4 id="comparator源码剖析">Comparator源码剖析</h4><p>首先我们来看一下虚基类的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Comparator<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 虚析构函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Comparator</span>();<br>    <span class="hljs-comment">// 进行比较的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;a, <span class="hljs-type">const</span> Slice &amp;b)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 返回comparator的名字，用于确认</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将start更改为一个位于[start, limit)里的最短的字符串。</span><br>    <span class="hljs-comment">// 也就是找到start和limit中的公共字符字串，并把这个字串最后一个字符ascii+1</span><br>    <span class="hljs-comment">// 这主要是为了优化SSTable里的Index Block里的索引项的长度，使得索引更短。</span><br>    <span class="hljs-comment">// 因为每一个Data Block对应的索引项大于等于这个Data Block的最后一个项，</span><br>    <span class="hljs-comment">// 而小于下一个Data Block的第一个项，通过这个函数可以减小索引项的长度；</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">FindShortestSeparator</span><span class="hljs-params">(std::string *start,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-type">const</span> Slice &amp;limit)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将key更改为大于key的最短的key</span><br>    <span class="hljs-comment">// 也就是取出key的第一个字节，然后+1</span><br>    <span class="hljs-comment">// 这也是为了减小索引项的长度</span><br>    <span class="hljs-comment">// 不过这是优化一个SSTable里最后一个索引项的。</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">FindShortSuccessor</span><span class="hljs-params">(std::string *key)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br></code></pre></td></tr></table></figure><p>其中FindShortestSeparator和FindShortSuccessor可能会令人感到疑惑，这两个方法的作用是缩短索引。因为levelDB内部是有序的，假如有这样的两个索引"Aaaaa"和"Acccc"，其实我们只需要"Ab"就能将两者分开了；另外，假如一个表中的最后一项是"Yaaaa"，我们只需要"Z"就能确定这个项的上界了。这就是这两个函数能减短索引的原理。</p><p>接下来我们来看一下BytewiseComparatorImpl类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BytewiseComparatorImpl</span> : <span class="hljs-keyword">public</span> Comparator<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BytewiseComparatorImpl</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"leveldb.BytewiseComparator"</span>; }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;a, <span class="hljs-type">const</span> Slice &amp;b)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">compare</span>(b);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortestSeparator</span><span class="hljs-params">(std::string *start,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> Slice &amp;limit)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-comment">// 先找到两者之间的最长子串</span><br>        <span class="hljs-type">size_t</span> min_length = std::<span class="hljs-built_in">min</span>(start-&gt;<span class="hljs-built_in">size</span>(), limit.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-type">size_t</span> diff_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;<br>               ((*start)[diff_index] == limit[diff_index]))<br>        {<br>            diff_index++;<br>        }<br><br>        <span class="hljs-keyword">if</span> (diff_index &gt;= min_length)<br>        {<br>            <span class="hljs-comment">// 如果一个串是另一个串的前缀就什么也不做</span><br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-comment">// 否则把start的最后一个字节+1(如果没超过255的话)</span><br>            <span class="hljs-type">uint8_t</span> diff_byte = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;((*start)[diff_index]);<br>            <span class="hljs-keyword">if</span> (diff_byte &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xff</span>) &amp;&amp;<br>                diff_byte + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(limit[diff_index]))<br>            {<br>                (*start)[diff_index]++;<br>                start-&gt;<span class="hljs-built_in">resize</span>(diff_index + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">Compare</span>(*start, limit) &lt; <span class="hljs-number">0</span>);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortSuccessor</span><span class="hljs-params">(std::string *key)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-comment">// 找到第一个能够+1的字节</span><br>        <span class="hljs-type">size_t</span> n = key-&gt;<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        {<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> byte = (*key)[i];<br>            <span class="hljs-keyword">if</span> (byte != <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xff</span>))<br>            {<br>                (*key)[i] = byte + <span class="hljs-number">1</span>;<br>                key-&gt;<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            }<br>        }<br>        <span class="hljs-comment">// 如果全是0xff，就不管了</span><br>    }<br>};<br><br><span class="hljs-comment">// 这个函数返回一个BytewiseComparatorImpl实例</span><br><span class="hljs-comment">// 之所以存在这个函数是为了保证线程安全</span><br><span class="hljs-comment">// 可以看https://www.zhihu.com/question/267013757</span><br><span class="hljs-function"><span class="hljs-type">const</span> Comparator *<span class="hljs-title">BytewiseComparator</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;<br>    <span class="hljs-keyword">return</span> singleton.<span class="hljs-built_in">get</span>();<br>}<br><br></code></pre></td></tr></table></figure><p>这部分比较的规则其实就是我们前面看到的虚基类的具体化。需要注意它存在一个为了保证线程安全的方法，进一步了解可以看<a href="https://www.zhihu.com/question/267013757">此处</a>。</p><p>接下来我们来看一下InternalKeyComparator的头文件和实现文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 头文件</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InternalKeyComparator</span> : <span class="hljs-keyword">public</span> Comparator<br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 多了一个私有成员，存放usr-key的比较函数</span><br>    <span class="hljs-type">const</span> Comparator *user_comparator_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 前面这些接口都非常简单</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">InternalKeyComparator</span><span class="hljs-params">(<span class="hljs-type">const</span> Comparator *c)</span> : user_comparator_(c) {</span>}<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;a, <span class="hljs-type">const</span> Slice &amp;b)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortestSeparator</span><span class="hljs-params">(std::string *start,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> Slice &amp;limit)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortSuccessor</span><span class="hljs-params">(std::string *key)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><br>    <span class="hljs-comment">// 返回usr-key的比较器，应该是用于判断</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> Comparator *<span class="hljs-title">user_comparator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> user_comparator_; }<br>    <span class="hljs-comment">// 这个也是比较的，InternalKey就是内部的key类型</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKey &amp;a, <span class="hljs-type">const</span> InternalKey &amp;b)</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 实现文件</span><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">InternalKeyComparator::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"leveldb.InternalKeyComparator"</span>;<br>}<br><br><span class="hljs-comment">// 比较key的类，调用的是usr-key的比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InternalKeyComparator::Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;akey, <span class="hljs-type">const</span> Slice &amp;bkey)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> r = user_comparator_-&gt;<span class="hljs-built_in">Compare</span>(<span class="hljs-built_in">ExtractUserKey</span>(akey), <span class="hljs-built_in">ExtractUserKey</span>(bkey));<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> anum = <span class="hljs-built_in">DecodeFixed64</span>(akey.<span class="hljs-built_in">data</span>() + akey.<span class="hljs-built_in">size</span>() - <span class="hljs-number">8</span>);<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bnum = <span class="hljs-built_in">DecodeFixed64</span>(bkey.<span class="hljs-built_in">data</span>() + bkey.<span class="hljs-built_in">size</span>() - <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (anum &gt; bnum)<br>        {<br>            r = <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anum &lt; bnum)<br>        {<br>            r = +<span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> r;<br>}<br><br><span class="hljs-comment">// 找到最短的分割函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InternalKeyComparator::FindShortestSeparator</span><span class="hljs-params">(std::string *start,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">const</span> Slice &amp;limit)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    Slice user_start = <span class="hljs-built_in">ExtractUserKey</span>(*start);<br>    Slice user_limit = <span class="hljs-built_in">ExtractUserKey</span>(limit);<br>    <span class="hljs-function">std::string <span class="hljs-title">tmp</span><span class="hljs-params">(user_start.data(), user_start.size())</span></span>;<br>    user_comparator_-&gt;<span class="hljs-built_in">FindShortestSeparator</span>(&amp;tmp, user_limit);<br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() &lt; user_start.<span class="hljs-built_in">size</span>() &amp;&amp;<br>        user_comparator_-&gt;<span class="hljs-built_in">Compare</span>(user_start, tmp) &lt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">PutFixed64</span>(&amp;tmp,<br>                   <span class="hljs-built_in">PackSequenceAndType</span>(kMaxSequenceNumber, kValueTypeForSeek));<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Compare</span>(*start, tmp) &lt; <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Compare</span>(tmp, limit) &lt; <span class="hljs-number">0</span>);<br>        start-&gt;<span class="hljs-built_in">swap</span>(tmp);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InternalKeyComparator::FindShortSuccessor</span><span class="hljs-params">(std::string *key)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    Slice user_key = <span class="hljs-built_in">ExtractUserKey</span>(*key);<br>    <span class="hljs-function">std::string <span class="hljs-title">tmp</span><span class="hljs-params">(user_key.data(), user_key.size())</span></span>;<br>    user_comparator_-&gt;<span class="hljs-built_in">FindShortSuccessor</span>(&amp;tmp);<br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() &lt; user_key.<span class="hljs-built_in">size</span>() &amp;&amp;<br>        user_comparator_-&gt;<span class="hljs-built_in">Compare</span>(user_key, tmp) &lt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">PutFixed64</span>(&amp;tmp,<br>                   <span class="hljs-built_in">PackSequenceAndType</span>(kMaxSequenceNumber, kValueTypeForSeek));<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Compare</span>(*key, tmp) &lt; <span class="hljs-number">0</span>);<br>        key-&gt;<span class="hljs-built_in">swap</span>(tmp);<br>    }<br>}<br><br><span class="hljs-comment">// 比较内部key的函数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">InternalKeyComparator::Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKey &amp;a,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> InternalKey &amp;b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Compare</span>(a.<span class="hljs-built_in">Encode</span>(), b.<span class="hljs-built_in">Encode</span>());<br>}<br><br></code></pre></td></tr></table></figure><p>我们可以看到InternalKeyComparator的比较其实也是基于usr-key的，不过由于内部key与usr-key存在差异，剩余的代码主要是处理差异的，具体我们先不展开。</p><h3 id="status">Status</h3><div class="note note-primary">            <p>源码位置： <code>leveldb/include/status.h</code><code>util/status.cc</code></p>          </div><p>这个类主要定义了很多操作的返回码，很多操作需要通过返回的status来判断下一步的行为。</p><h4 id="status源码剖析">Status源码剖析</h4><p>我们接下来来看一下它的头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Status<br>{<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//返回码</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Code</span><br>    {<br>        kOk = <span class="hljs-number">0</span>,<br>        kNotFound = <span class="hljs-number">1</span>,<br>        kCorruption = <span class="hljs-number">2</span>,<br>        kNotSupported = <span class="hljs-number">3</span>,<br>        kInvalidArgument = <span class="hljs-number">4</span>,<br>        kIOError = <span class="hljs-number">5</span><br>    };<br><br>    <span class="hljs-function">Code <span class="hljs-title">code</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> (state_ == <span class="hljs-literal">nullptr</span>) ? kOk : <span class="hljs-built_in">static_cast</span>&lt;Code&gt;(state_[<span class="hljs-number">4</span>]);<br>    }<br>    <span class="hljs-built_in">Status</span>(Code code, <span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2);<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">CopyState</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br><br>    <span class="hljs-comment">// 成功的时候state_为空指针，否则指向一个由new[]分配的数组</span><br>    <span class="hljs-comment">// 其中[0:3]为信息的长度</span><br>    <span class="hljs-comment">// [4]为错误码</span><br>    <span class="hljs-comment">// [5:]为信息</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *state_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造与析构函数等等一个类的必须的函数</span><br>    <span class="hljs-built_in">Status</span>() <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">state_</span>(<span class="hljs-literal">nullptr</span>) {}<br>    ~<span class="hljs-built_in">Status</span>() { <span class="hljs-keyword">delete</span>[] state_; }<br>    <span class="hljs-built_in">Status</span>(<span class="hljs-type">const</span> Status &amp;rhs);<br>    Status &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Status &amp;rhs);<br>    <span class="hljs-built_in">Status</span>(Status &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">state_</span>(rhs.state_) { rhs.state_ = <span class="hljs-literal">nullptr</span>; }<br>    Status &amp;<span class="hljs-keyword">operator</span>=(Status &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span>;<br><br>    <span class="hljs-comment">// 返回成功或错误类型</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">OK</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(); }<br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">NotFound</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2 = Slice())</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kNotFound, msg, msg2);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">Corruption</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2 = Slice())</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kCorruption, msg, msg2);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">NotSupported</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2 = Slice())</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kNotSupported, msg, msg2);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">InvalidArgument</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2 = Slice())</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kInvalidArgument, msg, msg2);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">IOError</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg, <span class="hljs-type">const</span> Slice &amp;msg2 = Slice())</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kIOError, msg, msg2);<br>    }<br><br>    <span class="hljs-comment">// state_为空就是成功</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> (state_ == <span class="hljs-literal">nullptr</span>); }<br><br>    <span class="hljs-comment">// 否则根据code()返回值来判断错误类型</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsNotFound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() == kNotFound; }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsCorruption</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() == kCorruption; }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsIOError</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() == kIOError; }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsNotSupportedError</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() == kNotSupported; }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsInvalidArgument</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">code</span>() == kInvalidArgument; }<br><br>    <span class="hljs-comment">// 根据错误类型返回一个字符串用于打印</span><br>    <span class="hljs-function">std::string <span class="hljs-title">ToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>由于这个类主要就是处理错误类型的，所以其实现也是非常简单的，此处就不展开了。</p><p>不过实现内部有一个小技巧：<strong>用memcpy去进行赋值</strong>。这个似乎会更快一些，不过我觉得这个还是用于大数组会比较好吧，毕竟针对内存块有SIMD之类的优化。</p><h3 id="env">Env</h3><div class="note note-primary">            <p>源码位置：</p><p><code>include/leveldb/env.h</code> : env相关的接口定义</p><p><code>util/env_posix.cc</code> <code>util/posix_logger.h</code> :Posix系统相关的封装，包括文件操作，文件锁，后台线程创建,Posix写日志</p><p><code>util/env_windows.cc</code> <code>util/windows_logger.h</code> :Windows相关的实现</p>          </div><p>LevelDB是一个数据库函数库，数据库总是需要操作文件和线程，这就需要做很多系统调用。各个操作系统的系统调用方式不一样，为了跨平台支持，LevelDB对这些系统调用做了一层封装，提供了统一的接口来操作，并且提供了Posix和Windows两种实现，如果需要实现其他的系统，只需要根据系统实现相应的Env即可。</p><p>不过由于这些代码实在是太多，而且也就是一些系统调用，所以此处不展开了。</p><p>里面感觉有用的就是关于多线程的一个锁的问题，但是也相对比较简单。</p><h3 id="options">Options</h3><div class="note note-primary">            <p>源码位置：<code>leveldb/include/options.h</code><code>util/options.cc</code></p>          </div><p>Options定义了操作数据库的选项，定义了3个struct来操作：</p><ul><li>Options定义打开数据库的选项</li><li>ReadOptions定义读操作相关的选项</li><li>WriteOptions定义写操作相关的选项</li></ul><p>同样的，这部分源码也非常简单，也不展开了</p><h2 id="总结">总结</h2><h3 id="编程小技巧">编程小技巧</h3><ul><li>可以定义虚基类来规定接口。</li><li>需要处理线程安全问题。</li><li>memcpy进行数组赋值会更快。</li></ul>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中更新python版本</title>
    <link href="/2022/09/21/linux%E4%B8%AD%E6%9B%B4%E6%96%B0python%E7%89%88%E6%9C%AC/"/>
    <url>/2022/09/21/linux%E4%B8%AD%E6%9B%B4%E6%96%B0python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="在linux中更新python3的版本">在linux中更新python3的版本。</h2><span id="more"></span><p>之前搞到一块rk3288的开发板，装好ubuntuserver后下一步打算配置一下环境，于是就有了这篇踩坑记录。</p><p>我这块板子上装的系统是ubuntu server14.04，版本比较老。里面的python3的版本是3.4，所以我想将其升级到3.8.1，不然nonebot2没法跑。</p><h3 id="下载工具与python源码">下载工具与python源码</h3><p>首先我们先安装好<code>gcc</code>, <code>make</code>, <code>git</code>这些基础工具以做好准备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo apt install gcc make git<br><br></code></pre></td></tr></table></figure><p>然后我们把python3.8.1的源码下载下来并解压，因为我们需要从源码来编译python3。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz<br>tar -zxvf Python-3.8.1.tgz<br><br></code></pre></td></tr></table></figure><h3 id="编译前准备">编译前准备</h3><p>但是此时我们是不能直接去python的源码下构建然后编译的，原因有以下几点</p><ul><li>openssl1.0.1是不安全的，所以python3需要1.0.2及以上版本，但是我们系统中的openssl版本为1.0.1。</li><li>还有一些前置的包没有安装。</li></ul><p>由于第二个好解决我们先来解决第二个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo apt install libffi-devel -y<br><br><span class="hljs-comment"># 也许还需要其他的包，但是我不记得了，所以如果有其他错误再安装吧</span><br><br></code></pre></td></tr></table></figure><p>下面我们来解决第一个问题，openssl也需要从源码构建。</p><h4 id="编译安装openssl">编译安装openssl</h4><p>这里参考的一篇<a href="https://stackoverflow.com/questions/53543477/building-python-3-7-1-ssl-module-failed">博客</a></p><p>首先，我们也需要安装一些前置的包并下载下来源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo apt-get install build-essential checkinstall libreadline-gplv2-dev libncursesw5-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev<br><br>wget https://www.openssl.org/source/openssl-1.0.2o.tar.gz<br>tar -zxvf openssl-1.0.2o.tar.gz<br><br></code></pre></td></tr></table></figure><p>然后开始构建编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>./config shared --prefix=/usr/local/<br><br>make -j4<br><br>sudo make install<br><br></code></pre></td></tr></table></figure><p>至此，openssl应该安装完成了。我们输入<code>openssl version</code>可以查看版本。</p><h3 id="编译python3">编译python3</h3><p>然后我们就可以正式来构建编译python3了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">cd</span> Python3.8.1<br><br>./configure --prefix=/usr/local/python3 \--with-ssl \--enable-optimizations<br><br>make -j4<br><br>sudo make install<br><br></code></pre></td></tr></table></figure><h3 id="替换软链接">替换软链接</h3><p>编译安装完成python3后我们需要更改软链接，不然还是没法用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">cd</span> /usr/bin<br>sudo <span class="hljs-built_in">mv</span> python3 python3.bak<br>sudo <span class="hljs-built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3<br><br></code></pre></td></tr></table></figure><p>然后我们输入<code>python3 --version</code>来查看python3版本是不是正确。</p><p>到这里我们虽然完成了pyhton3的安装，但是，pip3是不能使用的。</p><p>所以下一步我们是更改pip3的软链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo <span class="hljs-built_in">rm</span> -rf /usr/local/bin/pip3<br>sudo <span class="hljs-built_in">ln</span> -s /usr/local/Python3/bin/pip3 /usr/local/bin/pip3<br><br></code></pre></td></tr></table></figure><p>然后我们来试试安装一个包，如果能安装，则说明没有问题了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>pip3 install requests<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发板使用</tag>
      
      <tag>RK3288</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(5)--字符串Slice</title>
    <link href="/2022/09/20/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-5/"/>
    <url>/2022/09/20/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-5/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的字符串slice">levelDB的字符串Slice</h2><span id="more"></span><hr><p>上次我们分析编码解码的时候，注意到其中使用的参数有些是<code>Slice</code>类型，这个类型就是levelDB中自己封装的一个轻量级字符串类，其只包含了指向字符串的指针和字符串的长度。</p><div class="note note-primary">            <p>Slice可以理解成切片，因为其指向底层字符串的首地址，并且标定出长度。</p><p>但是需要注意的是，Slice中不涉及对字符串的销毁和创建，它只是<strong>指向</strong>。因此调用Slice对象时<strong>必须确保底层的字符串没有被销毁</strong>。</p>          </div><h3 id="源码解析部分">源码解析部分</h3><div class="note note-primary">            <p>源码位置： <code>utils/slice.h</code></p>          </div><p>没错，Slice对象只有一个头文件，全部方法都是内联的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Slice<br>{<br><br><span class="hljs-keyword">private</span>:               <span class="hljs-comment">//只有两个私有成员</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data_; <span class="hljs-comment">// 指向位于底层的字符串</span><br>    <span class="hljs-type">size_t</span> size_;      <span class="hljs-comment">// 标识出字符串的长度</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/****start一些构造函数start****/</span><br><br>    <span class="hljs-comment">// 空的构造函数</span><br>    <span class="hljs-built_in">Slice</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-string">""</span>), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>) {}<br>    <span class="hljs-comment">// 对字符串d进行0:n的切片，即d[:n]</span><br>    <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *d, <span class="hljs-type">size_t</span> n) : <span class="hljs-built_in">data_</span>(d), <span class="hljs-built_in">size_</span>(n) {}<br>    <span class="hljs-comment">// 对string类型s进行0:n的切片，即s[:n]</span><br>    <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">data_</span>(s.<span class="hljs-built_in">data</span>()), <span class="hljs-built_in">size_</span>(s.<span class="hljs-built_in">size</span>()) {}<br>    <span class="hljs-comment">// 指向字符串s</span><br>    <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) : <span class="hljs-built_in">data_</span>(s), <span class="hljs-built_in">size_</span>(<span class="hljs-built_in">strlen</span>(s)) {}<br><br>    <span class="hljs-comment">// 拷贝构造函数和'='运算符使用的默认的即可</span><br>    <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> Slice &amp;) = <span class="hljs-keyword">default</span>;<br>    Slice &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Slice &amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">/****end一些构造函数end****/</span><br><br>    <span class="hljs-comment">/*下面是一些公有接口*/</span><br><br>    <span class="hljs-comment">// 指向切片字符串的起始位置</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }<br>    <span class="hljs-comment">// 返回长度</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> size_; }<br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; }<br>    <span class="hljs-comment">// 执行类似字符串的str[i]的访问</span><br>    <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> n) <span class="hljs-type">const</span><br>    {<br>        <span class="hljs-built_in">assert</span>(n &lt; <span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> data_[n];<br>    }<br><br>    <span class="hljs-comment">// 清除切片</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        data_ = <span class="hljs-string">""</span>;<br>        size_ = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 移除切片前n个字节</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_prefix</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-built_in">assert</span>(n &lt;= <span class="hljs-built_in">size</span>());<br>        data_ += n;<br>        size_ -= n;<br>    }<br><br>    <span class="hljs-comment">// 将切片创建成string类</span><br>    <span class="hljs-function">std::string <span class="hljs-title">ToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(data_, size_); }<br><br>    <span class="hljs-comment">// 与另一个切片比较</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;b)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 此切片是否以切片x开头</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">starts_with</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;x)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="hljs-built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="hljs-number">0</span>));<br>    }<br>};<br><br><span class="hljs-comment">// 判断x与y是否相等</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Slice &amp;x, <span class="hljs-type">const</span> Slice &amp;y)<br>{<br>    <span class="hljs-built_in">return</span> ((x.<span class="hljs-built_in">size</span>() == y.<span class="hljs-built_in">size</span>()) &amp;&amp;<br>            (<span class="hljs-built_in">memcmp</span>(x.<span class="hljs-built_in">data</span>(), y.<span class="hljs-built_in">data</span>(), x.<span class="hljs-built_in">size</span>()) == <span class="hljs-number">0</span>));<br>}<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Slice &amp;x, <span class="hljs-type">const</span> Slice &amp;y) { <span class="hljs-keyword">return</span> !(x == y); }<br><br><span class="hljs-comment">// 比较字符串的函数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Slice::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">memcmp</span>(data_, b.data_, min_len);<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-keyword">if</span> (size_ &lt; b.size_)<br>            r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size_ &gt; b.size_)<br>            r = +<span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> r;<br>}<br><br></code></pre></td></tr></table></figure><p>Slice的实现还是非常简单的，而且它提供了非常丰富的接口。</p><p>但是Slice的实现我们也能看到一些问题：</p><ul><li>由于Slice类不涉及内存的分配和销毁，也不检查内存是否合法，因此在调用的时候需要特别注意。</li><li>Slice类不涉及原子操作，虽然大部分都是const的读取，但是在多线程中将某一个Slice对象进行修改，则所有线程都需要执行同步。</li></ul><p>关于第二点，源文件中也有说明</p><div class="note note-info">            <p>Multiple threads can invoke const methods on a Slice without externalsynchronization, but if any of the threads may call a non-const method,all threads accessing the same Slice must use externalsynchronization.</p><p>多线程在调用const方法后可以不同步，但是如果调用非const方法，所有访问被修改的Slice的线程必须执行同步。</p>          </div><h2 id="总结部分">总结部分</h2><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><ul><li>C++可以在类内或类外重载运算符，而在类内重载又可以分为'类内隐式重载'和在'类外显示重载'，这几种方式区别如下。当然，此处不考虑友元。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">x</span><br>{<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>==(x&amp; other){}; <span class="hljs-comment">// 类内隐式</span><br>}<br><br><span class="hljs-type">int</span> <span class="hljs-keyword">inline</span> x::<span class="hljs-keyword">operator</span>==(x&amp; other){};<span class="hljs-comment">// 类外显示</span><br><br><span class="hljs-type">int</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span>==(x&amp; <span class="hljs-keyword">this</span>, x&amp; other){};<span class="hljs-comment">//类外重载</span><br><br></code></pre></td></tr></table></figure>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记风火轮MIQI-RK3288开发板的踩坑过程</title>
    <link href="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="记风火轮miqi-rk3288开发板的踩坑过程">记风火轮MIQI-RK3288开发板的踩坑过程</h2><span id="more"></span><p>之前从某鱼上看到了价格比较合适的一块RK3288开发板，就顺便买下来了。记录一下烧录镜像过程中的踩坑记录。</p><img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic1.jpg" class=""><p>我买的就是上面这块板子，配置还是很不错的：RK3288四核处理器、2GDDR3、16GeMMC、4个USB2.0、HDMI、千兆网口、还有串口调试和一大票的GPIO。无论是当作家用服务器还是当超高配单片机或者是学习内核驱动开发感觉都不错，而且才100出头，这价格也不需要啥自行车。比我之前用的opiPC2这种小水管强多了(其实我就跑跑bot挂个下载器，偶尔当作vsc的远程环境来用，PC2完全是够了)。</p><img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic3.jpg" class=""><p>上面这个就是我目前的小水管服务器。</p><h3 id="镜像烧录">镜像烧录</h3><p>这块板子到手后我上电发现是Android的系统，而我是要做一个小服务器的，所以我要做的第一步就是烧录一个linux的系统上去。</p><p>由于这块板子自带了eMMC，所以不需要额外的内存卡用于烧写镜像，而是需要特殊的工具来完成烧写。</p><div class="note note-primary">            <p>有一说一，这款产品的网站做的是真垃圾捏。存的资料都是伯度网盘，好多资料都失效了；而且官方也没有详细的教程；wiki页面还全是英文的，里面的图还全都废了，真就不要国内用户了呗。</p><p>这个是<a href="http://wiki.smartfire.cn/%E9%A6%96%E9%A1%B5"><font color="#0000ff"><u>板子的页面</u></font></a>，可以感受一下。</p>          </div><p>首先，我们需要<a href="https://www.t-firefly.com/doc/download/4.html">下载瑞芯微提供的烧录工具和驱动</a>(RK3288就是瑞芯微的)。我们需要烧录到eMMC中，所以下载AndroidTools和对应的驱动并安装(现在这俩东西叫RKDevTool和RK驱动助手)。</p><img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic2.png" class=""><p>然后还需要下载我们需要的镜像。可以在<a href="https://pan.baidu.com/s/1qG8kNPaH1uARfxas7_CPvA">这里下载(提取码：4m0o)</a>，镜像在firmwares文件夹里。不过似乎<a href="https://www.t-firefly.com/doc/download/4.html">这里</a>的也能用，后面的镜像更新，所以推荐去这里下。但是这个官网的下载速度和伯度网盘差不多，我以我就找个小的下，我选了RK3288_Server_Ubuntu这个镜像，毕竟平时我也是需要关闭掉图形化显示的，所以不如干脆选一个不带图形化的界面的版本。</p><p>烧录前先把之前说的驱动装好，然后摁住板子后面的唯一一个按键不松手，把板子和电脑相连后等待几秒再松开那个按键，这样就进入了LOADER模式。打开那个AndroidTools，然后在升级固件的窗口中选择固件，然后点击烧录就完成了。</p><img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic4.png" class=""><p>然后断电再重新上电，随便找个显示器装上，就能看到成功启动了。不过由于我们没有装图形化显示界面，所以全是黑框框。<strong>以及这个默认的账号和密码都是firefly，它官网说的都不对，不过这种一般都是拿自己的公司来作为账号和密码，还是很好猜的</strong>。</p><img src="/2022/09/14/%E8%AE%B0%E9%A3%8E%E7%81%AB%E8%BD%AEMIQI-RK3288%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AE/pic5.jpg" class=""><h3 id="配置网络">配置网络</h3><p>很显然我们不能每次使用这块板子就找来显示屏和鼠标键盘这种东西连上去，否则就显得太蠢了。</p><p>我们首先需要找个好地方来放板子，这个好地方需要满足以下条件：</p><ul><li>离路由器或者交换机近，可以提供网线直连。因为板子的USB是2.0，就不要接一个愚蠢的usb网卡了，而且作为一台服务器，使用无线传输方式来接入互联网真是太掉价了。</li><li>有足够的充电设备，因为后续扩展硬盘上去是需要额外供电设备的。</li><li>比较阴凉，虽然本身散热还行，但是最好还是找个阴凉的地方。</li></ul><p>我选择把这台小服务器扔在宿舍里，虽然在实验室里可能会更好(宿舍限电，说不定啥时候就崩了)，但是实验室的交换机离我有点远，要拉一根很长的网线才行。</p><p>配置网络的时候最好将其配置成局域网内的静态IP，而不要DHCP分配。因为前者在局域网内访问会很方便，而且我这个路由器又是捡垃圾捡来的，它那个地址续租好像有点问题(不是很确定，但是非静态地址过一段时间会断网)。</p><p>首先输入<code>ifconfig</code>查看网卡和当前ip地址，然后通过修改<code>/etc/network/interfaces</code>文件来修改网卡配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo vim /etc/network/interfaces<br><br><span class="hljs-comment"># 下面是interfaces文件中的内容</span><br><br>auto eth0<br>iface eth0 inet static<br>address 192.168.1.205<br>gateway 192.168.1.1<br>netmask 255.255.255.0<br><br></code></pre></td></tr></table></figure><p>这样就配置好了静态IP。</p><h3 id="配置frp内网穿透">配置frp内网穿透</h3><p>由于这台服务器位于内网，我们要访问它就需要和它连接在一个子网内，但是这很明显不方便。而为了能够在外网访问它，我们需要使用内网穿透工具，此处选用了frp。</p><p>使用frp时，要保证我们拥有一个公网ip，frp的配置分为客户端与服务器，客户端即为我们的板子，服务器是拥有公网ip的主机。</p><p>我们首先进入frp的<a href="https://github.com/fatedier/frp/releases">github页面</a>，下载我们需要的frp程序，注意，这个程序是同步需要在我们的板子和远程主机上下载并启动的，且需要对应架构。</p><h4 id="客户端配置">客户端配置</h4><p>由于我们的板子是32位arm架构的(你可以输入<code>arch</code>来查看架构)，所以我们需要下载arm版本的frp程序并解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_arm.tar.gz<br><br>tar -zxvf frp_0.44.0_linux_arm.tar.gz<br><br><span class="hljs-built_in">cd</span> frp_0.44.0_linux_arm<br><br></code></pre></td></tr></table></figure><p>然后开始配置frp客户端，我们先将ssh进行穿透。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>vim frpc.ini<br><br><span class="hljs-comment"># 下面是配置文件内容</span><br><br>[common]<br>server_addr = 127.0.0.1 <span class="hljs-comment"># 这个是服务器端的公网ip</span><br>server_port = 7000 <span class="hljs-comment"># 这个是服务器端开放的端口，可以参见服务器端配置</span><br><br>[ssh]<br><span class="hljs-built_in">type</span> = tcp<br>local_ip = 127.0.0.1<br>local_port = 22<br>remote_port = 6000<br><br></code></pre></td></tr></table></figure><p>然后就可以输入<code>./frpc -c frpc.ini</code>启动一下看看效果，正常启动就没问题。</p><h4 id="服务器端配置">服务器端配置</h4><p>仅仅配置了客户端我们目前还是没有办法进行远程登录，还需要额外配置服务器端的frp程序。</p><p>我手上的这台服务器是<code>x86_64</code>架构的，所以我们需要下载对应架构的frp程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz<br><br>tar -zxvf frp_0.44.0_linux_amd64.tar.gz<br><br><span class="hljs-built_in">cd</span> frp_0.44.0_linux_amd64<br><br></code></pre></td></tr></table></figure><p>然后类似的，我们也需要修改服务器端的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>vim frps.ini<br><br><span class="hljs-comment"># 下面是配置文件内容</span><br><br>[common]<br>bind_port = 7000 <span class="hljs-comment"># 这个就是前面说的服务器端使用的ip地址</span><br>dashboard_port = 7500 <span class="hljs-comment"># 这个是提供统计信息的界面，在浏览器中输入http://{服务器ip}:7500就能看到</span><br>dashboard_user = admin <span class="hljs-comment"># 下面这俩是统计信息界面的账号密码，可以自己设置。</span><br>dashboard_pwd = admin<br><br></code></pre></td></tr></table></figure><p>配置完成后我们输入<code>./frps -c frps.ini</code>来启动服务器端程序看看运行结果，正常运行就是ok的。</p><p>最后注意需要在云服务器中的安全组里打开防火墙不然可能无法连接。</p><h4 id="自启动与后台执行">自启动与后台执行</h4><p>但是这样的话就会出现几个问题:</p><ul><li>板子每次重启都需要在内网内启动frpc程序</li><li>远程服务器的ssh不能断开，否则frps程序会随着ssh断开而关闭</li></ul><p>我们先来解决第二个问题，因为可以通过screen来快速解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>screen -S frps <span class="hljs-comment"># 先创建一个screen窗口</span><br>./frps -c frps.ini <span class="hljs-comment"># 在窗口内执行</span><br><br>CTRL^A D <span class="hljs-comment"># 按下ctrl^a 再按下d，此时这个窗口连同执行的程序就会进入后台。</span><br><br></code></pre></td></tr></table></figure><p>如果我们想重新连入这个窗口可以输入<code>screen -r frp</code>，这样可以很方便的查看日志，彻底关闭这个窗口可以按下ctrl^a再按下k。</p><p>对于第一个问题，我们的解决方法是写一个bash脚本然后每次开机都自启动这个脚本。</p><p>我们先写一个我们需要被自启动的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>vim start.sh<br><br><span class="hljs-comment"># 下面是脚本内容</span><br><br><span class="hljs-built_in">cd</span> /usr/local/frp_0.39.1_linux_arm64<br><span class="hljs-built_in">nohup</span> ./frpc -c frpc.ini &amp;<br><br></code></pre></td></tr></table></figure><p>然后我们编辑<code>/etc/rc.local</code>，如果没有这个文件可以参考<a href="https://www.linuxprobe.com/linux-rc-local.html">这里</a>。然后把我们的启动脚本添加进去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo vim /etc/rc.local<br><br><span class="hljs-comment"># 下面是添加的内容 在exit 0之前</span><br><br>bash /usr/local/start.sh &amp;<br><br></code></pre></td></tr></table></figure><p>这样就完成了。</p>]]></content>
    
    
    <categories>
      
      <category>工具杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发板使用</tag>
      
      <tag>RK3288</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(12)--CUDA标准库与生态</title>
    <link href="/2022/09/14/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-12/"/>
    <url>/2022/09/14/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-12/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda标准库与生态">CUDA标准库与生态</h2><span id="more"></span><h3 id="标准库">标准库</h3><p>CUDA提供了覆盖数学函数、线性代数、图像处理和机器学习以及其他重要领域的标准库供大家使用。这些库提供了大量高性能算法，可以节约大量时间。</p><table><thead><tr class="header"><th style="text-align: center;">库名称</th><th style="text-align: center;">介绍</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数学库</td><td style="text-align: center;">涉及到各种精度的数学计算，可以查看<a href="https://docs.nvidia.com/cuda/cuda-math-api/">文档</a></td></tr><tr class="even"><td style="text-align: center;">Thrust</td><td style="text-align: center;">类似C++的标准模板库</td></tr><tr class="odd"><td style="text-align: center;">cuBLAS</td><td style="text-align: center;">基本线性代数子程序</td></tr><tr class="even"><td style="text-align: center;">cuFFT</td><td style="text-align: center;">快速傅里叶变换</td></tr><tr class="odd"><td style="text-align: center;">cuSPARSE</td><td style="text-align: center;">稀疏矩阵</td></tr><tr class="even"><td style="text-align: center;">cuRAND</td><td style="text-align: center;">随机数生成库</td></tr><tr class="odd"><td style="text-align: center;">cuSolver</td><td style="text-align: center;">稠密矩阵和稀疏矩阵计算库</td></tr><tr class="even"><td style="text-align: center;">cuDNN</td><td style="text-align: center;">深度神经网络</td></tr></tbody></table><p>上述库需要使用时查阅<a href="https://docs.nvidia.com/cuda/">文档</a>即可</p><h4 id="thrust库">Thrust库</h4><p>这是一个实现了众多基本并行算法的C++模板库，类似于STL。</p><p>其提供了两种矢量结构(vector)，需要包含<code>&lt;thrust/host_vector.h&gt;</code>或<code>&lt;thrust/device_vector.h&gt;</code>来使用。</p><ul><li>thrust::host_vector<t> : 存储于主机的vector</t></li><li>thrust::device_vector<t> : 存储于设备的vector</t></li></ul><p>当然，其也提供了很多常用的算法</p><p>关于Thrust库的文档请查阅<a href="https://nvidia.github.io/thrust/">此处</a></p><h4 id="cublas">cuBLAS</h4><p>这个库专门用于进行矩阵运算，提供了诸多的矩阵相关的API，可以参阅<a href="https://docs.nvidia.com/cuda/cublas/index.html">文档</a></p><p>在使用的时候个地方需要特别提及一下，这个库由于最开始是使用Fortran语言实现的，因此带有Fortran语言风格。<strong>比如矩阵式按列有限存储的，这对局部性会产生印象，需要注意</strong>。</p><h4 id="cusolver">cuSolver</h4><p>这个库也是处理矩阵的，但是其主要处理高级矩阵运算，比如矩阵求逆或者对角化之类的东西。</p><h4 id="curand">cuRAND</h4><p>这个库用于产生随机数，可以产生伪随机数和准随机数。</p>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(11)--CUDA流</title>
    <link href="/2022/09/13/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-11/"/>
    <url>/2022/09/13/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-11/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda流">CUDA流</h2><span id="more"></span><p>CUDA程序的并行层次主要有两个，一个是在核函数内部的并行，另一个是在核函数外部的并行。之前的线程块、计算网格之类的都是内部的并行，而外部的并行主要包括核函数计算与数据传输之间的并行、主机计算与数据传输之间的并行、不同数据传输(方向)之间的并行、核函数计算与主机计算之间的并行以及不同核函数之间并行。</p><p>不过核函数外部的并行并不是编程时考虑的重点内容。但是如果需要考虑核函数外的并行，就需要涉及到流的概念了。</p><h3 id="流概述">流概述</h3><p>一个CUDA流是指由主机发出的在一个设备中执行的CUDA操作序列。除了主机端发送的流外，设备端也可以发送流，不过此处我们只考虑前者。</p><p>一个流的哥哥操作的次序是由主机控制的，按照主机发布的次序执行，但是来自于两个不同的流的操作不一定按照某个次序执行，而是按照并发或交错地执行。</p><p>任何CUDA操作都存在于某个流中，要么是默认流，也称空流，要么是明确的非默认流。如果没有显式地指定一个流，那么所有的CUDA操作都是在空流中进行的。</p><p>非默认的流，需要在主机端产生与销毁。一个CUDA流可以由以下的CUDA运行时API产生:<code>cudaError_t cudaStreamCreate(cudaStream_t *)</code>，其输入参数是<code>cudaStream_t</code>类型的一个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>cudaStream_t stream_1;<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;stream_1); <span class="hljs-comment">// 创建,这个需要传递流地址</span><br><span class="hljs-built_in">cudaStreamDestroy</span>(stream_1); <span class="hljs-comment">// 销毁,这个不需要流地址</span><br><br></code></pre></td></tr></table></figure><p>为了实现不同的CUDA流之间的并发，主机在向某个CUDA流中发布一系列命令后必须马上获得程序的控制权，不用等待CUDA流在GPU中执行完毕。这样就可以通过主机产生多个并行的CUDA流。</p><p>可以用以下函数检查一个CUDA流的所有操作是否在设备中执行完。</p><ul><li>cudaError_t cudaStreamSynchronize(cudaStream_t stream);强制阻塞主机，直到所有CUDA流中的操作执行完毕。</li><li>cudaError_t cudaStreamQuery(cudaStream_t stream);检查CUDA流中操作是否执行完毕，但不阻塞主机。</li></ul><h3 id="在默认流中重叠主机和设备计算">在默认流中重叠主机和设备计算</h3><p>同一个CUDA流中的所有CUDA操作都是顺序执行的，但是依然可以重叠默认流和主机之间的计算。</p><p>由于一个CUDA流内是顺序执行的，而我们前面也说过，主机执行完核函数后会立刻执行下一条指令，而不等待设备。因此如果主机执行完核函数后的下一条指令仍然是CUDA相关的(比如从设备中复制计算结果数据到主机)，就会导致这条指令被阻塞(因为设备会等待核函数结束后再执行这条复制相关的指令)。</p><p><strong>而如果主机在执行核函数后执行的指令与设备无关，那么就能实现主机和设备同时计算</strong>。这样就让设备和主机之间的计算重叠，这个技巧有时候会有用，前提是设备和主机执行的计算量差不多。</p><h3 id="用非默认的cuda流来重叠多个核函数的执行">用非默认的CUDA流来重叠多个核函数的执行</h3><p>要实现多个核函数之间并行必须需要使用多个流。</p><h4 id="核函数中流参数">核函数中流参数</h4><p>其实一个核函数在尖括号内可以传递4个参数，分别是网格尺寸，线程块尺寸，共享内存大小，流。因此要配置不同的流，就可以按照前述方法先创建出流，然后传递进核函数就可以了。<strong>其中共享内存大小可以为0</strong>。</p><p><code>xxx_kernel&lt;&lt;&lt;gridDim, blockDim, sharedMem, streamId&gt;&gt;&gt;(...)</code></p><h4 id="重叠多个核函数的例子">重叠多个核函数的例子</h4><p>下面给出一个简单的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cuda_runtime.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> __global__ <span class="hljs-title">stream_kernel</span><span class="hljs-params">(<span class="hljs-type">int</span> streamid)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d thread in %d block in %d\n"</span>, threadIdx.x, blockIdx.x, streamid);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>cudaStream_t streams[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : streams)<br>{<br><span class="hljs-built_in">cudaStreamCreate</span>(&amp;x); <span class="hljs-comment">// 创建流</span><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>;i++)<br>{<br>stream_kernel &lt;&lt; &lt;<span class="hljs-number">2</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0</span>, streams[i] &gt;&gt; &gt; (i); <span class="hljs-comment">// 调用核函数</span><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : streams)<br>{<br><span class="hljs-built_in">cudaStreamDestroy</span>(x); <span class="hljs-comment">// 销毁流</span><br>}<br>}<br><br></code></pre></td></tr></table></figure><h4 id="不同流之间核函数的执行与数据传递">不同流之间核函数的执行与数据传递</h4><p>要实现核函数执行与数据传输的并发，必须让这两个操作处于不同的非默认流中，<strong>且数据传输必须使用<code>cudaMemcpy()</code>的异步版本<code>cudaMemcpyAsync()</code></strong>(这个由GPU中DMA来实现的)；另外，由于我们需要将数据传输实现成异步形式，因此<code>需要使用不可分页内存</code>而不能使用常规的可分页内存(也就是默认的分配内存，因为这些内存在传输时需要和主机进行同步，比如缺页，达不到异步的效果)，可以用<code>cudaMallocHost()</code>函数来实现，不可分页内存需要用<code>cudaFreeHost()</code>来进行释放，否则会出现错误。下面来具体介绍一下这些API。</p><ul><li>cudaError_t cudaMallocHost(void **ptr, size_t size) :将*ptr指向的地址分配成不可分页地址。</li><li>cudaError_t cudaFreeHost(void *ptr) : 释放掉不可分页地址</li><li>cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t size,enum cudaMemcpyKind kind, cudaStream_t stream) :前面几个参数与cudaMemcpy()一致，最后一个参数是需要复制到的流中。</li></ul><h2 id="总结">总结</h2><ul><li>cudaStreamCreate()和cudaStreamDestroy()可以用于创建和销毁流。</li><li>cudaStreamSynchronize()强制阻塞主机，直到所有CUDA流中的操作执行完毕。cudaStreamQuery()，检查CUDA流中操作是否执行完毕，但不阻塞主机。</li><li>核函数调用中尖括号内第四个参数是流。</li><li>cudaMallocHost()和cudaFreeHost()可以用于分配和销毁不可分页内存。</li><li>cudaMemcpyAsync()可以在流内异步传输数据，且数据类型必须为不可分页内存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(6)--函数</title>
    <link href="/2022/09/12/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-6/"/>
    <url>/2022/09/12/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-6/</url>
    
    <content type="html"><![CDATA[<h2 id="函数----来源于cookbook第七章">函数----来源于cookbook第七章</h2><span id="more"></span><p><font color="#a0dad0">记录第七章中比较有意思的部分</font></p><hr><h3 id="只接受关键词参数的函数">只接受关键词参数的函数</h3><div class="note note-primary">            <p>关键词参数放在*打头的参数后面或者放在一个单独的*后面即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, *args, y</span>):<br>    ...<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, *, y</span>):<br>    ...<br><br>func(<span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>) <span class="hljs-comment"># 调用func</span><br>func(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment"># 错误</span><br><br></code></pre></td></tr></table></figure><h3 id="默认参数的问题">默认参数的问题</h3><div class="note note-primary">            <p>python函数的默认参数只会被初始化一次，所以只能赋值给不可变对象。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>_no_value = <span class="hljs-built_in">object</span>() <span class="hljs-comment"># 元类来构建出一个表示没有参数</span><br><br><span class="hljs-comment"># 请注意不传递参数和传递None的区别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b = <span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> _no_value:<br>        b = []<br>    ...<br><br><span class="hljs-comment"># 下面是一个错误示例</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">l = []</span>): <span class="hljs-comment"># 请务必不要这么做</span><br>    l.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(l)<br><br>func() <span class="hljs-comment"># 输出[1]</span><br>func() <span class="hljs-comment"># 输出[1, 1]</span><br><br></code></pre></td></tr></table></figure><h3 id="匿名函数的一些问题">匿名函数的一些问题</h3><div class="note note-primary">            <p>匿名函数即lambda函数，<strong>请时刻记住匿名函数是懒惰求值的</strong>。</p><p>要固定下匿名函数中使用的参数，<strong>必须在匿名函数参数列表中确定</strong>。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>示例一 懒惰求值<br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">1</span><br>a = <span class="hljs-keyword">lambda</span> x:x+y<br><span class="hljs-built_in">print</span>(a(<span class="hljs-number">20</span>)) <span class="hljs-comment"># 21 </span><br>y = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(a(<span class="hljs-number">20</span>)) <span class="hljs-comment"># 22</span><br><br><span class="hljs-comment"># 示例二 绑定变量，此时y的值被定下来了</span><br>x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">1</span><br>a = <span class="hljs-keyword">lambda</span> x, y=y:x+y<br><span class="hljs-built_in">print</span>(a(<span class="hljs-number">20</span>)) <span class="hljs-comment"># 21 </span><br>y = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(a(<span class="hljs-number">20</span>)) <span class="hljs-comment"># 21</span><br><br><span class="hljs-comment"># 示例三 列表推导式</span><br>funs = [<span class="hljs-keyword">lambda</span> x:x+n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> funs:<br>    <span class="hljs-built_in">print</span>(f(<span class="hljs-number">0</span>)) <span class="hljs-comment"># 4 4 4 4 4</span><br><br><span class="hljs-comment"># 示例四 列表推导式2</span><br>funs = [<span class="hljs-keyword">lambda</span> x,n=n:x+n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> funs:<br>    <span class="hljs-built_in">print</span>(f(<span class="hljs-number">0</span>)) <span class="hljs-comment"># 0 1 2 3 4 </span><br><br></code></pre></td></tr></table></figure><h3 id="固定多个参数的函数的某些参数">固定多个参数的函数的某些参数</h3><div class="note note-primary">            <p>可以使用<code>functools</code>中的<code>partial()</code>工厂方法来实现。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a,b,c,d</span>):<br>    <span class="hljs-built_in">print</span>(a,b,c,d)<br><br>func2 = partial(func, <span class="hljs-number">1</span>) <span class="hljs-comment"># 即a = 1</span><br>func3 = partial(func, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, d =<span class="hljs-number">4</span>) <span class="hljs-comment"># 即a = 1, b = 2, d = 4</span><br><br>func2(-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">4</span>) <span class="hljs-comment"># 1 -2 -3 -4</span><br>func3(-<span class="hljs-number">3</span>) <span class="hljs-comment"># 1 2 -3 4</span><br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>可以使用此方法将参数数目不兼容的代码组合到一起。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>points = [(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)] <span class="hljs-comment"># 点集</span><br><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">p1,p2</span>): <span class="hljs-comment"># 求两点距离</span><br>    <span class="hljs-keyword">return</span> math.hypot(p1[<span class="hljs-number">0</span>]-p2[<span class="hljs-number">0</span>],p1[<span class="hljs-number">1</span>]-p2[<span class="hljs-number">1</span>])<br><br>points.sort(key = partial(distance,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))) <span class="hljs-comment"># 对点集求两点距离</span><br><br></code></pre></td></tr></table></figure><h3 id="闭包与单个函数的类">闭包与单个函数的类</h3><div class="note note-primary">            <p>可以用闭包的工厂方法来代替只有单个函数的类。因为引入类的作用就是为了保存在类内可以使用的固定参数。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">template</span>(<span class="hljs-params">template</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">opener</span>(<span class="hljs-params">*args</span>):<br>        <span class="hljs-keyword">return</span> template.<span class="hljs-built_in">format</span>(args)<br>    <span class="hljs-keyword">return</span> opener<br><br>func = template(<span class="hljs-string">"{} is {}"</span>) <span class="hljs-comment"># 将常量保存在func内部</span><br>func(args)<br><br></code></pre></td></tr></table></figure><h3 id="闭包但是可以修改参数">闭包，但是可以修改参数</h3><div class="note note-primary">            <p>上述的闭包只是将传递的参数作为常量来使用，现在我们需要修改它，比如计数功能。</p><p>只需要在内层的函数内使用<code>nonlocal</code>关键字即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>():<br>    seq = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_handle</span>(<span class="hljs-params">result</span>):<br>        <span class="hljs-keyword">nonlocal</span> seq<br>        seq+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{seq}</span> : <span class="hljs-subst">{result}</span>"</span>)<br>    <span class="hljs-keyword">return</span> inner_handle<br><br>h = handle()<br>h(<span class="hljs-string">"first"</span>) <span class="hljs-comment"># 1 : first</span><br>h(<span class="hljs-string">"second"</span>) <span class="hljs-comment"># 2 : second</span><br><br></code></pre></td></tr></table></figure><h3 id="协程与回调函数">协程与回调函数</h3><div class="note note-primary">            <p>可以利用yield关键字中断发送和接受数据的方式来构造协程。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 示例一 : 重写可以修改参数的闭包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>():<br>    seq = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        result = <span class="hljs-keyword">yield</span><br>        seq += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{seq}</span> : <span class="hljs-subst">{result}</span>"</span>)<br><br>h = handle()<br><span class="hljs-built_in">next</span>(h) <span class="hljs-comment"># 让协程执行到yield上</span><br>h.send(<span class="hljs-string">"first"</span>) <span class="hljs-comment"># 1 : first</span><br>h.send(<span class="hljs-string">"second"</span>) <span class="hljs-comment"># 2 : second</span><br><br><br><span class="hljs-comment"># 示例二 : 一个比较复杂的内联回调函数</span><br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_async</span>(<span class="hljs-params">func, args, *, callback</span>): <span class="hljs-comment"># 这个是回调函数本身</span><br>    result = func(*args)<br>    callback(result)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Async</span>: <span class="hljs-comment"># 一个保存函数和参数的类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func, args</span>):<br>        self.func = func<br>        self.args = args<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inline_async</span>(<span class="hljs-params">func</span>): <span class="hljs-comment"># 一个装饰器</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">warpper</span>(<span class="hljs-params">*args</span>):<br>        f = func(*args) <span class="hljs-comment"># 先拿到生成器</span><br>        <span class="hljs-built_in">print</span>(f)<br>        result_queue = Queue() <span class="hljs-comment"># 创建一个队列</span><br>        result_queue.put(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 队列初始值为None</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            result = result_queue.get() <span class="hljs-comment"># 获取队列中的值</span><br>            <span class="hljs-keyword">try</span>:<br>                a = f.send(result) <span class="hljs-comment"># 然后把值发送给生成器，同时接受到值</span><br>                <span class="hljs-comment"># 下面把计算结果发送到队列中</span><br>                apply_async(a.func, a.args, callback = result_queue.put)<br>            <span class="hljs-keyword">except</span> StopIteration:<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> warpper<br><br><span class="hljs-comment">## 应用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br><br><span class="hljs-meta">@inline_async</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    r = <span class="hljs-keyword">yield</span> Async(add,(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">print</span>(r)<br>    r = <span class="hljs-keyword">yield</span> Async(add,(<span class="hljs-string">"hello "</span>, <span class="hljs-string">"world"</span>))<br>    <span class="hljs-built_in">print</span>(r)<br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这个例子感觉有些复杂，但其实它使用装饰器后可以简化在业务逻辑(test()函数)中处理回调函数(不然就得写成apply_async(add,(2,3),callback= ...)这种东西，需要手动去管理回调函数)</p><p>实现的原理是利用yield来获取到调用的函数和参数(被通过一个类封装了)，然后执行计算、回调等任务，再使用send方法把这个值发送到业务逻辑中。</p>          </div><h3 id="访问在闭包内的变量">访问在闭包内的变量</h3><div class="note note-primary">            <p>一般来说闭包内的变量不太好被外界给访问和修改，但是我们可以创建存取函数来实现。</p><p>因为python中一切皆对象，所以闭包就可以当作轻量级的类来用。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">closure</span>():<br>    n = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"n = <span class="hljs-subst">{n}</span>"</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_</span>():<br>        <span class="hljs-keyword">return</span> n<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_</span>(<span class="hljs-params">value</span>):<br>        <span class="hljs-keyword">nonlocal</span> n<br>        n = value<br><br>    func.getn = get_<br>    func.setn = set_<br>    <span class="hljs-keyword">return</span> func<br><br>f = closure()<br>f() <span class="hljs-comment"># 0</span><br>f.get() <span class="hljs-comment"># 0</span><br>f.<span class="hljs-built_in">set</span>(<span class="hljs-number">10</span>) <br>f.get() <span class="hljs-comment"># 10</span><br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这个结构基本上就是一个类了，但是其运行速度会更快，更加轻量级。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(10)--线程束基本函数与协作组</title>
    <link href="/2022/09/12/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-10/"/>
    <url>/2022/09/12/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-10/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda线程束基本函数与协作组">CUDA线程束基本函数与协作组</h2><span id="more"></span><p>由于GPU的每次调度计算的最小单元就是一个拥有32个线程的线程束，所以我们首先再来回顾一下线程束和GPU的处理模式。</p><h3 id="单指令多线程的执行模式">单指令多线程的执行模式</h3><p>一个GPU在硬件上是由多个SM组成的，核函数中定义的线程块在执行时会被调度到一个资源还没有被完全占满的SM上。一个线程块只会被一个SM调度，但是一个SM上可以拥有很多线程块。</p><p>不同的线程块之间可以并发或顺序的执行，但是<strong>线程块之间一般不能同步</strong>，当某个线程块完成计算后，SM会进入部分或完全空闲状态并调度下一个线程块。</p><p>一个SM以线程束作为最小单元进行调度，一个线程束为32个线程。</p><h4 id="线程块分支发散">线程块分支发散</h4><p>在伏特架构之前，每个线程束只有一个程序计数器，导致所有的线程必须执行相同的指令。如果一个线程束内的线程顺序地执行分支语句中的不同分支时，就会导致分支发散。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">if</span>(condition)<br>{<br>    A;<br>}<br><span class="hljs-keyword">else</span><br>{<br>    B;<br>}<br><br></code></pre></td></tr></table></figure><p>例如上述代码，在一个线程束内，首先满足condition的线程会执行A，其他线程闲置，然后不满足condition的线程再去执行B，其他线程闲置。因此，如果A,B的运算量相差不多，就会导致性能下降到原来的一半。而如果存在很多分支(switch-case)时，就会导致分支发散的很严重，性能严重下降。</p><p><strong>而在伏特架构开始</strong>，引入了线程独立调度，每个线程都有自己的程序计数器。因此分支发散的问题没有那么严重了，但是又引入了<strong>新的问题</strong>：</p><p>首先是由于CUDA核非常多，所以程序计数器也得非常多，导致空间浪费。另外，由于每个线程有自己的程序计数器，所以线程束也不再是完全同步执行的了。要引入线程束内同步，可以通过<code>__syncwarp()</code>来完成。</p><h3 id="线程块的基本函数">线程块的基本函数</h3><h4 id="线程束内线程同步函数">线程束内线程同步函数</h4><p>当需要同步的所有线程都位于一个线程块时，可以使用更加廉价的<code>__syncwarp(unsigned mask = 0xffffffff)</code>去代替线程块同步，其内部的掩模表示需要参与同步的线程块内的线程id。</p><p>但使用的时候需要十分注意，要保证范围内的线程同属一个线程块。</p><h4 id="线程束表决函数">线程束表决函数</h4><p>表决函数名字感觉有些奇怪，其函数族大致形如<code>__xxx_sync(mask, predicate)</code>，效果是线程块内所有线程求predicate的值，并根据所有线程块的计算结果来返回值。</p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">unsigned __ballot_sync(unsigned mask,int predicate)</td><td style="text-align: center;">mask掩模为1的线程参与计算。返回值也是一个掩模，其中位1的位表示对应的线程计算结果非0。<strong>相当于从旧的掩模中产生新的掩模</strong></td></tr><tr class="even"><td style="text-align: center;">int __all_sync(unsigned mask, intpredicate)</td><td style="text-align: center;">make掩模为1的线程参与计算。只有所有参与计算的线程的计算结果均为非0，返回值为1，否则为0.<strong>所有人都同意才执行</strong></td></tr><tr class="odd"><td style="text-align: center;">int __any_sync(unsigned mask, intpredicate)</td><td style="text-align: center;">make掩模为1的线程参与计算。只要参与计算的线程中有一个计算结果非0，那么就返回1，否则返回0.<strong>只要有一个人同意就执行</strong></td></tr></tbody></table><p>这些函数结尾都带有<code>_sync</code>，因此其都具有隐式同步功能。</p><p>下面给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cuda_runtime.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_functions.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TARGET 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FULL_MASK 0Xffffffff</span><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">test_warp_primitives</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> tid = threadIdx.x;<br><span class="hljs-type">int</span> lane_id = tid % WIDTH;<br><br><span class="hljs-comment">// 输出线程号</span><br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>) <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"threadIdx.x: "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n "</span>);<br><br><span class="hljs-comment">// 输出定义的线程束内线程号</span><br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"lane id: "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, lane_id);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n "</span>);<br><br><span class="hljs-comment">// 使用表决函数计算mask并打印</span><br><span class="hljs-type">unsigned</span> mask1 = __ballot_sync(FULL_MASK, tid &gt; <span class="hljs-number">0</span>);<br><span class="hljs-type">unsigned</span> mask2 = __ballot_sync(FULL_MASK, tid == <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"fullmask = %x\n"</span>, FULL_MASK);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"mask1 = %x\n"</span>, mask1);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"mask2 = %x\n"</span>, mask2);<br><br><span class="hljs-comment">// 下面也是表决函数的使用</span><br><span class="hljs-type">int</span> result = __all_sync(FULL_MASK, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"all_sync(fullmask) = %d\n"</span>, result);<br><br>result = __any_sync(mask1, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"any_sync(mask1) = %d\n"</span>, result);<br><br>result = __any_sync(FULL_MASK, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"any_sync(fullmask) = %d\n"</span>, result);<br><br>result = __any_sync(mask2, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"any_sync(mask2) = %d\n"</span>, result);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>test_warp_primitives &lt;&lt; &lt;<span class="hljs-number">1</span>, BLOCK_SIZE &gt;&gt; &gt; ();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>这个例子介绍了表决函数的使用，非常简单，不再赘述。</p><h4 id="线程束洗牌函数">线程束洗牌函数</h4><p>下面介绍洗牌函数的功能</p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T __shfl_sync(unsigned mask,T v,intsrcLane,int w = warpSize)</td><td style="text-align: center;">参与线程返回标号为scrLane的线程中变量v的值。即广播数据交互，将一个线程的数据广播到线程束中所有的线程上(包括自身)。</td></tr><tr class="even"><td style="text-align: center;">T __shfl_up_sync(unsigned mask,Tv,unsigned d,int w = warpSize)</td><td style="text-align: center;">标号为t的参与线程中会返回t-d的线程中变量的值。标号满足t-d&lt;0的线程返回原来v的值，也就是数据向标号高的线程传递</td></tr><tr class="odd"><td style="text-align: center;">T __shfl_down_sync(unsigned mask,Tv,unsigned d,int w = warpSize)</td><td style="text-align: center;">标号为t的参与线程中会返回t+d的线程中变量的值。标号满足t+d&gt;w的线程返回原来v的值，也就是数据向标号低的线程传递</td></tr><tr class="even"><td style="text-align: center;">T __shfl_xor_sync(unsigned mask,T v,intlaneMask,int w = warpSize)</td><td style="text-align: center;">标号为t的参与线程返回标号为t^laneMask的线程中的变量为v的值</td></tr></tbody></table><p>洗牌函数可以用于将数据进行线程内传递，同样是同步的。<strong>注意其中的参数w表示作用的范围，比如其值取8的时候，表示把线程束再按照8个线程一组分成更小的'线程束'</strong></p><div class="note note-primary">            <p>可能会觉得这几个函数令人费解，下面来具体讲述一下。</p><p>首先线程是从核函数创建的，所以每个线程内部的代码都是一样的(类似c语言的fork)，这也就是说，<strong>假如在核函数中写了一个洗牌函数，那么实际上所有的线程内都会有这个洗牌函数</strong>。假如在核函数内有这么一句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">val = __shfl_up_sync(<span class="hljs-number">0xffffffff</span>, tid, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 其中tid = threadIdx.x</span><br></code></pre></td></tr></table></figure><p>由于所有线程都参与了，就不用考虑参与线程的问题。</p><p>下表给出了16个线程中val的值，其中tid_{i}表示这个值来自于线程i</p><table><thead><tr class="header"><th style="text-align: center;">线程编号</th><th style="text-align: center;">线程内val值</th><th style="text-align: center;"></th><th style="text-align: center;">线程编号</th><th style="text-align: center;">线程内val值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0,即tid_0，下同</td><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">6,即tid_6，下同</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;">9</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;"></td><td style="text-align: center;">12</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;">13</td><td style="text-align: center;">11</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;">14</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;"></td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;">16</td><td style="text-align: center;">14</td></tr></tbody></table>          </div><p>同样给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cuda_runtime.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_functions.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TARGET 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FULL_MASK 0Xffffffff</span><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">test_warp_primitives</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> tid = threadIdx.x;<br><span class="hljs-type">int</span> lane_id = tid % WIDTH;<br><br><span class="hljs-comment">// 输出线程号</span><br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"threadIdx.x: "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, tid);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n "</span>);<br><br><span class="hljs-comment">// 输出定义的线程束内线程号</span><br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"lane id: "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, lane_id);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n "</span>);<br><br><span class="hljs-comment">// 把2号线程的值广播到0-7号中，把10号线程的值广播到8-15中</span><br><span class="hljs-type">int</span> value = __shfl_sync(FULL_MASK, tid, <span class="hljs-number">2</span>, WIDTH);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"shfl : "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, value);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br><span class="hljs-comment">// 在每个小的线程束内把值向上传递</span><br>value = __shfl_up_sync(FULL_MASK, tid, <span class="hljs-number">1</span>, WIDTH);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"shfl_up : "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, value);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br><span class="hljs-comment">// 在每个小的线程束内把值向下传递</span><br>value = __shfl_down_sync(FULL_MASK, tid, <span class="hljs-number">1</span>, WIDTH);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"shfl_down : "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, value);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br><span class="hljs-comment">// 类似上面，线程号异或后判断传递方向</span><br>value = __shfl_xor_sync(FULL_MASK, tid, <span class="hljs-number">1</span>, WIDTH);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"shfl_xor : "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d "</span>, value);<br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>test_warp_primitives &lt;&lt; &lt;<span class="hljs-number">1</span>, BLOCK_SIZE &gt;&gt; &gt; ();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>主要使用了洗牌函数并查看其在线程束内的工作情况。</p><h2 id="协作组">协作组</h2><p>在有些算法中，需要若干线程之间进行协作，而协作，就需要用到某种同步机制，否则乱序是没有办法进行很好的协作的。</p><p><strong>协作组</strong>可以看成是线程块与线程束的同步机制的推广，它提供了更加灵活的线程协作方式，包括<strong>线程块内部同步</strong>、<strong>线程块之间(计算网格)同步</strong>和<strong>设备与设备之间的同步</strong>。</p><p>使用协作组的相关函数时需要包含头文件<code>#include &lt;cooperative_groups.h&gt;</code>，且声明命名空间<code>using namespace cooperative_groups;</code></p><h4 id="线程块级别的协作组">线程块级别的协作组</h4><p>协作组编程中最基本的类型就是线程组thread_group类，我们把其头文件中源码放上来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_group</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> _CG_QUALIFIER thread_group <span class="hljs-title">this_thread</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> _CG_QUALIFIER thread_group <span class="hljs-title">tiled_partition</span><span class="hljs-params">(<span class="hljs-type">const</span> thread_group&amp; parent, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tilesz)</span></span>;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_block</span>;<br><br> <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">__align__</span>(<span class="hljs-number">8</span>) {<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type : <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">struct</span> {<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type : <span class="hljs-number">8</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size : <span class="hljs-number">24</span>;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask;<br>        } coalesced;<br>        <span class="hljs-keyword">struct</span> {<br>            <span class="hljs-type">void</span>* ptr[<span class="hljs-number">2</span>];<br>        } buffer;<br>    } _data;<br><br>    _CG_QUALIFIER thread_group <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> thread_group&amp; src);<br>    <span class="hljs-function">_CG_QUALIFIER <span class="hljs-title">thread_group</span><span class="hljs-params">(__internal::groupType type)</span> </span>{<br>        _data.type = type;<br>    }<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(_data) == <span class="hljs-number">16</span>, <span class="hljs-string">"Failed size check"</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 接口</span><br>    <span class="hljs-function">_CG_QUALIFIER <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">_CG_QUALIFIER <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">thread_rank</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">_CG_QUALIFIER <span class="hljs-type">void</span> <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>};<br><br></code></pre></td></tr></table></figure><p>我们可以看到其接口只有三个函数</p><ul><li>size() : 返回组的大小</li><li>sync() : 同步</li><li>thread_rank() : 返回当前调用该函数的线程在组内标号(从0开始)</li></ul><p>另外我们注意到其有一个友元类<code>thread_block</code>，这个类公有继承自thread_group，且提供了额外的公有接口，我们介绍两个</p><ul><li>dim3 group_index() : 等价于blockIdx</li><li>dim3 thread_index() : 等价于threadIdx</li></ul><p>我们可以使用如下方式定义一个thread_block对象<br><code>thread_block g = this_thread_block();</code><br>其中this_thread_block()也是一个常量，这样定义的g就变成了我们熟悉的线程块。调用g.sync()等价于__syncthreads()函数。而g.group_index()和g.thread_index()也完全等于内建变量。</p><p>可以使用函数<code>tiled_partition()</code>来讲一个线程块进行分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 将线程块分成32一组的线程束</span><br>thread_block g32 = <span class="hljs-built_in">tiled_partition</span>(<span class="hljs-built_in">this_thread_block</span>(), <span class="hljs-number">32</span>);<br><br><span class="hljs-comment">// 也可以分割成更细的线程束</span><br>thread_block g4 = <span class="hljs-built_in">tiled_partition</span>(g32), <span class="hljs-number">4</span>);<br><br></code></pre></td></tr></table></figure><p>当线程组大小在编译时就能确定，可以使用<strong>静态结构</strong>进行定义，更高效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>thread_block_tile&lt;<span class="hljs-number">32</span>&gt; g32 = <span class="hljs-built_in">tiled_partition</span>&lt;<span class="hljs-number">32</span>&gt;(<span class="hljs-built_in">this_thread_block</span>());<br>thread_block_tile&lt;<span class="hljs-number">4</span>&gt; g4 = <span class="hljs-built_in">tiled_partition</span>&lt;<span class="hljs-number">4</span>&gt;(g32);<br><br></code></pre></td></tr></table></figure><p>线程组内也可以使用表决函数和洗牌函数等，但是其不能有掩模和宽度，也就是所有的线程必须参与进去。</p><h2 id="总结">总结</h2><ul><li>__syncwarp()可以用于线程束内同步，__syncthreads()则用于线程块同步。</li><li>表决函数可以用于线程束内线程计算表达式并返回计算结果，可以用于将一个掩模映射成另一个掩模。表决函数时同步的。</li><li>洗牌函数可以用于将数据进行线程内传递，同样是同步的。洗牌函数可以指定作用在更小的"线程束"上。</li><li>使用协作组的相关函数时需要包含头文件<code>#include &lt;cooperative_groups.h&gt;</code>，且声明命名空间<code>using namespace cooperative_groups;</code>。</li><li>协作组使用tiled_partition()进行分割，thread_block类用于确定线程块协作组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(9)--原子函数及其合理使用</title>
    <link href="/2022/09/11/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-9/"/>
    <url>/2022/09/11/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-9/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda全局内存共享内存的合理使用">CUDA全局内存、共享内存的合理使用</h2><span id="more"></span><h3 id="原子操作">原子操作</h3><p>所谓原子操作，就是不能被中断的操作，因为在多线程任务中，假设有全局内存可以被所有线程访问，且线程的任务均为读--将值加一--写回，那么当线程1进行加一的操作时，线程2将其结果写入到该内存中，那么接下来线程1再写回时，就覆盖了线程2的计算结果。如果这个任务被用于计数的话，那么结果就是线程之间串扰导致错误。</p><p>因此，我们希望某个线程在执行这一套流程时，其他线程不能访问这个全局内存，只有这样我们才能保证最终结果的正确性，这就是<strong>原子操作</strong>。</p><p>当然，假如说每个线程执行的任务都是需要对共享内存进行大量的原子读写，就会导致性能下降的很多。</p><p>我们可以使用形如<code>atomicxxx(addr, val)</code>的函数来进行原子操作，**原子函数都是__device__修饰的**。</p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T atomicAdd(T*, T)</td><td style="text-align: center;">加法</td></tr><tr class="even"><td style="text-align: center;">T atomicSub(T*, T)</td><td style="text-align: center;">减法</td></tr><tr class="odd"><td style="text-align: center;">T atomicExch(T*, T)</td><td style="text-align: center;">交换</td></tr><tr class="even"><td style="text-align: center;">T atomicMin(T*, T)</td><td style="text-align: center;">最小值</td></tr><tr class="odd"><td style="text-align: center;">T atomicMax(T*, T)</td><td style="text-align: center;">最大值</td></tr><tr class="even"><td style="text-align: center;">T atomicInc(T*, T)</td><td style="text-align: center;">自增</td></tr><tr class="odd"><td style="text-align: center;">T atomicDec(T*, T)</td><td style="text-align: center;">自减</td></tr><tr class="even"><td style="text-align: center;">T atomicCAS(T*, T1, T2)</td><td style="text-align: center;">比较-交换</td></tr><tr class="odd"><td style="text-align: center;">T atomicAnd(T*, T)</td><td style="text-align: center;">按位与</td></tr><tr class="even"><td style="text-align: center;">T atomicOr(T*, T)</td><td style="text-align: center;">按位或</td></tr><tr class="odd"><td style="text-align: center;">T atomicXor(T*, T)</td><td style="text-align: center;">按位异或</td></tr></tbody></table><div class="note note-primary">            <p>其结果一般都是 *(T*) = *(T *) operate T</p><p>原子函数的返回值都是*(T *)的原始值。</p><p>举例：T atomicSub(T* addr, T val)</p><p>等效于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>T tmp = *addr;<br>*addr = *addr - val;<br><span class="hljs-keyword">return</span> tmp;<br><br></code></pre></td></tr></table></figure><p>其中比较特殊的T atomicCAS(T*, T1, T2)的作用是*(T*) = (*(T*) = T1) ?T2 : *(T*)</p>          </div><div class="note note-info">            <p>还有需要注意一点，原子函数是有精度限制的，比如atomicSub要求数据类型为<code>int</code>,<code>unsigned</code>,<code>unsigned long long</code>，而不能是浮点数类型。</p><p>一般所有的原子操作都是通过atomicCAS来实现，但是在实际过程中要避免这样做，因为性能会下降。</p>          </div><p>下面给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cuda_runtime.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_atomic_functions.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATOMIC 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TPB 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1024</span><br><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">dotKernel</span><span class="hljs-params">(<span class="hljs-type">int</span> * d_res, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *d_a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> * d_b, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> idx = threadIdx.x + blockDim.x * blockIdx.x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> s_idx = threadIdx.x;<br><br><span class="hljs-keyword">if</span> (idx &gt;= n)<br><span class="hljs-keyword">return</span>;<br><br>__shared__ <span class="hljs-type">int</span> s_prod[TPB];<br>s_prod[s_idx] = d_b[idx] * d_a[idx];<br>__syncthreads(); <span class="hljs-comment">// 至此，所有的分块计算都完成了</span><br><br><span class="hljs-keyword">if</span> (s_idx == <span class="hljs-number">0</span>) <span class="hljs-comment">// 使用每个线程块中的第一个线程进行数据合并计算</span><br>{<br><span class="hljs-type">int</span> blockSum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; blockDim.x; ++j)<br>{<br>blockSum += s_prod[j];<br>}<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"block %d, blocksum %d\n"</span>, blockIdx.x, blockSum);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ATOMIC == 1</span><br><span class="hljs-built_in">atomicAdd</span>(d_res, blockSum); <span class="hljs-comment">// 原子计算</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>*d_res += blockSum; <span class="hljs-comment">// 直接计算</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doLauncher</span><span class="hljs-params">(<span class="hljs-type">int</span> * res, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> * d_res;<br><span class="hljs-type">int</span> *d_a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *d_b = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 分配内存</span><br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_res, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_a, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_b, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-built_in">cudaMemset</span>(d_res, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">cudaMemcpy</span>(d_a, a, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), cudaMemcpyHostToDevice);<br><span class="hljs-built_in">cudaMemcpy</span>(d_b, b, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), cudaMemcpyHostToDevice);<br><br><span class="hljs-comment">// 调用核函数计算并将数据写回主机端</span><br>dotKernel &lt;&lt; &lt;(n + TPB - <span class="hljs-number">1</span>) / TPB, TPB &gt;&gt; &gt; (d_res, d_a, d_b, n);<br><span class="hljs-built_in">cudaMemcpy</span>(res, d_res, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), cudaMemcpyDeviceToHost);<br><br><span class="hljs-comment">// 释放内存</span><br><span class="hljs-built_in">cudaFree</span>(d_res);<br><span class="hljs-built_in">cudaFree</span>(d_a);<br><span class="hljs-built_in">cudaFree</span>(d_b);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> cpu_res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> gpu_res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *a = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>{<br>a[i] = <span class="hljs-number">1</span>;<br>b[i] = <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">// 先调用CPU计算结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br>cpu_res += a[i] * b[i];<br>}<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\ncpu res = %d\n\n"</span>, cpu_res);<br><br><span class="hljs-comment">// 调用GPU对比计算结果</span><br><span class="hljs-built_in">doLauncher</span>(&amp;gpu_res, a, b, N);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\ngpu res = %d\n\n"</span>, gpu_res);<br><br><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">free</span>(b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>可以修改宏ATOMIC来查看使用原子操作和非原子操作的结果。其中原子操作每次都能给出正确结果，而非原子操作每次结果都不一样，且都不正确。</p><h2 id="总结">总结</h2><ul><li>当涉及归约或者其他类型的需要多个线程访问同一个地址时，需要使用原子操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(8)--CUDA全局内存、共享内存的合理使用</title>
    <link href="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-8/"/>
    <url>/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-8/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda全局内存共享内存的合理使用">CUDA全局内存、共享内存的合理使用</h2><span id="more"></span><h3 id="全局内存与合理使用">全局内存与合理使用</h3><p>由于全局内存是GPU内存中容量最大、访问速度最慢的内存，因此对全局内存的关注是十分必要的，只有正确使用全局内存，才能写出高性能的CUDA程序。一般依次传输数据量是32字节。</p><p>对全局内存是存在L1、L2高速缓存的，因此访问全局内存首先会经过缓存，如果不命中则执行缺页中断，再从主存中取出。对全局内存的访问有合并和非合并两种方式。</p><h4 id="全局内存的合并与非合并访问">全局内存的合并与非合并访问</h4><p>合并访问是指一个线程束对全局内存的一次访问申请求所导致的最小数量的数据传输，否则称为非合并访问。</p><p>即如果一次请求的数据全部是线程束需要的就是合并访问，否则就是非合并访问。因此合并度可以看作是资源利用率，合并度越高则说明效率越高。</p><p>合并度不到100%的原因是因为内存对齐问题，内存对齐在CPU中是非常普遍的现象，<code>malloc</code>分配的内存全部都是内存对齐的，内存对齐也有利于访问速度的提升，此处不再赘诉。在GPU中，全局内存转移到L2缓存的内存是首地址为32字节的整数倍，因此内存首地址需要被对齐到32的整倍数时，即首地址满足<code>addr &amp; ~~(11111b) == 0</code>(低5位位0)才能满足合并度为100%。</p><p>使用<code>cudaMalloc()</code>分配的内存地址至少为256的整倍数。</p><div class="note note-primary">            <p>当读取与写入都是非合并的时候，最好合并写入，因为非合并的读取会被__lgd()优化。</p><p>也可以尝试使用共享内存将非合并转换成合并。</p>          </div><h3 id="共享内存与合理使用">共享内存与合理使用</h3><p>前面也提到过，共享内存就是可以被直接编程的缓存，读写速度十分的高，所以很有必要了解其使用。</p><h4 id="对大数组求和">对大数组求和</h4><p>对一个大数组进行求和与两个大数组相加的编程思路是不一样的，后者只需要定义相同元素个线程然后两两相加即可。对于前者，可能C++语言会编写出如下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">float</span> <span class="hljs-built_in">array</span>[N]={...};<br><span class="hljs-type">float</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; i:<span class="hljs-built_in">array</span>)<br>    result += <span class="hljs-built_in">array</span>;<br><br></code></pre></td></tr></table></figure><p>但是上述代码没有办法直接转化成并行计算模式。如果数组大小刚好是2的N次幂时，可以将数组每次分成一半，后一半加到前一半上，直到只剩一个元素就是最终结果。下面给出并行计算的核函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> __global__ <span class="hljs-title">sum_kernel</span><span class="hljs-params">(readl *d_x, <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n = blockDim.x * blockIdx.x + threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> offset = N&lt;&lt;<span class="hljs-number">1</span>; offset &gt; <span class="hljs-number">0</span>; offset&gt;&gt;=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(n &lt; offset )<br>            d_x[n] += d_x[n + offset];<br>}<br><br></code></pre></td></tr></table></figure><p>但是如果想要在并行计算中使用这个方法，需要注意由于每个线程执行顺序是不确定的，因此需要保证当所有线程都完成当前轮迭代后再开启下一轮。</p><p>可以使用<code>__syncthreads()</code>函数来进行<strong>同步</strong>，当其不带任何参数时，会等待一个线程块内所有线程束完成后再继续执行。我们此处先简单考虑，假设线程块为128，先将d_x[n]这个大数组每128个元素求和，并保存在d_y[n/128]中，因此可以得到这样一个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> __global__ <span class="hljs-title">sum_kernel</span><span class="hljs-params">(real *d_x, <span class="hljs-type">int</span> N,real *d_y)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> tid = threadIdx.x;<br>    real * x = d_x + blockDim.x * block.x;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> offset = N&lt;&lt;<span class="hljs-number">1</span>; offset &gt; <span class="hljs-number">0</span>; offset&gt;&gt;=<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">if</span>(tid &lt; offset )<br>            d_y[tid] += x[tid + offset];<br>        __syncthreads();<br>    }<br><br>    <span class="hljs-keyword">if</span>(tid == <span class="hljs-number">0</span>)<br>    {<br>        d_y[blockIdx.x] = x[<span class="hljs-number">0</span>];<br>    }<br><br>}<br><br></code></pre></td></tr></table></figure><p>很明显，上述代码需要频繁的访问d_y，且由于d_y位于全局内存中，这样IO速度会慢很多。同时d_y是多个线程合作的结果，所以也不能使用寄存器(既存不下也不能被其他线程访问)，所以此处加速的方法是使用共享内存。</p><p><strong>共享内存声明</strong>是使用修饰符<code>__shared__</code>即可，由于每个线程都能访问线程块的共享内存，因此将全局内存数据复制到共享内存中不需要写循环。下面给出代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> __global__ <span class="hljs-title">sum_kernel</span><span class="hljs-params">(real *d_x, <span class="hljs-type">int</span> N,real *d_y)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> tid = threadIdx.x;<br>    real * x = d_x + blockDim.x * block.x;<br>    __shared__ s_y[<span class="hljs-number">128</span>];<br>    s_y[tid] = (n &lt; N) ? d_X[n] : <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 执行数据的复制，</span><br>    __syncthreads();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> offset = N&lt;&lt;<span class="hljs-number">1</span>; offset &gt; <span class="hljs-number">0</span>; offset&gt;&gt;=<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">if</span>(tid &lt; offset )<br>            s_y[tid] += s_y[tid + offset];<br>        __syncthreads();<br>    }<br><br>    <span class="hljs-keyword">if</span>(tid == <span class="hljs-number">0</span>)<br>    {<br>        d_y[blockIdx.x] = x[<span class="hljs-number">0</span>];<br>    }<br><br>}<br><br></code></pre></td></tr></table></figure><p>但是这种共享内存的声明是硬编码的方式声明的，可扩展与可移植性不好，下面给出动态共享内存的声明方式。</p><p>首先，使用了动态共享内存的核函数必须传递三个参数<code>xxx_kernel&lt;&lt;&lt;gridSize,blockSize,sizof(T)*N&gt;&gt;&gt;(...)</code>，其中第三个参数为声明的共享内存大小，且在核函数内部必须以<code>extern __shared__ T array[];</code>的方式进行声明。</p><div class="note note-primary">            <p>不能声明成extern <strong>shared</strong> T *array;</p><p>因为指针与数组是不同的，所以这样会编译错误。</p>          </div><div class="note note-info">            <p>在设备上使用动态共享内存和静态共享内存是没有明显的性能差距的，所以最好使用动态共享内存。</p>          </div><h4 id="共享内存的bank冲突">共享内存的bank冲突</h4><p>在共享内存中，连续的32-bits字被分配到连续的32个bank中，这就像电影院的座位一样：一列的座位就相当于一个bank，所以每行有32个座位，在每个座位上可以“坐”一个32-bits的数据(或者多个小于32-bits的数据，如4个char型的数据，2个short型的数据)；而正常情况下，我们是按照先坐完一行再坐下一行的顺序来坐座位的，在sharedmemory中地址映射的方式也是这样的。下图中内存地址是按照箭头的方向依次映射的：</p><img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-8/pic1.png" class=""><p>每个bank内的存储数据是共用一根总线的，所以当有两个及以上的线程需要访问一个bank内的数据时，需要两次总线操作；而所有线程访问不同bank内的数据时，所有的访问都能在一次总线操作，因此bank冲突会导致性能下降。</p><h2 id="总结">总结</h2><ul><li>__syncthreads()函数可以用于线程块内线程同步。</li><li>静态共享内存在核函数内使用<code>__shared__</code>修饰符进行修饰。</li><li>动态共享内存需要在核函数调用时传递第三个参数<code>xxx_kernel&lt;&lt;&lt;gridSize,blockSize,sizof(T)*N&gt;&gt;&gt;(...)</code>，并且在核函数内声明为<code>extern __shared__ array[];</code></li><li>要尽可能避免bank冲突。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(7)--CUDA软件抽象与硬件抽象</title>
    <link href="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/"/>
    <url>/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda软件抽象与硬件抽象">CUDA软件抽象与硬件抽象</h2><span id="more"></span><p>之前我们了解了许多概念，比如SM、计算网格、线程块等等，但这些包含对软件部分的抽象和对硬件部分的抽象，下面我们来分别对这些层次的抽象进行具体的描述。</p><h3 id="硬件抽象">硬件抽象</h3><img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic1.jpg" class=""><p>硬件抽象包括SM(流多处理器，大核心)、SP(流处理器，小核心)。SP是GPU最基本的处理单元，也称为CUDAcore，每个SM中包含几十或者上百个CUDA核心。</p><p>其中，SP是执行每个线程的单元，一个SP对应一个线程。每个SP有自己的寄存器和局部内存，可以看作是微型CPU。</p><p>而SM则是多个SP聚合在一起，并且有负责管理线程调度的单元，和共享内存等。</p><div class="note note-primary">            <p>可以用下面这个例子来进行类比：</p><p>将GPU比作教学楼，那么SM就是教学楼中的每一个楼层，有着一些共享设施(wrap调度器、共享内存等)；而SP就是每一间教室里的学生，有着自己的课桌和其他资源(寄存器、局部内存、运算器等)；而每间教室则可以看成是对SP进行的一个分组(线程束)，活动(计算)都是以班级为单位整体进行的(即单指令多线程)。</p>          </div><h3 id="软件抽象">软件抽象</h3><img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic2.png" class=""><p>软件抽象包括计算网格、线程块、线程束、线程。</p><p>计算网格是用于对计算任务的抽象，其大小限制为(<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>,<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.656ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></span>,<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.656ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></span>)，主要目的是用于将计算任务划分成不同的最小计算单元。<strong>计算网格是GPU级别的基本调度单位</strong>。</p><p>线程块也是用于对计算任务的抽象，线程块大小最大为1024。同一线程块的线程(线程束)将会被分配到同一个SM上。<strong>线程块是SM级别的基本调度单位</strong>。</p><p>线程束，线程束就是软件抽象与硬件抽象的桥梁，与硬件中的线程束相对应，线程束大小为32。每个线程束中的线程是通过单指令多线程来执行的，所以每个线程做的工作是一样的。<strong>线程束是ALU级别的基本调度单位</strong>。</p><p>线程，线程是执行具体计算的东西，但是线程不会被单个调度，都是以线程束为整体进行调度的。</p><div class="note note-primary">            <p>可以用下面这个例子来进行类比：</p><p>将GPU所有的计算资源看作学校，那么计算网格就是学校里面的年级，有时候不同年级也会出现在同一层楼中(一个SM可以对应多个线程块，<strong>但这里稍微有些差异，因为一个线程块只能对应一个SM</strong>)；线程块对应的是班级，一个班级的所有人肯定是在一层楼中的(对应线程块上所有线程束在同一个SM上)，且班级一般都是一样大的(最大线程数相同)；线程束是班级里面划分的小组，一般收作业都是每个小组一起交(线程束统一被调度，且任务相同)；线程则对应个人。</p>          </div><h3 id="执行计算过程">执行计算过程</h3><img src="/2022/09/09/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-7/pic3.png" class=""><p>有了软件抽象和硬件抽象，下面我们就来考虑具体的任务是怎么被执行的。</p><p>虽然GPU是并行运行，但也并不是我们理想中所有的线程一起工作。下面我们还是以例子来进行说明。</p><p>当学校组织全校大扫除时(计算任务)，首先会按照年级来为各年级(SM)下达指令(计算网格)，然后每个年级再为每个班级(线程块)分配包干区(线程块分配)，在打扫卫生时，并不是所有学生一起干活，学生经过老师（这里我们理解为线程束调度器）安排后，分为一组一组的小组(线程束)，每一个小组都只会做一件一样的事情，如果有人先做完了或者不需要做，那么他也会在旁边等他的组员，处于等待状态，直到小组内所有组员工作完成；另外，由于工具是有限的(计算资源有限)，所以可能会存在一部分小组暂时干不了活(没有足够资源调度)，且某个小组干完活之后送还工具是需要时间的(调度耗时)。</p>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(6)--CUDA内存组织与使用</title>
    <link href="/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-6/"/>
    <url>/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-6/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda内存组织与使用">CUDA内存组织与使用</h2><span id="more"></span><h3 id="cuda的内存组织结构">CUDA的内存组织结构</h3><p>与CPU的内存结构相似，GPU也是存在类似L1、L2之类的高速缓存的东西，而且CUDA为程序员提供更多的控制权，下面列出CUDA的内存模型。</p><table><thead><tr class="header"><th style="text-align: center;">内存类型</th><th style="text-align: center;">物理位置</th><th style="text-align: center;">访问权限</th><th style="text-align: center;">可见范围</th><th style="text-align: center;">生命周期</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">全局内存</td><td style="text-align: center;">芯片外</td><td style="text-align: center;">R/W</td><td style="text-align: center;">所有线程和主机端</td><td style="text-align: center;">主机分配和释放</td></tr><tr class="even"><td style="text-align: center;">常量内存</td><td style="text-align: center;">芯片外</td><td style="text-align: center;">R</td><td style="text-align: center;">所有线程和主机端</td><td style="text-align: center;">主机分配和释放</td></tr><tr class="odd"><td style="text-align: center;">纹理和表面内存</td><td style="text-align: center;">芯片外</td><td style="text-align: center;">R</td><td style="text-align: center;">所有线程和主机端</td><td style="text-align: center;">主机分配和释放</td></tr><tr class="even"><td style="text-align: center;">寄存器内存</td><td style="text-align: center;">芯片内</td><td style="text-align: center;">R/W</td><td style="text-align: center;">单个线程</td><td style="text-align: center;">所在线程</td></tr><tr class="odd"><td style="text-align: center;">局部内存</td><td style="text-align: center;">芯片外</td><td style="text-align: center;">R/W</td><td style="text-align: center;">单个线程</td><td style="text-align: center;">所在线程</td></tr><tr class="even"><td style="text-align: center;">共享内存</td><td style="text-align: center;">芯片内</td><td style="text-align: center;">R/W</td><td style="text-align: center;">单个线程块</td><td style="text-align: center;">所在线程块</td></tr></tbody></table><img src="/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-6/pic1.jpg" class=""><p>下面对这些内存逐一阐述</p><h4 id="全局内存">全局内存</h4><p>全局内存是指核函数中所有线程都访问的内存，与C语言中的全局内存概念上存在差异。其容量是最大的，基本上就是显存容量。当然，其访问速度也是相对比较低的。</p><p>全局内存的主要目的就是为核函数提供数据、在主机与设备和在设备与设备之间传递数据。</p><p>全局内存对所有线程可见，且其是完全由主机端来进行分配和回收的，另外，全局内存是线性排列的。</p><p>我们通过使用cudaMalloc()函数可以动态地在全局内存中分配，但是我们也可以在全局内存上分配静态内存，这样的<code>全局的静态全局内存变量</code>必须在所有函数外部定义，即类似与C语言中的全局变量的定义，同样是所有线程可访问，且大小在编译时确定。</p><p>定义方法如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>__device__ T x; <span class="hljs-comment">// 单个类型为T的变量</span><br>__device__ T x[<span class="hljs-number">120</span>]; <span class="hljs-comment">// 固定长度的数组</span><br><br></code></pre></td></tr></table></figure><p>在核函数内可以对这些<code>全局的静态全局内存变量</code>进行访问，而不需要显示传递，但是这些变量对主机端不可见。</p><p>要想让主机端访问这些变量，或者在主机端和设备之间传递这些数据，需要用到<code>cudaMemcpyToSymbol(symbol:设备符号, src:主机符号, count:长度, offset:设备偏移量, Flag:方向)</code>和<code>cudaMemcpyFromSymbol(dst:主机, symbol:设备, count:长度, offset:设备偏移量,Flag:方向)</code>来进行传递。</p><h4 id="常量内存">常量内存</h4><p>常量内存是有常量缓存的内存，数量有限，只有64K，其可见范围与生存周期与全局内存一样。不过常量内存仅可读，不可写。但是由于其存在缓存，所以速度会高很多。如果想得到高速的访问速度，需要保证线程束中的线程(线程块中相邻的32个线程)读取相同的常量内存(这样高速缓存才会命中)，(每个线程束由一个SM负责处理)。</p><p>定义常量内存的方式是使用<code>__constant__</code>关键字来修饰变量，并使用<code>cudaMemcpyToSymbol()</code>来将数据复制到设备端。一般来说，给核函数按指传递的数据就放在常量内存中，但给核函数传递的参数最多在核函数内使用4KB常量内存。</p><h4 id="纹理内存与表面内存">纹理内存与表面内存</h4><p>纹理内存与表面内存类似与常量内存，有相同的可见范围与生命周期，但是其容量更大，使用方式也略微有些区别。</p><p>对比较新的架构，对全局只读内存使用<code>__ldg(*addr)</code>函数可以通过全局只读缓存读取，这样速度会快一些。</p><h4 id="寄存器">寄存器</h4><p>核函数中定义的不加任何修饰符的变量就位于寄存器，gridDim这些也位于特殊的寄存器，所以访问的很快。在核函数中定义的数组有可能放在寄存器中，这取决于数组大小。</p><p>寄存器变量位于芯片中，是访问速度最高的，且与所属线程生命周期一样长。</p><h4 id="局部内存">局部内存</h4><p>局部内存是全局内存的一部分，所以延迟很高，但是其使用方式跟寄存器内存一致。即在核函数内定义的不加修饰的变量或数组，存的下的位于寄存器，存不下的位于局部内存。</p><p>每个线程最多使用512k的局部内存，但是使用过多会降低性能。</p><h4 id="共享内存">共享内存</h4><p>共享内存位于芯片上，读写速度仅次于寄存器，不过其声明周期是与线程块一样长。线程块内的所有线程都可以访问共享内存。</p><h4 id="缓存">缓存</h4><p>一般来说，高速缓存是不能被编程的，其执行过程是自动的，但是其对优化程序速度非常大。</p><p>GPU的缓存有L1缓存(SM层次)、L2缓存(设备层次)，但是从硬件角度看L1缓存、纹理缓存和共享内存使用的相同的物理结构。</p><div class="note note-primary">            <p>此处仅考虑图灵架构，因为图灵架构是最新的架构。</p>          </div><p>因此，共享内存其实就可以看成是可以编程的缓存。</p><h3 id="sm中的资源数目">SM中的资源数目</h3><p>一个GPU是由多个SM组成的，一个SM包含以下资源：</p><ul><li>一定数量的寄存器</li><li>一定数量的共享内存</li><li>常量内存缓存</li><li>纹理和表面内存缓存</li><li>L1缓存</li><li>线程束调度器，用于对就绪线程发出执行命令</li><li>执行核心<ul><li>若干整型运算核心INT32</li><li>若干单精度浮点数运算核心FP32</li><li>若干双精度浮点数运算核心FP64</li><li>若干单精度浮点数超越函数的函数单元SFUs</li><li>若干混合精度的张量核心tensor core</li></ul></li></ul><p>因为一个SM的资源是有限的，所以有些情况下SM中驻留的线程数可能达不到理想的最大值，也就是SM的占有率不足100%。</p><p>一般来说，让SM占有率保持在一个值(25%)以上，才可能获得高性能计算。</p><p>另外，在图灵架构中，一个SM最多拥有16个线程块，且一个SM中最多有1024个线程（注意一个线程块中最多线程数目也是1024，而一个线程束大小为32）</p><h4 id="运行时api查询设备">运行时API查询设备</h4><p>通过一些运行时API来查询设备资源，可以用于编写针对不同架构的的显卡的程序。</p><p>下面给出一个代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TARGET 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK(call)                                   \</span><br><span class="hljs-meta">do                                                    \</span><br><span class="hljs-meta">{                                                     \</span><br><span class="hljs-meta">    const cudaError_t error_code = call;              \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (error_code != cudaSuccess)                    \</span><br><span class="hljs-meta">    {                                                 \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"CUDA Error:\n"</span>);                      \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    File:       %s\n"</span>, __FILE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Line:       %d\n"</span>, __LINE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error code: %d\n"</span>, error_code);   \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error text: %s\n"</span>,                \</span><br><span class="hljs-meta">            cudaGetErrorString(error_code));          \</span><br><span class="hljs-meta">        exit(1);                                      \</span><br><span class="hljs-meta">    }                                                 \</span><br><span class="hljs-meta">} while (0)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TARGET == 1</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> device_id = <span class="hljs-number">0</span>;<br><br>cudaDeviceProp prop;<br><span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaGetDeviceProperties</span>(&amp;prop, device_id)); <span class="hljs-comment">// 获取设备数据</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"device id : %d \n"</span>, device_id);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"device name : %s \n"</span>, prop.name);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"compute capability %d.%d\n"</span>, prop.major, prop.minor);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"global mem : %g GB\n"</span>, prop.totalGlobalMem / (<span class="hljs-number">1024.0</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"constant mem : %g kb\n"</span>, prop.totalConstMem / <span class="hljs-number">1024.0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max grid size : (%d, %d, %d)\n"</span>, prop.maxGridSize[<span class="hljs-number">0</span>], prop.maxGridSize[<span class="hljs-number">1</span>], prop.maxGridSize[<span class="hljs-number">2</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max block size : (%d, %d, %d)\n"</span>, prop.maxThreadsDim[<span class="hljs-number">0</span>], prop.maxThreadsDim[<span class="hljs-number">1</span>], prop.maxThreadsDim[<span class="hljs-number">2</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"numbers of SM : %d\n"</span>, prop.multiGpuBoardGroupID);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max shared mem per block : %g kb\n"</span>, prop.sharedMemPerBlock / <span class="hljs-number">1024.0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max numbers of register per block : %d K\n"</span>, prop.regsPerBlock);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max numbers of register per SM : %d K\n"</span>, prop.regsPerMultiprocessor/<span class="hljs-number">1024</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max number of threads per block : %d\n"</span>, prop.maxThreadsPerBlock);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"max number of threads per SM : %d\n"</span>, prop.maxThreadsPerMultiProcessor);<br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(5)--CUDA二维计算网格</title>
    <link href="/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-5/"/>
    <url>/2022/09/08/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-5/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda二维计算网格">CUDA二维计算网格</h2><span id="more"></span><h3 id="二维计算网格">二维计算网格</h3><h4 id="核函数创建二维计算网格">核函数创建二维计算网格</h4><p>之前我们的核函数是按照如下方式来创建计算网格的。</p><p><code>xxx_kernel &lt;&lt; &lt;2, 2 &gt;&gt; &gt; ();</code></p><p>前几篇也介绍过，这里会自动转换成<code>xxx_kernel &lt;&lt; &lt;dim3(2,1,1), dim3(2,1,1) &gt;&gt; &gt; ();</code>，后面两个维度的参数默认是1。</p><div class="note note-primary">            <p>需要注意的是，在开普勒、图灵架构中，线程块内线程总数不超过1024</p>          </div><p>所以我们需要创建一个二维网格只需要按照下面的方式调用核函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function">dim3 <span class="hljs-title">gridSize</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">blockSize</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>...<br><br>xxx_kernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;();<br><br></code></pre></td></tr></table></figure><h4 id="核函数内部确定线程位置">核函数内部确定线程位置</h4><p>在一维计算网格中，我们使用<code>blockIdx.x</code>和<code>threadIdx.x</code>来获取当前线程处的索引。在二维计算网格中，也是类似的，我们给核函数传递的网格维度和线程块维度存储在<code>gridDim</code>，<code>blockDim</code>中，这两个变量有<code>x</code>,<code>y</code>,<code>z</code>三个成员存储传入dim3的三个维度。</p><p>与之类似，<code>blockIdx</code>和<code>threadIdx</code>也有<code>x</code>,<code>y</code>,<code>z</code>三个成员分别存储当前线程块索引和线程索引。</p><p>下面给出一个简单的二维计算网格的程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK(call)                                   \</span><br><span class="hljs-meta">do                                                    \</span><br><span class="hljs-meta">{                                                     \</span><br><span class="hljs-meta">    const cudaError_t error_code = call;              \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (error_code != cudaSuccess)                    \</span><br><span class="hljs-meta">    {                                                 \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"CUDA Error:\n"</span>);                      \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    File:       %s\n"</span>, __FILE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Line:       %d\n"</span>, __LINE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error code: %d\n"</span>, error_code);   \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error text: %s\n"</span>,                \</span><br><span class="hljs-meta">            cudaGetErrorString(error_code));          \</span><br><span class="hljs-meta">        exit(1);                                      \</span><br><span class="hljs-meta">    }                                                 \</span><br><span class="hljs-meta">} while (0)</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W 500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> H 500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TX 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TY 32</span><br><br><span class="hljs-comment">// 核函数，这里的float2是一个二维向量</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">distanceKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> * d_out, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, float2 pos)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-comment">// 行索引</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> r = blockIdx.y*blockDim.y + threadIdx.y; <span class="hljs-comment">// 列索引</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = r * w + c; <span class="hljs-comment">// 行优先存储，获取到当前线程的实际位置</span><br><br><span class="hljs-keyword">if</span> ((c &gt;= w) || (r &gt;= h))<br><span class="hljs-keyword">return</span>;<br><br>d_out[i] = <span class="hljs-built_in">sqrtf</span>((c - pos.x)*(c - pos.x) + (r - pos.y)*(r - pos.y)); <span class="hljs-comment">// 计算结果</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"thread (%d, %d) in grid (%d, %d) computes the result is %f\n"</span>, threadIdx.x, threadIdx.y, blockIdx.x, blockIdx.y,d_out[i]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> *out = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(W*H, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)); <span class="hljs-comment">// 主机内存</span><br><span class="hljs-type">float</span> * d_out; <span class="hljs-comment">// 设备内存</span><br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_out, W*H* <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)); <span class="hljs-comment">// 为设备分配内存</span><br><span class="hljs-type">const</span> float2 pos = { <span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span> }; <span class="hljs-comment">// 初始化计算过程中传递的常量</span><br><span class="hljs-function"><span class="hljs-type">const</span> dim3 <span class="hljs-title">blockSize</span><span class="hljs-params">(TX, TY)</span></span>; <span class="hljs-comment">// 指定线程块大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> bx = (W + TX - <span class="hljs-number">1</span>) / TX; <span class="hljs-comment">// 向上舍入计算出x方向的计算网格数目</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> by = (H + TY - <span class="hljs-number">1</span>) / TY; <span class="hljs-comment">// 向上摄入计算处y方向的计算网格数目</span><br><span class="hljs-type">const</span> dim3 gridSize = <span class="hljs-built_in">dim3</span>(bx, by); <span class="hljs-comment">// 指定计算网格大小</span><br><br>distanceKernel &lt;&lt; &lt;gridSize, blockSize &gt;&gt; &gt; (d_out, W, H, pos); <span class="hljs-comment">// 启动核函数</span><br><br><span class="hljs-built_in">cudaDeviceSynchronize</span>(); <span class="hljs-comment">// 同步设备与主机</span><br><span class="hljs-built_in">cudaMemcpy</span>(out, d_out, W*H * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), cudaMemcpyDeviceToHost); <span class="hljs-comment">// 拷贝计算结果</span><br><br><span class="hljs-built_in">cudaFree</span>(d_out); <span class="hljs-comment">// 释放内存</span><br><span class="hljs-built_in">free</span>(out);<br>}<br><br></code></pre></td></tr></table></figure><p>注意，执行这个程序的时候，可以观测到明显的输出卡顿，这就是前面提到的由于GPU高速缓存能力比较弱，所以当核函数执行简单的计算时内存IO将成为瓶颈。</p><h2 id="总结">总结</h2><ul><li>线程块内线程总数不超过1024。</li><li>blockIdx和threadIdx存在三个成员来保存维度</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(4)--CUDA错误检测与程序计时</title>
    <link href="/2022/09/06/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-4/"/>
    <url>/2022/09/06/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-4/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda错误检测与程序计时">CUDA错误检测与程序计时</h2><span id="more"></span><h3 id="错误检测">错误检测</h3><h4 id="程序中的错误">程序中的错误</h4><p>前面写的程序其实是存在重大问题的，只是我们刻意选择了一些数据来规避了错误的触发。</p><p>其引起错误的关键是这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TPB 32</span><br><br>...<br><br>distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, d_in, ref);<br><br></code></pre></td></tr></table></figure><p>核函数会创建N/TPB个线程块，每个线程块中有TPB个线程。此处每个线程块内的线程数目是确定的(因为一般都是2的整数次幂)。</p><p>而如果N不是2的整数次幂，比如N=63，此时计算出来的N/TPB = 63/32 =1，也就意味着此时只分配一个有32个线程组成的线程块，是不足以完成整个计算的。</p><p>所以我们需要N/TPB向上取整才对，将这个公式改成<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="8.434ex" height="2.774ex" role="img" focusable="false" viewBox="0 -880.9 3728 1225.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(237,398) scale(0.707)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1666,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(704,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(1455,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g><rect width="1765.5" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2227.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3228,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>就完成了向上取整的任务。但是此时又会引入新的问题。</p><p>比如此时N取65，那么就会分配64/32+1=3个线程块，而每个线程块内又有32个线程，这样就分配了96个线程用于计算，而每个线程会访问其索引对应的数组位置，但是我们只分配了N=65个浮点数的内存，当后续的线程访问对应的数组下标时，其实引发了数组越界的问题，会导致段错误或者是完成计算但是结果匪夷所思。</p><p>此处我们当然可以在核函数内使用如下形式的if来结束掉不必要的线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">if</span> (i &gt;= N)<br><span class="hljs-keyword">return</span>;<br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>核函数不可以有返回值，但是能用return，return后不能带参数</p>          </div><h4 id="检测cuda运行时的宏函数">检测CUDA运行时的宏函数</h4><p>上面的错误是比较明显的，所以我们可以直接纠正。但是还有一部分错误我们可能没有办法快速定位(因为CUDA不会主动抛出错误，造成DEBUG上困难)。</p><div class="note note-primary">            <p>此处只讨论运行时错误，因为编译时错误肯定会被检测出来。</p>          </div><p>但是，虽然我们没法直接定位错误，但是所有以cuda开头的函数其实都是有返回值的，其返回值的类型为<code>cudaError_t</code>，代表了一种错误信息，只有当返回值为<code>cudaSuccess</code>时，才成功调用了函数。</p><p>可以创建一个用于在运行时检测CUDA函数错误的宏函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK(call)                                   \</span><br><span class="hljs-meta">do                                                    \</span><br><span class="hljs-meta">{                                                     \</span><br><span class="hljs-meta">    const cudaError_t error_code = call;              \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (error_code != cudaSuccess)                    \</span><br><span class="hljs-meta">    {                                                 \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"CUDA Error:\n"</span>);                      \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    File:       %s\n"</span>, __FILE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Line:       %d\n"</span>, __LINE__);     \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error code: %d\n"</span>, error_code);   \</span><br><span class="hljs-meta">        printf(<span class="hljs-string">"    Error text: %s\n"</span>,                \</span><br><span class="hljs-meta">            cudaGetErrorString(error_code));          \</span><br><span class="hljs-meta">        exit(1);                                      \</span><br><span class="hljs-meta">    }                                                 \</span><br><span class="hljs-meta">} while (0)</span><br><br></code></pre></td></tr></table></figure><p>在调用一个cudafunc时，可以CHECK(cudafunc)这样来调用，当函数出现错误时，就能被宏函数捕捉到。</p><h4 id="检查核函数中的错误">检查核函数中的错误</h4><p>上述方法只能用于检测以cuda函数开头的函数是否被正确执行。但是由于核函数不存在返回值，所以核函数需要用别的方法进行检查。</p><p>下面给出两个自带的函数：</p><ul><li><code>cudaGetLastError()</code>：捕捉上一个错误。</li><li><code>cudaDeviceSynchronize()</code>：同步主机与设备。</li></ul><div class="note note-primary">            <p><strong>同步主机与设备</strong></p><p>由于核函数是异步调用的，即主机调用完核函数后会直接执行下一条指令，而不会等核函数执行完。</p><p>不过由于同步操作相当耗时，所以一般不在循环内层调用。只会在必要的时候调用。</p>          </div><p>在核函数调用后加上下面这两句就能实现检测核函数错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaGetLastError</span>());<br><span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaDeviceSynchronize</span>());<br><br></code></pre></td></tr></table></figure><h4 id="检查内存错误">检查内存错误</h4><p>CUDA提供了CUDA-MEMCHECK工具集，可以在命令行使用<code>cuda-memcheck</code>来使用。</p><p>当使用nvcc编译程序后，执行<code>cuda-memcheck ./a.out</code>就可以看到内存错误检查后的结果。</p><h3 id="cuda事件计时">CUDA事件计时</h3><p>对一个函数或程序进行计时是很常见的事情，毕竟，我们用GPU改写了一个程序后，肯定想定量的计算性能的提升。</p><p>在CUDA中，提供了基于CUDA事件的计时方法。在CUDA程序中，CPU端将命令写到命令缓冲区中，GPU端会依次读取命令缓冲区并执行任务，一般的程序中，GPU需要给CPU汇报任务的工作进度。命令缓冲区和“同步信息位置”都位于锁页主机内存上，所以CPU和GPU都能同时读写这些数据。在这个“同步信息位置”的内存上，会设置一个单调递增的整数值（“进度值”），GPU完成一条命令操作之后，就会更新递增这个“同步值”，CPU读取这个“同步值”，就可以知道GPU的工作进度。</p><p>CUDA事件可以反映这种硬件能力，cudaEventRecord()函数的作用是将一个命令加入队列，使一个新的同步值写入共享同步位置中，cudaEventQuery()和cudaEventSynchronize()则分别用于检查和等待这个事件的同步值。</p><p>其实原理很简单：先用cudaEventRecord()记录下一个起始事件的时刻，然后再记录下结束事件的时刻，然后两者做差就能得到时间了。但是需要注意，事件记录这件事本身也是异步的，因此需要在结束事件的位置进行同步，让CPU等待这个事件被记录。</p><p>下面是抽象出来的记录时间的代码片段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>cudaEvent_t start, stop; <span class="hljs-comment">// 创建事件</span><br><span class="hljs-built_in">cudaEventCreate</span>(&amp;start); <span class="hljs-comment">// 初始化事件</span><br><span class="hljs-built_in">cudaEventCreate</span>(&amp;stop); <span class="hljs-comment">// 初始化事件</span><br><span class="hljs-built_in">cudaEventRecord</span>(start); <span class="hljs-comment">// 事件开始，用于计时</span><br><span class="hljs-built_in">cudaEventQuery</span>(start); <span class="hljs-comment">// 刷新队列</span><br><br><span class="hljs-comment">/*下面是需要被计时的代码片段*/</span><br><br><span class="hljs-comment">/*上面是需要被计时的代码片段*/</span><br><br><span class="hljs-built_in">cudaEventRecord</span>(stop); <span class="hljs-comment">// 结束事件记录</span><br><span class="hljs-built_in">cudaEventSynchronize</span>(stop); <span class="hljs-comment">// 让主机等待事件stop被记录完毕</span><br><span class="hljs-type">float</span> times = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">cudaEventElapsedTime</span>(&amp;times, start, stop); <span class="hljs-comment">// 获取起始事件和结束事件的差值，单位ms</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"time = %f\n"</span>, times); <br><span class="hljs-built_in">cudaEventDestroy</span>(start); <span class="hljs-comment">// 销毁事件</span><br><span class="hljs-built_in">cudaEventDestroy</span>(stop);<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>如果不在结束事件出进行同步，那么是不会得到正确的时间的。</p><p>可以把同步处代码注释掉，然后将获取时间的部分改成<code>CHECK(cudaEventElapsedTime(&amp;times, start, stop));</code></p><p>这样就能看到device notready的错误了，且输出的时间为0，也是不正确的。</p>          </div><h4 id="分析代码性能工具">分析代码性能工具</h4><p>CUDA工具箱中存在一个叫<code>nvprof</code>的程序，可以执行性能分析。但是注意要将cuda下的<code>extras\CUPTI\lib64</code>添加到环境变量，同时此程序必须运行在管理员模式下。</p><p>输入<code>nvprof {程序名}</code>即可执行代码性能分析。</p><h4 id="影响gpu加速的关键因素">影响GPU加速的关键因素</h4><ul><li>由于调用设备GPU计算需要将数据先传递到GPU中，这会导致额外的耗时，所以小规模计算是不划算的。另外，GPU与CPU的连接桥PCIE总线速度是远远低于GPU显存带宽的，因此不能将数据来回传递。</li><li>GPU由于没有很多空间去布置高速缓存，因此在GPU中，对内存进行读写是相当耗时的。这导致开销比较低的计算(比如简单加法)时受到内存读写瓶颈的限制，导致性能下降。</li><li>GPU一个SM能驻留1024个线程，而一个GPU有几个到几十个SM，因此能开到几万至几十万个线程，当我们的并行规模远小于这个数目时，性能就不能达到最优。</li></ul><p>因此我们想要获得很好的加速性能就需要满足以下几点：</p><ul><li>数据传输比例小，减少主机与设备的数据传输。</li><li>提高核函数的运算强度。</li><li>增大核函数的并行规模。</li></ul><h2 id="总结">总结</h2><ul><li>每个cuda函数都使用宏函数来检测错误</li><li>使用CHECK(cudaGetLastError())来检测核函数错误</li><li>cuda-memcheck工具来检测内存错误</li><li>使用cuda事件用于计时</li><li>nvprof来进行代码分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(3)--CUDA编程初试</title>
    <link href="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-3/"/>
    <url>/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-3/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda编程初试">CUDA编程初试</h2><span id="more"></span><h3 id="第一个调用gpu计算的程序">第一个调用GPU计算的程序</h3><p>在前面，我们已经写了一个串行的dist程序计算，现在我们尝试对其进行改进，从而得到一个使用GPU进行计算的程序。</p><p>为了调用GPU，所以我们需要写一个核函数，从而在主机端调用GPU。由于核函数是用于不断产生出线程，而线程才是真正用于计算的东西，所以我们在核函数内需要为每个线程分配计算任务，这个就是等价之前for循环内部的东西。</p><p>值得注意的是，每个被核函数调用出来的线程执行的计算都是相同的，所以在核函数内需要为每个线程分配数据，这样就可以执行计算。</p><div class="note note-primary">            <p>与之类比，在C语言中fork出的新线程可以执行与原有线程不一样的指令。</p>          </div><h4 id="每个线程分配计算数据">每个线程分配计算数据</h4><p>那如何为每个线程分配数据呢？</p><p>在核函数内，有以下的变量可以用于给不同的线程分配数据，这些变量是提供线程块核线程的维度数核索引变量</p><ul><li><p><code>gridDim</code>：声明了网格中的线程块数目</p></li><li><p><code>blockDim</code>：声明了每个线程块中的线程数目</p></li><li><p><code>blockIdx</code>：给出了线程块在这个网格中的索引</p></li><li><p><code>threadIdx</code>：给出了这个线程在这个线程块中的索引</p></li></ul><div class="note note-primary">            <p>前两个的类型为<code>dim3</code>，这是一个1*3的向量，可以使用.x.y.z来访问。</p><p>后面两个类型为<code>uint3</code>，这也是一个1*3向量，遇上一个类似。</p><p>核函数调用时的&lt;&lt;&lt;A,B&gt;&gt;&gt;其实是&lt;&lt;&lt;dim3(A,1,1),dim3(B,1,1)&gt;&gt;&gt;，即目前声明的都是1维数组，当需要计算二维、三维的时候，就可以声明高维数组。</p><p><span class="label label-info">每个线程块的线程数不超过1024</span></p>          </div><h4 id="主机端与gpu的数据通信">主机端与GPU的数据通信</h4><p>由于GPU不能直接访问主机端中的数据，所以，CUDA提供了一系列可以把数据从设备传回主机的API</p><p>位于头文件<code>cuda_runtime.h</code></p><ul><li><p><code>cudaMalloc()</code>：分配设备端内存</p></li><li><p><code>cudaMemcpy()</code>：将数据传入或传出设备</p></li><li><p><code>cudaFree()</code>：释放设备内存</p></li><li><p><code>size_</code>：内存大小的专用变量</p></li><li><p><code>cudaError_t</code>：错误处理专用变量</p></li></ul><h4 id="编写程序">编写程序</h4><p>有了上面的内容，我们很容易就将之前的串行程序改成GPU并行程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cuda_runtime.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TPB 32</span><br><br><span class="hljs-comment">// 执行放缩的函数</span><br><span class="hljs-function">__device__ <span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-comment">// 计算距离的函数</span><br><span class="hljs-function">__device__ <span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x1 - x2)*(x1 - x2));<br>}<br><br><span class="hljs-comment">// 核函数，每个线程通过当前的线性维度来处理数组中的数据</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">distanceKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_out, <span class="hljs-type">float</span> ref, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 由于有两个网格，每个网格内有数目相等的线程</span><br>    <span class="hljs-comment">// 所以就分别对其编号就可以了</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> x = <span class="hljs-built_in">scale</span>(i, len);<br>d_out[i] = <span class="hljs-built_in">distance</span>(x, ref);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> *d_out = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 分配设备端内存</span><br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_out, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><br>distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, ref, N);<br><br><span class="hljs-built_in">cudaFree</span>(d_out);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>}<br><br></code></pre></td></tr></table></figure><p>执行<code>nvcc distcuda.cu</code>来编译，运行后可以看到，程序的执行顺序是乱的，但是其结果都被打印出来了。</p><h2 id="另一个更深入的cuda程序">另一个更深入的CUDA程序</h2><p>我们之前写过两个版本的dist，现在我们把第二个版本的dist并行化。<br>这是一个更加通用的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DIST == 2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TPB 32</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function">__device__ <span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">distanceKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_out, <span class="hljs-type">float</span> * d_in, <span class="hljs-type">float</span> ref)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> x = d_in[i];<br>d_out[i] = <span class="hljs-built_in">distance</span>(x, ref);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">distanceArray</span><span class="hljs-params">(<span class="hljs-type">float</span> * out, <span class="hljs-type">float</span> *in, <span class="hljs-type">float</span> ref, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> *d_out = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> *d_in = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_out, len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-built_in">cudaMalloc</span>(&amp;d_in, len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><br><span class="hljs-built_in">cudaMemcpy</span>(d_in, in, len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), cudaMemcpyHostToDevice);<br><br>distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (d_out, d_in, ref);<br><br><span class="hljs-built_in">cudaMemcpy</span>(out, d_out, len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), cudaMemcpyDeviceToHost);<br><br><span class="hljs-built_in">cudaFree</span>(d_in);<br><span class="hljs-built_in">cudaFree</span>(d_out);<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> * in = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-type">float</span> * out = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br>in[i] = <span class="hljs-built_in">scale</span>(i, N);<br>}<br><br><span class="hljs-built_in">distanceArray</span>(out, in, ref, N);<br><br><span class="hljs-built_in">free</span>(in);<br><span class="hljs-built_in">free</span>(out);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><h3 id="程序执行过程">程序执行过程</h3><ol type="1"><li>在设备上创建数组，这个数组大小和主机上的数组大小一致。</li><li>在内存上分配内存来存储输入的数据。</li><li>将主机端的数组复制到设备中(<code>cudaMemcpy</code>函数)</li><li>启动核函数执行计算并将输出值存储在设备内存上的输出数组中</li><li>将设备上的结果赋值到主机端</li><li>释放内存</li></ol><p>注意到，在GPU上的计算比在主机端的计算不一样的地方：</p><ul><li>在设备上创建一个镜像数组，然后需要把数据拷贝过去</li><li>启动一个核函数并执行大量计算</li><li>把结果拷贝回主机</li></ul><p>很明显，只有当核函数并行计算的收益超过拷贝数据时，使用GPU计算才是合理的。</p><h3 id="统一内存与托管数组">统一内存与托管数组</h3><p>在两个设备之间传递已有的很大数组这个步骤是必要且有点冗余的，所以出现了统一内存来<strong>简化开发流程</strong>。</p><p>统一内存就是一个主机和设备可以共同访问的内存，但实际上只是CUDA帮助我们完成了在主机与设备之间拷贝数组的活，这项工作本身没有消失，只是不需要显示地做了。另外，CUDA系统调度内存可能不如手工管理内存那样好。</p><p>其实现方式是使用<code>cudaMallocManaged()</code>即可。</p><p>我们对上一个程序使用统一内存来进行简化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;device_launch_parameters.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TPB 32</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function">__device__ <span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">distanceKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> *d_out, <span class="hljs-type">float</span> * d_in, <span class="hljs-type">float</span> ref)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> x = d_in[i];<br>d_out[i] = <span class="hljs-built_in">distance</span>(x, ref);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %2d: dist from %f to %f is %f\n"</span>, i, ref, x, d_out[i]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">distanceArray</span><span class="hljs-params">(<span class="hljs-type">float</span> * out, <span class="hljs-type">float</span> *in, <span class="hljs-type">float</span> ref, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>{<br>distanceKernel &lt;&lt; &lt;N / TPB, TPB &gt;&gt; &gt; (out, in, ref);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><span class="hljs-type">float</span> * in = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> * out = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">cudaMallocManaged</span>(&amp;in, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-built_in">cudaMallocManaged</span>(&amp;out, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br>in[i] = <span class="hljs-built_in">scale</span>(i, N);<br>}<br><br><span class="hljs-built_in">distanceArray</span>(out, in, ref, N);<br><br><span class="hljs-built_in">cudaFree</span>(in);<br><span class="hljs-built_in">cudaFree</span>(out);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>注意到distanceArray函数中不再需要冗长的复制数据的过程了，这样就非常的方便了。</p><h2 id="总结">总结</h2><ul><li>核函数只能在设备上执行，不能向主机端返回变量，其可以访问设备内存，但是不能访问主机内存(这也是为什么需要用<code>cudaMalloc</code>而不是<code>malloc</code>)。</li><li>可以使用<code>cudaMallocManaged()</code>来自动传递内存，而避免使用<code>cudaMemcpy()</code>来显示传递数据。</li><li>一般每个线程块的线程数目是32的整倍数时，可以对应SM中的CUDA核心数目，这样性能更好。</li><li>gridDim、blockDim、blockIdx、threadIdx这些变量可以用于定位线程的处理数据的索引。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(2)--CUDA基础知识</title>
    <link href="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/"/>
    <url>/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda基础知识">CUDA基础知识</h2><span id="more"></span><h3 id="并行计算与串行计算">并行计算与串行计算</h3><p>对于计算密集型任务，当我们有很多计算核心时，每次只调用其中的一个核心进行一次计算任务，这时很浪费的，而这恰恰正式上一节中编写的程序的工作模式。而为了提高计算单元的效率，我们需要将串行工作模式改成并行计算模式，而这就需要用到CUDA和其API接口。</p><h3 id="cuda的基本概念">CUDA的基本概念</h3><p>由于GPU存在成千上万个廉价的计算单元，如果我们能将一个计算任务分解成多个子任务，这样就可以用GPU来完成并行计算，下面来介绍一下在并行计算中的规划方法。</p><p>CUDA引用了<strong>单指令多线程</strong>的并行模式(即每个线程执行相同的数据计算，然后使用一条指令控制从而减少控制器数目和系统复杂度--设想成千上万的线程各自做不同的事情，如果再有线程间通讯/同步，将会是怎样的梦魇)，GPU中包含大量的基础计算单元，称为<strong>核</strong>，每个核都包含了一个逻辑计算单元和一个浮点计算单元，多个核集成在一起被称为<strong>多流处理器</strong>。</p><img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic1.png" class=""><p>而将每个计算任务分解成多个子任务，称为<strong>线程</strong>，多个线程被组织成<strong>线程块</strong>，线程块被分解成大小与一个SM中核数量相同的<strong>线程束</strong>(大小为32)，每个线程束由一个SM负责执行，这些多流处理器的控制单元指挥其他所有核同时在一个线程束的每个线程中执行同一个指令，这是单指令多线程的来源。</p><h3 id="gpu与cpu对比">GPU与CPU对比</h3><p>众所周知，CPU也是可以执行并行计算的，那两者有什么区别呢？</p><p>首先，CPU是通用计算单元，其核心数目比较少，但是具备处理能力较强，同时其芯片上大部分空间是被设计成用于加速IO的高速缓存。而GPU拥有大量的能力稍弱的核，且每次都是使用一堆核做相同的计算(并不是做一摸一样的计算，而是做类型一样的计算，比如都是加法这样，这是更大的计算任务中的一小部分)，与CPU另一个不同之处在于GPU倾向于延迟隐藏，由于GPU上没有很多高速缓存，因此当一个线程束需要的数据不可达时，SM会转向去处理另一个线程束(挂起)。</p><h3 id="cuda计算任务流程">CUDA计算任务流程</h3><p>GPU计算中的关键结构是<strong>核函数</strong>，其产生大量组织成可以分配给SM的计算线程。</p><p>因此在计算时，需要加载核函数来创建一个由多个线程块组成的<strong>线程网格</strong>，同一个网格上的线程共享相同的全局内存空间，每个网格内有很多线程块，而每个线程块由多个线程组成。</p><p>一个线程块只会由一个SM来调度，但是一个SM可以调度多个线程块。另外由于SM的资源是有限的，所以其调用线程是由上限的。</p><img src="/2022/09/05/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-2/pic2.png" class=""><h3 id="核函数">核函数</h3><p>上面说了核函数是计算的关键函数，下面就来了解一下核函数怎么写。</p><h4 id="核函数的声明与标识符">核函数的声明与标识符</h4><p>由于GPU是一个外部设备，因此每个函数都需要指明这个函数是在主机上调用(CPU)还是在外部设备上调用(GPU)，并根据调用来编译出不同的代码。</p><p>为了告知编译器在哪个设备上编译，就需要额外引入标识符，有以下三种标识符</p><ul><li><p>__global__：在CPU调用父函数，子函数在GPU执行(异步)。用__global__修饰的一般就是内核(kernel)函数。</p></li><li><p>__device__：在GPU调用父函数，子函数在GPU执行。由__device__修饰的函数可以被由__global__和__device__修饰的函数调用，这种情况是动态并行。</p></li><li><p>__host__：在CPU调用父函数，子函数在CPU执行（这是默认的标识符）。</p></li></ul><span class="label label-info">用__host__与__device__修饰的函数将同时在主机核设备上被编译。</span><div class="note note-primary">            <p>一般来说，我们只需要2个修饰词就够了，但是cuda却提供了3个——2个执行位置为GPU。这儿要引入一个“函数执行环境标识符”的概念。父函数调用子函数时，父函数可能运行于CPU或者GPU，相应的子函数也可能运行于CPU或者GPU，但是这绝不是一个2*2的组合关系。因为GPU作为CPU的计算组件，不可以调度CPU去做事，所以不存在父函数运行于GPU，而子函数运行于CPU的情况。</p>          </div><p>另外，核函数不能带有返回值，因此返回类型通常为void，以及在GPU上的核函数是不能访问主机端CPU可以访问的内存数据。</p><p>给出一个声明实例<code>__global__ void run_on_gpu()</code></p><h4 id="核函数的调用">核函数的调用</h4><p>核函数是一种特殊的函数，调用核函数从一个函数名开始，然后以一个包含逗号分割的参数列表，其中网格维度核线程块维度被放在参数列表中(三个尖括号，这是编译器扩展后的)。</p><p>形如<code>aKernal &lt;&lt;&lt;2, 2 &gt;&gt;&gt; ();</code></p><h4 id="一个示例">一个示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"device_launch_parameters.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function">__host__ __device__ <span class="hljs-type">int</span> <span class="hljs-title">run_on_cpu_or_gpu</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">run_on_gpu</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"run_on_cpu_or_gpu GPU: %d\n"</span>, <span class="hljs-built_in">run_on_cpu_or_gpu</span>());<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"run_on_cpu_or_gpu CPU: %d\n"</span>, <span class="hljs-built_in">run_on_cpu_or_gpu</span>());<br>run_on_gpu &lt;&lt; &lt;<span class="hljs-number">2</span>, <span class="hljs-number">2</span> &gt;&gt; &gt; ();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA高性能并行计算(1)--CUDA初步探究</title>
    <link href="/2022/09/04/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1/"/>
    <url>/2022/09/04/CUDA%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-1/</url>
    
    <content type="html"><![CDATA[<h2 id="cuda初步探究">CUDA初步探究</h2><span id="more"></span><h3 id="什么是cuda">什么是CUDA</h3><p>CUDA，即Compute Unified DeviceArchitecture的简称，是由NVIDIA公司创立的基于他们公司生产的图形处理器GPUs的一个并行计算平台和编程模型。</p><p>通过CUDA，GPUs可以很方便地被用来进行通用计算（有点像在CPU中进行的数值计算等等）。在没有CUDA之前，GPUs一般只用来进行图形渲染（如通过OpenGL，DirectX）。<br>开发人员可以通过调用CUDA的API，来进行并行编程，达到高性能计算目的。NVIDIA公司为了吸引更多的开发人员，对CUDA进行了编程语言扩展，如CUDAC/C++,CUDA Fortran语言。注意CUDAC/C++可以看作一个新的编程语言，因为NVIDIA配置了相应的编译器nvcc,CUDAFortran一样。更多信息可以参考文献。</p><div class="note note-primary">            <p>本系列的博客跳过了CUDA环境的安装，如果有需要，请自行查阅相关教程，这方面资料还是很多的。</p><p>另外，本博客的环境是基于CUDA10.2，VS2017，windows10下的。</p>          </div><h3 id="运行cuda的样例">运行CUDA的样例</h3><p>首先先找到CUDA的安装目录（本机是<code>C:\Program Files\NVIDIA GPU Computing Toolkit</code>），然后进入<code>extras/demo_suite</code>目录，就能看到已经编译好的样例程序。</p><p>我们运行<code>nbody.exe</code>，这是一个模拟上千个受到万有引力的粒子运动并进行可视化的程序。可以在控制台中进行调整参数，这个程序还有很炫酷的。</p><p>除了<code>nbody.exe</code>，这个目录下还有其他的一些例程可以运行，同样的，还有一些未被编译的例程，可以手动去编译。</p><h3 id="编写一个串行程序">编写一个串行程序</h3><p>我们首先使用传统方式来写一个计算一个点到一条直线上若干点的距离的程序。</p><p>这个简单的cpp程序使用了一个for循环，先对循环变量进行归一化处理，然后计算并存储与参考位置的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> out[N] = { <span class="hljs-number">0.0f</span> };<br><span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br><span class="hljs-type">float</span> x = <span class="hljs-built_in">scale</span>(i, N);<br>out[i] = <span class="hljs-built_in">distance</span>(x, ref);<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; i : out)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f "</span>, i);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></table></figure><p>接下来我们使用另外一种方式来编写这个程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 64</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> ((<span class="hljs-type">float</span>)i / (n - <span class="hljs-number">1</span>));<br>}<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> x2)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x2 - x1)*(x2 - x1));<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">distanceArray</span><span class="hljs-params">(<span class="hljs-type">float</span> * out, <span class="hljs-type">float</span> * in, <span class="hljs-type">float</span> ref, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>{<br>out[i] = <span class="hljs-built_in">distance</span>(i, n);<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">float</span> * in = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-type">float</span> * out = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">calloc</span>(N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ref = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>{<br>in[i] = <span class="hljs-built_in">scale</span>(i, N);<br>}<br><br><span class="hljs-built_in">distanceArray</span>(out, in, ref, N);<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;N;i++)<br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f "</span>, out[i]);<br>}<br><br><span class="hljs-built_in">free</span>(in);<br><span class="hljs-built_in">free</span>(out);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure><p>我们来重新审视一下这两个程序，这两个程序都是使用串行的方式处理的，即每次处理一个数值，只是两个的写法不一样。</p><ul><li><p>第一个程序是在mian函数中手动处理每个点</p></li><li><p>而第二个程序则是提供了一个统一的抽象接口，mian函数只需要一次调用这个函数就能计算出所有的值</p></li></ul><p>表面上看这两个程序没有本质的区别，但是其标志性的指出了并行程序的编写思路：<strong><em>提供数据并调用接口，一次性获得所有的结果</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>CUDA并行程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(5)--文件和IO</title>
    <link href="/2022/09/02/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/"/>
    <url>/2022/09/02/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/</url>
    
    <content type="html"><![CDATA[<h2 id="文件和io----来源于cookbook第五章">文件和IO----来源于cookbook第五章</h2><span id="more"></span><p><font color="#a0add0">记录第五章中比较有意思的部分</font></p><hr><h3 id="open函数打开文件的小技巧">open函数打开文件的小技巧</h3><div class="note note-primary">            <p>由于有些文件中会出现编码错误或与当前主机不匹配，使用<code>open</code>函数时可以增加<code>errors='ignore'</code>来忽略掉错误的编码。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>g = <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile.txt"</span>, <span class="hljs-string">'rt'</span>, encoding = <span class="hljs-string">'utf-8'</span>, errors = <span class="hljs-string">'ignore'</span>)<br><br></code></pre></td></tr></table></figure><h3 id="使用print函数重定向到文件">使用print函数重定向到文件</h3><div class="note note-primary">            <p>使用<code>print</code>函数的<code>file = handler</code>参数即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'3'</span>,(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"file"</span>,<span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(*l, sep = <span class="hljs-string">','</span>, file = f)<br><br></code></pre></td></tr></table></figure><h3 id="对不存在的文件进行写入操作">对不存在的文件进行写入操作</h3><div class="note note-primary">            <p>直接使用<code>xt</code>模式来操作文件即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile"</span>, <span class="hljs-string">'wt'</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 当somefile不存在时会报错</span><br>    ...<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"somefile"</span>, <span class="hljs-string">'xt'</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># 当somefile不存在时会创建，存在时不影响</span><br>    ...<br><br></code></pre></td></tr></table></figure><h3 id="将二进制文件做内存映射">将二进制文件做内存映射</h3><div class="note note-primary">            <p>使用<code>mmap</code>模块来创建映射，这样可以直接访问，而不需要频繁的seek、read等操作。</p><p>另外，由于虚拟内存的存在，多个python解释器可以映射到同一个文件上从而实现共享数据。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> mmap<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">memory_map</span>(<span class="hljs-params">filename, access = mmap.ACCESS_WRITE</span>):<br>    size = os.path.getsize(filename)<br>    fd = os.<span class="hljs-built_in">open</span>(filename, os.O_RDWR)<br>    <span class="hljs-keyword">return</span> mmap.mmap(fd, size, access = access)<br><br>m = memory_map(<span class="hljs-string">"data"</span>)<br><br><span class="hljs-comment"># 此时就可以像操作数组那样操作m</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(m))<br><span class="hljs-built_in">print</span>(m[:<span class="hljs-number">34</span>])<br>m[:<span class="hljs-number">11</span>] = <span class="hljs-string">b'hello world'</span><br>m.close()<br><br></code></pre></td></tr></table></figure><h3 id="将字节数据写入文本文件">将字节数据写入文本文件</h3><div class="note note-primary">            <p>只需要简答的将字节数据写入到文件底层buffer中就可以了。</p>          </div><div class="note note-warning">            <p>在python中调用print时，事实上调用了sys.stdout.write(obj+'\n')</p><p>而stdout就像是一个类文件对象，因为你可以将他赋值给任意的一个文件对象，重定向输出</p><p>原始的sys.stdout指向控制台，如果把文件的对象引用赋给sys.stdout，那么print调用的就是文件对象的write方法</p><p>而buffer是缓冲区，所以此操作就是不调用上层的write方法而直接写入底层的缓冲区</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 示例一</span><br><br><span class="hljs-keyword">import</span> sys<br><br>sys.stdout.buffer.write(<span class="hljs-string">b'hello\n'</span>)<br><br><br><span class="hljs-comment"># 示例二</span><br><br><span class="hljs-keyword">import</span> sys<br><br>sys.stdout = <span class="hljs-built_in">open</span>(<span class="hljs-string">"filename"</span>,<span class="hljs-string">"xt"</span>)<br><br>sys.stdout.buffer.write(<span class="hljs-string">b'hello\n'</span>)<br><br></code></pre></td></tr></table></figure><h3 id="创建临时文件与文件夹">创建临时文件与文件夹</h3><div class="note note-primary">            <p><code>tempfile</code>模块中有各种实现了上下文管理协议的函数来处理临时文件</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> tempfile <span class="hljs-keyword">import</span> TemporaryFile<br><br><span class="hljs-keyword">with</span> TemporaryFile(<span class="hljs-string">'w+t'</span>, encoding = <span class="hljs-string">'utf-8'</span>, errors = <span class="hljs-string">'ignore'</span>, delete = <span class="hljs-literal">True</span>):<br>    ...<br><br></code></pre></td></tr></table></figure><h3 id="序列化python对象">序列化python对象</h3><div class="note note-primary">            <p><code>pickle</code>模块的dump和load函数就足以处理这些</p>          </div><div class="note note-warning">            <p>注意不要对来源不明的对象进行load，因为这会产生副作用，严重甚至可能导致计算机被入侵。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> pickle<br><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"filename"</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(a,f)<br>    ...<br>    pickle.load(a,f)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webbench源码剖析</title>
    <link href="/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="webbench源码剖析">Webbench源码剖析</h2><span id="more"></span><p><a href="https://github.com/EZLippi/WebBench">项目地址</a></p><h3 id="webbench介绍">Webbench介绍</h3><div class="note note-primary">            <p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。</p><p>而其源码也相当的短，只有500行，读起来非常容易。</p>          </div><p>不过本项目虽然代码量很小，但是最好熟悉unix网络编程，以及linux下C语言多线程的实现(fork()函数)，否则可能看起来会比较吃力。</p><p>我们将代码拉下来后，可以发现，其只包含两个文件，我们首先分析代码行数较少的<code>socket.c</code>文件。</p><h3 id="socket.c源码剖析">socket.c源码剖析</h3><h4 id="文件说明">文件说明</h4><p>这个<code>socket.c</code>文件里仅有一个函数<code>int Socket(const char *host, int clientPort)</code>，这是对socket的一层封装，可以解析以字符串传入的<code>url地址</code>和<code>端口</code>，并返回一个指向服务器的socket套接字用于连接。</p><h4 id="函数工作流程">函数工作流程</h4><div class="note note-primary">            <ol type="1"><li><p>首先准备好必须的参数并对其进行初始化。</p></li><li><p>先将主机名转换成ip并存储（包括本身就是ip的主机和通过dns解析主机两部分）</p></li><li><p>根据主机IP和端口创建socket套接字</p></li><li><p>执行一次连接，如果连接成功就返回这个套接字，否则返回错误码</p></li></ol>          </div><h4 id="源码">源码</h4><p>这部分源码相对比较简单，主要懂一些linux下网络编程就不难看懂了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-comment">// host是目标主机名，clientPort为端口</span><br><span class="hljs-comment">// 建立与目标的TCP连接，返回客户端连接使用的套接字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Socket</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">int</span> clientPort)</span><br>{<br><br>    <span class="hljs-type">int</span> sock;              <span class="hljs-comment">// 本地套接字标识符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> inaddr;  <span class="hljs-comment">// 主机ip的数字形式（32位）</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ad</span>;</span> <span class="hljs-comment">// 处理网络通信套接字地址结构，存储地址族、套接字端口号、ip地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">hp</span>;</span>    <span class="hljs-comment">// 存储了主机名、主机别名、ip及其类型、长度等，是gethostbyname返回值</span><br><br>    <span class="hljs-built_in">memset</span>(&amp;ad, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ad)); <span class="hljs-comment">// 初始化套接字</span><br>    ad.sin_family = AF_INET;    <span class="hljs-comment">// TCP/IP协议</span><br><br>    inaddr = inet_addr(host); <span class="hljs-comment">// 先尝试将host转换成整型（不经过dns解析的ip形式主机）</span><br>    <span class="hljs-keyword">if</span> (inaddr != INADDR_NONE)<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="hljs-keyword">sizeof</span>(inaddr)); <span class="hljs-comment">// 成功则保存转换结果</span><br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 否则需要先经过dns解析</span><br>        hp = gethostbyname(host); <span class="hljs-comment">// hp是存储解析结果的结构体</span><br>        <span class="hljs-keyword">if</span> (hp == <span class="hljs-literal">NULL</span>)           <span class="hljs-comment">// 解析失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length); <span class="hljs-comment">// 解析成功同样需要保存整型结构的IP地址</span><br>    }<br>    ad.sin_port = htons(clientPort); <span class="hljs-comment">// htons是将整型变量从主机字节顺序转变成网络字节顺序</span><br><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// 创建套接字</span><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> sock; <span class="hljs-comment">// 创建失败</span><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ad, <span class="hljs-keyword">sizeof</span>(ad)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 创建成功但是不能连接成功也认为是失败</span><br>    <span class="hljs-keyword">return</span> sock;<br>}<br><br></code></pre></td></tr></table></figure><h3 id="webbench.c源码剖析">webbench.c源码剖析</h3><h4 id="文件说明-1">文件说明</h4><p>这个<code>webbench.c</code>文件是这个项目中最重要的文件，所有的处理操作都在这个文件中执行。</p><p>在这个文件头处可以看到可能令人疑惑的地方，在一行有一句<code>#include "socket.c"</code>，也就是把另一个.c文件给include进来了，但一般我们include都是.h文件。</p><p>其实在c语言中<code>#</code>开头的指令是预处理指令，我们知道，c语言进行编译的第一步就是预处理，而<code>include</code>指令就是把include后紧跟的文件原封不动的插入进来，而不做改变。而平时我们不这么做的原因就是当多个文件都include一个.c文件时，这个.c文件内的函数会被重定义。但这个项目就两个文件，所以不用考虑那么多。</p><div class="note note-info">            <p><strong><em>关于预处理</em></strong></p><p>在linux环境下执行<code>gcc -E webbench.c &gt; result.txt</code>就能看到预处理结果，当然为了便于观察，可以把除了<code>#include "socket.c"</code>的所有其他头文件都注释掉。</p>          </div><h4 id="源码-1">源码</h4><p>由于这个文件比较大，所以分函数来进行展示</p><p>先来看头文件部分和全局变量部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"socket.c"</span></span><br><span class="hljs-comment">// 这里include了一个.c文件可能会令人费解，但是理解C语言的编译过程就容易看懂了</span><br><span class="hljs-comment">// #include是一个预处理指令，在预处理过程中会用"socket.c"的内容来替换这个预处理</span><br><span class="hljs-comment">// 所以相当于完成了两个.c文件的拼接，等效于将"socket.c"直接写在这个文件前面</span><br><span class="hljs-comment">// 平时之所以不这样用是因为可能出现重定义的现象</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/param.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;getopt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> timerexpired = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计时器是否到期，到期为1，未到期为0</span><br><span class="hljs-type">int</span> speed = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 记录速度</span><br><span class="hljs-type">int</span> failed = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 记录失败次数</span><br><span class="hljs-type">int</span> bytes = <span class="hljs-number">0</span>;                 <span class="hljs-comment">//记录传输的数据量</span><br><br><span class="hljs-type">int</span> http10 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0 - http/0.9, 1 - http/1.0, 2 - http/1.1</span><br><br><span class="hljs-comment">// 定义了http的方法和全局配置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_GET 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_HEAD 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_OPTIONS 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> METHOD_TRACE 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROGRAM_VERSION <span class="hljs-string">"1.5"</span></span><br><span class="hljs-type">int</span> method = METHOD_GET; <span class="hljs-comment">// 默认请求方法</span><br><span class="hljs-type">int</span> clients = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 客户端连接数目</span><br><span class="hljs-type">int</span> force = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 是否不等待服务器响应，发送请求后直接关闭连接</span><br><span class="hljs-type">int</span> force_reload = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 是否强制代理服务器重新发送请求</span><br><span class="hljs-type">int</span> proxyport = <span class="hljs-number">80</span>;      <span class="hljs-comment">// 代理端口</span><br><span class="hljs-type">char</span> *proxyhost = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 代理地址</span><br><span class="hljs-type">int</span> benchtime = <span class="hljs-number">30</span>;      <span class="hljs-comment">// 持续时间</span><br><br><span class="hljs-comment">// 网络相关的变量</span><br><span class="hljs-type">int</span> mypipe[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 读写管道，0为读取端，1为写入端</span><br><span class="hljs-type">char</span> host[MAXHOSTNAMELEN];  <span class="hljs-comment">// 保存主机的字符串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REQUEST_SIZE 2048   <span class="hljs-comment">// 请求的最大长度</span></span><br><span class="hljs-type">char</span> request[REQUEST_SIZE]; <span class="hljs-comment">// 请求内容</span><br><br><span class="hljs-comment">// 静态数组，用于记录各个选项的需要求参数</span><br><span class="hljs-comment">// no_argument表示选项没有参数，required_argument表示选项需要参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">long_options</span>[] =</span><br>    {<br>        {<span class="hljs-string">"force"</span>, no_argument, &amp;force, <span class="hljs-number">1</span>},<br>        {<span class="hljs-string">"reload"</span>, no_argument, &amp;force_reload, <span class="hljs-number">1</span>},<br>        {<span class="hljs-string">"time"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'t'</span>},<br>        {<span class="hljs-string">"help"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'?'</span>},<br>        {<span class="hljs-string">"http09"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'9'</span>},<br>        {<span class="hljs-string">"http10"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'1'</span>},<br>        {<span class="hljs-string">"http11"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'2'</span>},<br>        {<span class="hljs-string">"get"</span>, no_argument, &amp;method, METHOD_GET},<br>        {<span class="hljs-string">"head"</span>, no_argument, &amp;method, METHOD_HEAD},<br>        {<span class="hljs-string">"options"</span>, no_argument, &amp;method, METHOD_OPTIONS},<br>        {<span class="hljs-string">"trace"</span>, no_argument, &amp;method, METHOD_TRACE},<br>        {<span class="hljs-string">"version"</span>, no_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'V'</span>},<br>        {<span class="hljs-string">"proxy"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'p'</span>},<br>        {<span class="hljs-string">"clients"</span>, required_argument, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'c'</span>},<br>        {<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>}};<br><br><span class="hljs-comment">/* prototypes */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *request)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                     <span class="hljs-comment">// 执行压力测试的入口函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span>; <span class="hljs-comment">// 构造请求</span><br><br></code></pre></td></tr></table></figure><p>前面这里就是定义了一些用到的宏和全局变量。</p><p>接下来我们来分析三个辅助函数，一个是用于设置定时器过期，一个用于显示帮助信息，另一个用于构造请求头。</p><p>其中，构造请求头的函数看起来稍微有些复杂，但是其实就是一些逻辑处理，然后根据http协议的定义手动构造出了请求体并保存在全局变量里面，这并不是我们分析的重点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 静态函数，用于信号处理，用于设置定时器过期</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">alarm_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span><br>{<br>    timerexpired = <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">// 返回帮助信息的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-comment">// printf == fprintf(stdout, ...)</span><br>    <span class="hljs-comment">// 不过fprintf的功能更强大，支持重定向</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>            <span class="hljs-string">"webbench [option]... URL\n"</span><br>            <span class="hljs-string">"  -f|--force               Don't wait for reply from server.\n"</span><br>            <span class="hljs-string">"  -r|--reload              Send reload request - Pragma: no-cache.\n"</span><br>            <span class="hljs-string">"  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n"</span><br>            <span class="hljs-string">"  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n"</span><br>            <span class="hljs-string">"  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n"</span><br>            <span class="hljs-string">"  -9|--http09              Use HTTP/0.9 style requests.\n"</span><br>            <span class="hljs-string">"  -1|--http10              Use HTTP/1.0 protocol.\n"</span><br>            <span class="hljs-string">"  -2|--http11              Use HTTP/1.1 protocol.\n"</span><br>            <span class="hljs-string">"  --get                    Use GET request method.\n"</span><br>            <span class="hljs-string">"  --head                   Use HEAD request method.\n"</span><br>            <span class="hljs-string">"  --options                Use OPTIONS request method.\n"</span><br>            <span class="hljs-string">"  --trace                  Use TRACE request method.\n"</span><br>            <span class="hljs-string">"  -?|-h|--help             This information.\n"</span><br>            <span class="hljs-string">"  -V|--version             Display program version.\n"</span>);<br>}<br><br><span class="hljs-comment">// 构造请求头的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span><br>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    build_request的执行过程</span><br><span class="hljs-comment">    就是根据请求方式、http协议版本等等信息来构造处http的报文</span><br><span class="hljs-comment">    且这个报文是全局变量</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-type">char</span> tmp[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 先把保存主机的请求体部分的地址区域清空</span><br>    <span class="hljs-built_in">memset</span>(host, <span class="hljs-number">0</span>, MAXHOSTNAMELEN);<br>    <span class="hljs-built_in">memset</span>(request, <span class="hljs-number">0</span>, REQUEST_SIZE);<br><br>    <span class="hljs-comment">// 然后根据选项来判断请求的http协议版本</span><br>    <span class="hljs-keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="hljs-literal">NULL</span> &amp;&amp; http10 &lt; <span class="hljs-number">1</span>)<br>        http10 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_HEAD &amp;&amp; http10 &lt; <span class="hljs-number">1</span>)<br>        http10 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_OPTIONS &amp;&amp; http10 &lt; <span class="hljs-number">2</span>)<br>        http10 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (method == METHOD_TRACE &amp;&amp; http10 &lt; <span class="hljs-number">2</span>)<br>        http10 = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 然后开始正式构造请求体</span><br>    <span class="hljs-comment">// 不过u1s1，这部分自己手动构造真是痛苦</span><br>    <span class="hljs-keyword">switch</span> (method)<br>    {<br>    <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">case</span> METHOD_GET: <span class="hljs-comment">// get请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"GET"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_HEAD: <span class="hljs-comment">// head请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"HEAD"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_OPTIONS: <span class="hljs-comment">// options请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"OPTIONS"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_TRACE: <span class="hljs-comment">// trace请求</span><br>        <span class="hljs-built_in">strcpy</span>(request, <span class="hljs-string">"TRACE"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" "</span>);<br><br>    <span class="hljs-comment">// 处理url地址，做一些错误检测，而且不支持https</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == <span class="hljs-built_in">strstr</span>(url, <span class="hljs-string">"://"</span>))<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\n%s: is not a valid URL.\n"</span>, url);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(url) &gt; <span class="hljs-number">1500</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"URL is too long.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != strncasecmp(<span class="hljs-string">"http://"</span>, url, <span class="hljs-number">7</span>))<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nOnly HTTP protocol is directly supported, set --proxy for others.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br><br>    <span class="hljs-comment">// 计算出url去掉协议头的部分</span><br>    i = <span class="hljs-built_in">strstr</span>(url, <span class="hljs-string">"://"</span>) - url + <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 要求结尾以/来结尾，不知道为啥</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">'/'</span>) == <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nInvalid URL syntax - hostname don't ends with '/'.\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    }<br><br>    <span class="hljs-comment">// 处理使用代理的情况</span><br>    <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-comment">// 这种硬编码的东西看起来有点痛苦，就不考虑细节了</span><br>        <span class="hljs-keyword">if</span> (index(url + i, <span class="hljs-string">':'</span>) != <span class="hljs-literal">NULL</span> &amp;&amp; index(url + i, <span class="hljs-string">':'</span>) &lt; index(url + i, <span class="hljs-string">'/'</span>))<br>        {<br>            <span class="hljs-built_in">strncpy</span>(host, url + i, <span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">':'</span>) - url - i);<br>            <span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>            <span class="hljs-built_in">strncpy</span>(tmp, index(url + i, <span class="hljs-string">':'</span>) + <span class="hljs-number">1</span>, <span class="hljs-built_in">strchr</span>(url + i, <span class="hljs-string">'/'</span>) - index(url + i, <span class="hljs-string">':'</span>) - <span class="hljs-number">1</span>);<br>            proxyport = atoi(tmp);<br>            <span class="hljs-keyword">if</span> (proxyport == <span class="hljs-number">0</span>)<br>                proxyport = <span class="hljs-number">80</span>;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            <span class="hljs-built_in">strncpy</span>(host, url + i, <span class="hljs-built_in">strcspn</span>(url + i, <span class="hljs-string">"/"</span>));<br>        }<br>        <span class="hljs-built_in">strcat</span>(request + <span class="hljs-built_in">strlen</span>(request), url + i + <span class="hljs-built_in">strcspn</span>(url + i, <span class="hljs-string">"/"</span>));<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-built_in">strcat</span>(request, url);<br>    }<br><br>    <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" HTTP/1.0"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">" HTTP/1.1"</span>);<br><br>    <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"User-Agent: WebBench "</span> PROGRAM_VERSION <span class="hljs-string">"\r\n"</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span> &amp;&amp; http10 &gt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Host: "</span>);<br>        <span class="hljs-built_in">strcat</span>(request, host);<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br>    }<br><br>    <span class="hljs-keyword">if</span> (force_reload &amp;&amp; proxyhost != <span class="hljs-literal">NULL</span>)<br>    {<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Pragma: no-cache\r\n"</span>);<br>    }<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"Connection: close\r\n"</span>);<br><br>    <span class="hljs-keyword">if</span> (http10 &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">strcat</span>(request, <span class="hljs-string">"\r\n"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nRequest:\n%s\n"</span>, request);<br>}<br><br></code></pre></td></tr></table></figure><p>然后我们来进入main函数，main函数主要是解析选项，并构造url的请求头，然后调用bench函数来正式开始压力测试，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    main函数的处理过程就是先解析出所有的选项</span><br><span class="hljs-comment">    然后构造指向目标地址的url请求</span><br><span class="hljs-comment">    最后调用bench函数来执行压力测试</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 用于记录当前标志（其实是char）</span><br>    <span class="hljs-type">int</span> options_index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于标记当前选项处理到的索引未知</span><br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-comment">// 若如果不带任何参数执行此程序就直接退出</span><br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><br>    <span class="hljs-comment">// 否则循环解析命令</span><br>    <span class="hljs-comment">// getopt_long是解析命令的函数，此处不展开细🔒</span><br>    <span class="hljs-comment">// 就是通过这个步骤来解析所有的选项</span><br>    <span class="hljs-keyword">while</span> ((opt = getopt_long(argc, argv, <span class="hljs-string">"912Vfrt:p:c:?h"</span>, long_options, &amp;options_index)) != EOF)<br>    {<br>        <span class="hljs-keyword">switch</span> (opt)<br>        {<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:<br>            force = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'r'</span>:<br>            force_reload = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'9'</span>:<br>            http10 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:<br>            http10 = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'2'</span>:<br>            http10 = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'V'</span>:<br>            <span class="hljs-built_in">printf</span>(PROGRAM_VERSION <span class="hljs-string">"\n"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'t'</span>:<br>            benchtime = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'p'</span>:<br>            <span class="hljs-comment">/* proxy server parsing server:port */</span><br>            <span class="hljs-comment">// 由于代理是server:port的格式</span><br>            <span class="hljs-comment">// 所以先查找处:的位置</span><br>            <span class="hljs-comment">// strrchr就是查找并返回指向:字符的指针</span><br>            tmp = <span class="hljs-built_in">strrchr</span>(optarg, <span class="hljs-string">':'</span>);<br>            proxyhost = optarg;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)<br>            {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (tmp == optarg)<br>            {<br>                <span class="hljs-comment">// 没有主机，即字符串是:....的形式</span><br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in option --proxy %s: Missing hostname.\n"</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (tmp == optarg + <span class="hljs-built_in">strlen</span>(optarg) - <span class="hljs-number">1</span>)<br>            {<br>                <span class="hljs-comment">// 没有端口，即字符串是...:的形式</span><br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in option --proxy %s Port number is missing.\n"</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            }<br>            <span class="hljs-comment">// 由于tmp指向了冒号，所以把冒号置'\0'就完成了分割操作</span><br>            *tmp = <span class="hljs-string">'\0'</span>;<br>            <span class="hljs-comment">// 然后获取端口号</span><br>            proxyport = atoi(tmp + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">':'</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'h'</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:<br>            usage();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">'c'</span>:<br>            <span class="hljs-comment">// atoi是把字符串转换成整型</span><br>            clients = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (optind == argc)<br>    {<br>        <span class="hljs-comment">// 最后一个被opt处理的选项与全部选项等长，就说明没有网址</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"webbench: Missing URL!\n"</span>);<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><br>    <span class="hljs-comment">// 修改默认的客户端数目与时间</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">0</span>)<br>        clients = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (benchtime == <span class="hljs-number">0</span>)<br>        benchtime = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">/* Copyright */</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Webbench - Simple Web Benchmark "</span> PROGRAM_VERSION <span class="hljs-string">"\n"</span><br>                    <span class="hljs-string">"Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n"</span>);<br><br>    <span class="hljs-comment">// 构造请求，存储在全局变量char request[REQUEST_SIZE]</span><br>    <span class="hljs-comment">// optind指向下一个未处理的字符串的索引</span><br>    <span class="hljs-comment">// 因此./webbench -c 5 -t 1 http://www.baidu.com/ wrong会被正常处理</span><br>    <span class="hljs-comment">// 而./webbench -c 5 -t 1 wrong http://www.baidu.com/ 不会被正常处理</span><br>    build_request(argv[optind]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Runing info: "</span>);<br><br>    <span class="hljs-comment">// 打印连接日志，为毛要写成这个样子？？</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 client"</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d clients"</span>, clients);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">", running %d sec"</span>, benchtime);<br><br>    <span class="hljs-keyword">if</span> (force)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", early socket close"</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", via proxy server %s:%d"</span>, proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (force_reload)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">", forcing reload"</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">".\n"</span>);<br><br>    <span class="hljs-comment">//调用bench函数，开始压力测试，bench() 为压力测试核心代码</span><br>    <span class="hljs-keyword">return</span> bench();<br>}<br><br></code></pre></td></tr></table></figure><p>然后我们分析用于作为测试入口的bench函数。</p><p>这个函数内是使用fork创建出子进程，同时分配管道用于主进程与子进程之间通信，最后还设定了主进程的逻辑为从管道中不断读取子进程的数据并汇总。</p><p>这里我们可以学到一点：<strong>所有需要处理的东西全部由子进程去做，主进程只负责汇总或打印报告之类的，这样处理的时候子进程崩了也不影响主进程</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 正式开始压力测试的入口函数，主要用于创建子进程、管道，以及主进程从管道中读取数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-number">0</span>;<br>    FILE *f;<br><br>    <span class="hljs-comment">// 构造一个socket套接字</span><br>    i = Socket(proxyhost == <span class="hljs-literal">NULL</span> ? host : proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"\nConnect to server failed. Aborting benchmark.\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br><br>    <span class="hljs-comment">// 关闭连接，这次连接不计入测试</span><br>    close(i);<br><br>    <span class="hljs-comment">// 创建管道，mypipe也是全局变量</span><br>    <span class="hljs-comment">// 管道用于两个进程之间数据交换</span><br>    <span class="hljs-keyword">if</span> (pipe(mypipe))<br>    {<br>        perror(<span class="hljs-string">"pipe failed."</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    }<br><br>    <span class="hljs-comment">// fork出子进程</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clients; i++)<br>    {<br>        pid = fork();<br><br>        <span class="hljs-keyword">if</span> (pid &lt;= (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 如果是子进程或者创建失败，休眠1s后退出循环，</span><br>            <span class="hljs-comment">// 让父进程先执行，完成初始化（因为创建子进程是很快的）</span><br>            <span class="hljs-comment">// 并且保证子进程中不会再fork出新的子进程</span><br>            <span class="hljs-comment">// 子进程不fork出新的子进程，所以总的子进程数目就很好控制了</span><br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    <span class="hljs-comment">//主进程创建进程失败就退出</span><br>    <span class="hljs-keyword">if</span> (pid &lt; (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"problems forking worker no. %d\n"</span>, i);<br>        perror(<span class="hljs-string">"fork failed."</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (pid == (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-comment">// 子进程调用benchcore去尽可能发送请求</span><br>        <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>            benchcore(host, proxyport, request);<br>        <span class="hljs-keyword">else</span><br>            benchcore(proxyhost, proxyport, request);<br><br>        <span class="hljs-comment">// 同时写入管道</span><br>        f = fdopen(mypipe[<span class="hljs-number">1</span>], <span class="hljs-string">"w"</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        {<br>            perror(<span class="hljs-string">"open pipe for writing failed."</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        }<br><br>        <span class="hljs-comment">// 写入数据，来源于全局变量</span><br>        <span class="hljs-built_in">fprintf</span>(f, <span class="hljs-string">"%d %d %d\n"</span>, speed, failed, bytes);<br>        fclose(f);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 主进程读取管道</span><br>        f = fdopen(mypipe[<span class="hljs-number">0</span>], <span class="hljs-string">"r"</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        {<br>            perror(<span class="hljs-string">"open pipe for reading failed."</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        }<br><br>        <span class="hljs-comment">// 定义流 stream 应如何缓冲</span><br>        <span class="hljs-comment">// 设置不使用缓冲。每个I/O操作都被即时写入管道</span><br>        setvbuf(f, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 初始化主进程的变量</span><br>        speed = <span class="hljs-number">0</span>;<br>        failed = <span class="hljs-number">0</span>;<br>        bytes = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        {<br>            <span class="hljs-comment">// 获取成功读取的参数个数</span><br>            pid = <span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d %d %d"</span>, &amp;i, &amp;j, &amp;k);<br>            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">2</span>)<br>            {<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Some of our childrens died.\n"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            }<br><br>            speed += i;<br>            failed += j;<br>            bytes += k;<br><br>            <span class="hljs-comment">// 客户端数减一后如果等于0，说明没有多的客户端数据读取，直接退出循环</span><br>            <span class="hljs-keyword">if</span> (--clients == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        }<br><br>        fclose(f);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n"</span>,<br>               (<span class="hljs-type">int</span>)((speed + failed) / (benchtime / <span class="hljs-number">60.0f</span>)),<br>               (<span class="hljs-type">int</span>)(bytes / (<span class="hljs-type">float</span>)benchtime),<br>               speed,<br>               failed);<br>    }<br><br>    <span class="hljs-keyword">return</span> i;<br>}<br><br></code></pre></td></tr></table></figure><p>最后是子进程发起请求的函数benchcore函数，这个函数其实逻辑也很简单，就是构造请求并发起，然后看看有没有错误，不过错误种类还挺多。</p><p>另外，这个函数还使用了信号量来作为定时器，这部分可以参考，即：<strong>在不影响程序执行的前提下进行定时</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 子进程发送请求的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *req)</span><br>{<br>    <span class="hljs-type">int</span> rlen;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br>    <span class="hljs-type">int</span> s, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br><br>    <span class="hljs-comment">// 当程序执行到指定的秒数之后，发送SIGALRM信号，</span><br>    <span class="hljs-comment">// 即设置alam_handler函数为信号处理函数</span><br>    sa.sa_handler = alarm_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br><br>    alarm(benchtime); <span class="hljs-comment">// after benchtime,then exit</span><br><br>    rlen = <span class="hljs-built_in">strlen</span>(req);<br>nexttry:<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">if</span> (timerexpired)<br>        {<br>            <span class="hljs-comment">// 定时器过期</span><br>            <span class="hljs-comment">// 减去由于定时器过期引起的失败</span><br>            <span class="hljs-keyword">if</span> (failed &gt; <span class="hljs-number">0</span>)<br>            {<br>                failed--;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        s = Socket(host, port);<br>        <span class="hljs-comment">// 构造并发起请求失败</span><br>        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>        {<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        <span class="hljs-comment">// 如果请求报文写入套接字失败</span><br>        <span class="hljs-keyword">if</span> (rlen != write(s, req, rlen))<br>        {<br>            failed++;<br>            close(s);<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        <span class="hljs-comment">// 如果使用HTTP/0.9协议，因为会在服务器回复后自动断开连接，所以可以先关闭写端</span><br>        <span class="hljs-comment">// 如果写端已经被关闭了，则说明异常连接</span><br>        <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (shutdown(s, <span class="hljs-number">1</span>))<br>            {<br>                failed++;<br>                close(s);<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>        <span class="hljs-keyword">if</span> (force == <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 读取服务器的数据</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            {<br>                <span class="hljs-keyword">if</span> (timerexpired)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 将数据读取进buf中</span><br>                i = read(s, buf, <span class="hljs-number">1500</span>);<br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                {<br>                    failed++;<br>                    close(s);<br>                    <span class="hljs-keyword">goto</span> nexttry;<br>                }<br>                <span class="hljs-comment">// 文件尾</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 如果读取到了数据，将总共传送的字节数加上读取到的数据的字节数</span><br>                <span class="hljs-keyword">else</span><br>                    bytes += i;<br>            }<br>        }<br>        <span class="hljs-comment">// 关闭连接，如果失败，测试失败数加一，继续循环</span><br>        <span class="hljs-keyword">if</span> (close(s))<br>        {<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        speed++;<br>    }<br>}<br><br><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><div class="note note-primary">            <p><strong>流程解析</strong></p><p><img src="/2022/09/01/Webbench%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/pic1.png" class="" title="_"></p>          </div><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>getopt_long() :其函数族成员有getopt、getopt_long、getopt_long_only，可以用来解析命令行参数，很实用。位于getopt.h，可以参阅<a href="https://blog.csdn.net/qq_33850438/article/details/80172275/"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>pipe() :管道是两个进程之间的连接，一个进程的标准输出成为另一个进程的标准输入。在UNIX操作系统中，管道用于进程间通信。可以参阅<a href="https://blog.51cto.com/u_15064646/3853841"><font color="#0000ff"><strong>这篇文章</strong></font></a>来使用。</p></li><li><p>fork() :用于创建出子进程，调用一次返回两次，子进程拥有父进程所有的打开的文件与变量。<strong>另外，在循环中使用fork会导致子进程继续fork，非常麻烦，为了计数方便可以让子进程在循环中break掉。</strong></p></li><li><p>fprintf() : printf() ==fprintf(stdout,...)这个函数功能更强大，支持重定向。</p></li><li><p>alarm() :alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号，可以设置对应的信号处理函数去处理这个信号。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>小型C语言项目源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>小型C语言项目源码剖析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(4)--迭代器</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器----来源于cookbook第四章">迭代器----来源于cookbook第四章</h2><span id="more"></span><p><font color="#add0a0">记录第四章中比较有意思的部分</font></p><hr><h3 id="实现容器的委托迭代">实现容器的委托迭代</h3><div class="note note-primary">            <p>只需要为容器实现<code>__iter__</code>魔法方法即可。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,value</span>):<br>        self._value = value<br>        self._children = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Node({!r})"</span>.<span class="hljs-built_in">format</span>(self._value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self,value</span>):<br>        self._children.append(value)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self._children)<br><br>a = Node(<span class="hljs-string">"list"</span>)<br>a.append(<span class="hljs-number">1</span>)<br>a.append(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">""</span>) <span class="hljs-comment">## 12</span><br><br></code></pre></td></tr></table></figure><h3 id="简单的方法实现迭代协议">简单的方法实现迭代协议</h3><div class="note note-primary">            <p>使用<code>yield from</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    <span class="hljs-comment"># 注意，此处yield出去的仍然是一个迭代器，</span><br>    <span class="hljs-keyword">yield</span> (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span>)<br><br>a = gen()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># &lt;generator object gen.&lt;locals&gt;.&lt;genexpr&gt; at 0x000001C6FC019D60&gt;</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_good</span>():<br>    x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    <span class="hljs-comment"># 此时yield出去的是我们需要的整数</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">3</span>)<br><br>a = gen()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 4 5</span><br><br></code></pre></td></tr></table></figure><h3 id="反向迭代">反向迭代</h3><div class="note note-primary">            <p>只需要实现<code>__reversed__()</code>方法即可，实现反向迭代后的效率更高</p>          </div><h3 id="迭代器切片">迭代器切片</h3><div class="note note-primary">            <p>使用<code>itertools</code>的<code>islice()</code>方法即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> islice<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        <span class="hljs-keyword">yield</span> i<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> islice(gen(),<span class="hljs-number">10</span>,<span class="hljs-number">20</span>):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 10....19</span><br><br><span class="hljs-comment"># 但是注意，islice会消耗掉迭代器，所以没法倒回去访问数据</span><br><br></code></pre></td></tr></table></figure><h3 id="以索引-值的形式迭代序列">以索引-值的形式迭代序列</h3><div class="note note-primary">            <p>使用<code>enumerate()</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]<br><br><span class="hljs-keyword">for</span> index, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>    <span class="hljs-built_in">print</span>(index,word) <span class="hljs-comment"># 0 a  1 b  2 c</span><br><br></code></pre></td></tr></table></figure><h3 id="同时迭代多个序列">同时迭代多个序列</h3><div class="note note-primary">            <p>使用<code>zip()</code>函数即可，其返回一个迭代器，长度是参数中较短的一个</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(a,b):<br>    <span class="hljs-built_in">print</span>(x,y) <span class="hljs-comment"># 1 4  2 5  3 6</span><br><br></code></pre></td></tr></table></figure><h3 id="在多个容器中进行迭代">在多个容器中进行迭代</h3><div class="note note-primary">            <p>使用<code>itertools</code>的<code>chain()</code>函数即可，可以逐个迭代多个容器</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain<br><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chain(a,b):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1 2 3 4 5 6 7</span><br><br><br></code></pre></td></tr></table></figure><h3 id="使用迭代器取代while循环">使用迭代器取代while循环</h3><div class="note note-primary">            <p><code>iter(func,sentinal)</code>可以一直调用无参函数func直到其返回哨兵值sentinal为止</p><p>这样就可以将while循环转换成迭代器模式</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>times = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-keyword">global</span> times<br>    <span class="hljs-keyword">if</span> times==<span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    times +=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(gen,-<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(3)--处理数字、时间和日期</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/</url>
    
    <content type="html"><![CDATA[<h2 id="处理数字时间和日期----来源于cookbook第三章">处理数字、时间和日期----来源于cookbook第三章</h2><span id="more"></span><p><font color="#a0a0dd">记录第三章中比较有意思的部分</font></p><hr><h3 id="精确的小数计算">精确的小数计算</h3><div class="note note-primary">            <p>使用<code>decimal</code>中的<code>Decimal</code>类就可以实现精确小数计算，而避免引入浮点数误差。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br><span class="hljs-comment"># 传统浮点数会引入误差</span><br>a = <span class="hljs-number">4.2</span><br>b = <span class="hljs-number">2.1</span><br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 6.300000000000001</span><br><span class="hljs-built_in">print</span>(a + b == <span class="hljs-number">6.3</span>) <span class="hljs-comment"># False</span><br><br><span class="hljs-comment"># 使用Decimal</span><br>a = Decimal(<span class="hljs-string">'4.2'</span>)<br>b = Decimal(<span class="hljs-string">'2.1'</span>)<br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 6.3</span><br><span class="hljs-built_in">print</span>(a + b == Decimal(<span class="hljs-string">'6.3'</span>)) <span class="hljs-comment"># True</span><br><br></code></pre></td></tr></table></figure><h3 id="精确的分数计算">精确的分数计算</h3><div class="note note-primary">            <p>使用<code>fractions</code>中的<code>Fraction</code>可以精确的计算分数</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> Fraction<br><br>a = Fraction(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br>b = Fraction(<span class="hljs-number">7</span>,<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment"># 27/16</span><br><br></code></pre></td></tr></table></figure><h3 id="numpy的matrix与array在处理矩阵上的微妙区别">numpy的matrix与array在处理矩阵上的微妙区别</h3><div class="note note-primary">            <p><code>matrix</code>是矩阵，而<code>array</code>主要是数组，两者在运算上存在一些区别</p><ul><li><p>首先array的<code>*</code>，<code>**</code>都是点乘，其矩阵乘法需要使用<code>np.dot()</code></p></li><li><p>而matrix的<code>*</code>，<code>**</code>都是矩阵乘法，其点乘需要用到<code>np.multiply()</code></p></li><li><p>matrix求逆可以直接<code>.I</code>，而array求逆需要使用<code>np.linalg.inv()</code></p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(2)--字符串与文本</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串与文本----来源于cookbook第二章">字符串与文本----来源于cookbook第二章</h2><span id="more"></span><p><font color="#a0dda0">记录第二章中比较有意思的部分</font></p><hr><div class="note note-info">            <p>其实这一章讲的方法挺多挺杂的，但是日常使用基本就正则和python自带的字符串方法，其他的感觉用不到的样子。</p><p>正则的话平时写多了自然就会了，这里就不记录了</p>          </div><h3 id="字符串开头结尾文本匹配">字符串开头结尾文本匹配</h3><div class="note note-primary">            <p>使用<code>str.startswith()</code>和<code>str.endwith()</code>即可。在写文件批处理脚本的时候用得到。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>files = [<span class="hljs-string">'a.h'</span>,<span class="hljs-string">'a.c'</span>,<span class="hljs-string">'a.exe'</span>]<br>selected = [file <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files <span class="hljs-keyword">if</span> file.endswith((<span class="hljs-string">".h"</span>,<span class="hljs-string">".c"</span>))]<br><span class="hljs-built_in">print</span>(selected) <span class="hljs-comment"># ['a.h', 'a.c']</span><br><br></code></pre></td></tr></table></figure><h3 id="字符串去除首尾不需要的字符">字符串去除首尾不需要的字符</h3><div class="note note-primary">            <p>使用<code>str.lstrip()</code>和<code>str.rstrip()</code>即可</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>s = <span class="hljs-string">'-=-=hellp-=-world-=-=-='</span><br>s = s.lstrip(<span class="hljs-string">"-="</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment"># 'hellp-=-world-=-=-='</span><br>s = s.rstrip(<span class="hljs-string">"-="</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment"># 'hellp-=-world'</span><br><br></code></pre></td></tr></table></figure><h3 id="字符串拼接">字符串拼接</h3><div class="note note-primary">            <p><code>+</code>：效率最低，但是简单</p><p><code>join</code>：效率高，支持列表等</p><p><code>print(*args,sep=",")</code>：容易被遗忘的一种方法</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>c = <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">','</span>.join(<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [a,b,c])) <span class="hljs-comment"># 1,2,3</span><br><span class="hljs-built_in">print</span>(a,b,c,sep=<span class="hljs-string">","</span>) <span class="hljs-comment"># 1,2,3</span><br><br></code></pre></td></tr></table></figure><h3 id="给字符串中变量名做插值">给字符串中变量名做插值</h3><div class="note note-primary">            <p>作者在书中提到python没法直接处理字符串插值，并实现了一些复杂的方法，<br>幸运的是，新版本的python已经直接支持插值了，不需手动去实现了</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>name = <span class="hljs-string">'book'</span><br>price = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>' price is <span class="hljs-subst">{price}</span>"</span>) <span class="hljs-comment"># book' price is 10</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python奇技淫巧(1)--基本数据结构与算法</title>
    <link href="/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/"/>
    <url>/2022/08/30/Python%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/</url>
    
    <content type="html"><![CDATA[<h2 id="基本数据结构与算法----来源于cookbook第一章">基本数据结构与算法----来源于cookbook第一章</h2><span id="more"></span><p><font color="#dda0a0">记录第一章中比较有意思的部分</font></p><hr><h3 id="元素分解">元素分解</h3><div class="note note-primary">            <p>通过<code>*表达式</code>来解包裹实现分解</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)]<br><br>first, *_, (*__, last) = l<br><br><span class="hljs-built_in">print</span>(first,last) <span class="hljs-comment"># 1 7</span><br><br></code></pre></td></tr></table></figure><h3 id="将字典的键映射到多个值上">将字典的键映射到多个值上</h3><div class="note note-primary">            <ul><li><p>通过使用<code>collections</code>中的<code>defaultdict</code>来实现一键多值字典</p></li><li><p>通过<code>dict</code>类的<code>setdefault</code>方法来实现</p></li></ul>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一</span><br><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br>d = defaultdict(<span class="hljs-built_in">list</span>) <span class="hljs-comment"># 或defaultdict(set)</span><br>d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">1</span>)<br>d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">2</span>)<br>d[<span class="hljs-string">'b'</span>].append(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(d) <span class="hljs-comment"># {'a': [1, 2], 'b': [3]}</span><br><br><br><span class="hljs-comment"># 方法二</span><br><br>d = {}<br>d.setdefault(<span class="hljs-string">'a'</span>,[]).append(<span class="hljs-number">1</span>)<br>d.setdefault(<span class="hljs-string">'a'</span>,[]).append(<span class="hljs-number">2</span>)<br>d.setdefault(<span class="hljs-string">'b'</span>,[]).append(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(d) <span class="hljs-comment"># {'a': [1, 2], 'b': [3]}</span><br><br></code></pre></td></tr></table></figure><h3 id="两个字典的集合运算">两个字典的集合运算</h3><div class="note note-primary">            <p>字典支持集合运算符，可以对其求交集、并集等</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>a = {<br>    <span class="hljs-string">'x'</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">'y'</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">'z'</span> : <span class="hljs-number">3</span><br>}<br><br>b={<br>    <span class="hljs-string">'x'</span> : <span class="hljs-number">10</span>,<br>    <span class="hljs-string">'w'</span> : <span class="hljs-number">11</span>,<br>    <span class="hljs-string">'z'</span> : <span class="hljs-number">3</span><br>}<br><br><span class="hljs-built_in">print</span>(a.keys() &amp; b.keys()) <span class="hljs-comment"># {'z', 'x'}</span><br><span class="hljs-built_in">print</span>(a.keys() - b.keys()) <span class="hljs-comment"># {'y'}</span><br><span class="hljs-built_in">print</span>(a.items() &amp; b.items()) <span class="hljs-comment"># {('z', 3)}</span><br><br></code></pre></td></tr></table></figure><h3 id="字典推导式">字典推导式</h3><div class="note note-primary">            <p>感觉字典推导式不如生成器推导式和列表推导式用的多</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>prices = {<br>    <span class="hljs-string">'a'</span> : <span class="hljs-number">45</span>,<br>    <span class="hljs-string">'b'</span> : <span class="hljs-number">32</span>,<br>    <span class="hljs-string">'c'</span> : <span class="hljs-number">10</span><br>}<br><br>p1 = {key:value <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> value &gt;<span class="hljs-number">20</span>}<br><span class="hljs-built_in">print</span>(p1) <span class="hljs-comment"># {'a': 45, 'b': 32}</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PythonCookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(4)--levelDB的编码格式</title>
    <link href="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/"/>
    <url>/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的编码格式">levelDB的编码格式</h2><span id="more"></span><hr><h3 id="存储方式">存储方式</h3><p>当数据库获取到内存后，其需要将数据插入到内存中，并在适当的时候读取出来，如何高效地利用申请到的内存就是一个比较重要的问题。</p><div class="note note-info">            <p>在levelDB中，数据是按照下列方法存储的：</p><ul><li><p>整数分为32位和64位定长整数</p></li><li><p>整数还使用变长整数存储</p></li><li><p>整数均为小端法存储</p></li><li><p>字符串采用长度前缀编码</p></li></ul>          </div><h4 id="变长整数与定长整数">变长整数与定长整数</h4><p>所谓定长整数就是我们平时在C语言中定义的数据类型，其长度是始终不变的。</p><p>而变长整数则顾名思义，其编码的原理是只使用一个字节的低7位去存储数据，而最高位的用于做标识：当最高位为1时表示需要继续读取下一个字节。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic1.jpg" class=""><p>如上图所示，这样变长整数就可以使用1-5字节去表示int32的所有整数，表面上看，虽然表示非常大的整数的时候变长整数编码会占用更多的空间，但是由于大整数出现的频率一般是比较小的，所以就普遍而言，使用变长整数会节省更多的内存。</p><h4 id="字符串">字符串</h4><p>字符串使用长度前缀编码，即在把字符串的长度放在字符串的前面，然后组合起来编码。</p><p>而同时，字符串长度使用变长整数进行编码，所以一个字符串的存储格式是<code>32位变长整数编码字符串长度 + 字符串本身</code></p><p>使用长度前缀编码的方式，字符串能够编码任意字符(比如C语言不能在字符串中包含'\0')，同时，字符串的长度可以预先知道，所以有利于读写操作。另外，对于大部分字符串的长度都比较短的时候，并不会造成大量内存损失。</p><h3 id="源码解析部分">源码解析部分</h3><div class="note note-primary">            <p>源码位置： <code>utils/coding.cc</code><code>utils/coding.h</code></p>          </div><h4 id="头文件">头文件</h4><p>首先，我们先来看一下编码解码和插入数据的头文件，这部分内容很简单，就是处理编码格式的一些方法。</p><p>其中要注意用到了一个类<code>Slice</code>，这个类是对字符串的封装，比<code>std::string</code>封装更加低级，所以效率会更高，后面的文章会细🔒它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span>;                 <span class="hljs-comment">// 插入定长32位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span>;                 <span class="hljs-comment">//插入定长64位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span>;                <span class="hljs-comment">//插入变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span>;                <span class="hljs-comment">//插入变长64位整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutLengthPrefixedSlice</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">const</span> Slice &amp;value)</span></span>; <span class="hljs-comment">//插入字符串</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span>;          <span class="hljs-comment">// 获取变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint64</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint64_t</span> *value)</span></span>;          <span class="hljs-comment">// 获取变长64位整数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span>; <span class="hljs-comment">// 获取字符串</span><br><br><span class="hljs-comment">// 用于解码32/64位变长整数的函数，其中p是指向变长整数，limit是变长整数最大长度</span><br><span class="hljs-comment">// 而v存放的是解码后的值，如果不能解码则返回null</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint32_t</span> *v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint64_t</span> *v)</span></span>;<br><br><span class="hljs-comment">// 这是上面GetVarint32Ptr函数的内部回调函数，是实际处理变长整数的东西</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> *value)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VarintLength</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> v)</span></span>; <span class="hljs-comment">// 返回变长整数(32/64)的'长度'</span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span>; <span class="hljs-comment">// 编码变长32位整数</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span>; <span class="hljs-comment">// 编码变长64位整数</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span>; <span class="hljs-comment">// 编码定长32位整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span>; <span class="hljs-comment">// 编码定长64位整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">DecodeFixed32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span>;       <span class="hljs-comment">// 解码32位定长整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">DecodeFixed64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span>;       <span class="hljs-comment">// 解码64位定长整数</span><br><br></code></pre></td></tr></table></figure><p>头文件只是给出了函数接口，下面我们就来进一步去分析各个函数。</p><h4 id="实现文件">实现文件</h4><p>为了方便分析，我们将其分成：编码解码定长整数、编码解码变长整数、Put和Get方法。</p><p>这部分代码全部围绕编码解码来实现的，其中定长的编解码很简单，就不在此赘述了。关于变长整数的编解码，其关于编码和解码的相关函数都预留了类似迭代器一样的超尾元素(指针)，这种形式的接口可以很方便的确定所处理数据的区间(变长整数的Put和Get相关函数都使用到了预留的超尾元素)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-comment">// 内联函数本来是在头文件中的，但是此处将其当成一个函数来进行分析</span><br><br><span class="hljs-comment">/*=============编码解码定长整数=============*/</span><br><br><span class="hljs-comment">// 编码定长32位整数，实现思路就是类似结构体那样去分割uint32即可</span><br><span class="hljs-comment">// 但注意保证让dst有足够的空间去存储，否则会溢出或段错误</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// reinterpret_cast允许指针(引用)之间转换</span><br>    <span class="hljs-comment">// 整型与指针类型间的转换以及指针与足够大的整型之间的转换</span><br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br><br>    buffer[<span class="hljs-number">0</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value);<br>    buffer[<span class="hljs-number">1</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">8</span>);<br>    buffer[<span class="hljs-number">2</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">16</span>);<br>    buffer[<span class="hljs-number">3</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">24</span>);<br>}<br><br><span class="hljs-comment">// 编码定长64位整数，思路与编码定长32位整数一致</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">EncodeFixed64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br><br>    buffer[<span class="hljs-number">0</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value);<br>    buffer[<span class="hljs-number">1</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">8</span>);<br>    buffer[<span class="hljs-number">2</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">16</span>);<br>    buffer[<span class="hljs-number">3</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">24</span>);<br>    buffer[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">32</span>);<br>    buffer[<span class="hljs-number">5</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">40</span>);<br>    buffer[<span class="hljs-number">6</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">48</span>);<br>    buffer[<span class="hljs-number">7</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(value &gt;&gt; <span class="hljs-number">56</span>);<br>}<br><br><span class="hljs-comment">// 解码32位定长整数并返回，这同样不做边界检查</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">DecodeFixed32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(ptr);<br><br>    <span class="hljs-comment">// 注意是小端存储结构</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">0</span>])) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(buffer[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>);<br>}<br><br><span class="hljs-comment">// 解码64位定长整数并返回，与上类似</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">DecodeFixed64</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(ptr);<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">0</span>])) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">4</span>]) &lt;&lt; <span class="hljs-number">32</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">5</span>]) &lt;&lt; <span class="hljs-number">40</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">6</span>]) &lt;&lt; <span class="hljs-number">48</span>) |<br>           (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(buffer[<span class="hljs-number">7</span>]) &lt;&lt; <span class="hljs-number">56</span>);<br>}<br><br><span class="hljs-comment">/*=============编码解码变长整数=============*/</span><br><br><span class="hljs-comment">// 编码32位变长整数</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint32_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 这一部分的编码就是完全按照定义来的，用了5个if</span><br>    <span class="hljs-comment">// 分别对应了1-5个字节范围内的长度</span><br>    <span class="hljs-type">uint8_t</span> *ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>    <span class="hljs-comment">/* 仿照EncodeVarint64的循环写法来重写这一部分</span><br><span class="hljs-comment">    while(v&gt;=B)</span><br><span class="hljs-comment">    {</span><br><span class="hljs-comment">        *(ptr++) = v|B;</span><br><span class="hljs-comment">        v &gt;&gt;= 7;</span><br><span class="hljs-comment">    }</span><br><span class="hljs-comment">    *(ptr++) = static_cast&lt;uint8_t&gt;(v);</span><br><span class="hljs-comment">    return reinterpret_cast&lt;char *&gt;(ptr);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>))<br>    {<br>        *(ptr++) = v;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">7</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">14</span>;<br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">28</span>))<br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">14</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">21</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        *(ptr++) = v | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">7</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">14</span>) | B;<br>        *(ptr++) = (v &gt;&gt; <span class="hljs-number">21</span>) | B;<br>        *(ptr++) = v &gt;&gt; <span class="hljs-number">28</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(ptr);<br>}<br><br><span class="hljs-comment">// 编码64位变长整数，此处没有使用循环，同样的，上面32位的也可以这样写</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 将函数内的常数设置为局部静态变量，减少每次调用函数时的分配与开销</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">uint8_t</span> *ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span> *&gt;(dst);<br>    <span class="hljs-comment">// B被设置成1&lt;&lt;7，当v&gt;=b时表示7位存不下</span><br>    <span class="hljs-keyword">while</span> (v &gt;= B)<br>    {<br>        *(ptr++) = v | B;<br>        v &gt;&gt;= <span class="hljs-number">7</span>;<br>    }<br>    *(ptr++) = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(ptr);<br>}<br><br><span class="hljs-comment">// 解码32位变长整数，这个函数只处理小于128的单字节变长整数</span><br><span class="hljs-comment">// 大于127的部分则调用GetVarint32PtrFallback处理</span><br><span class="hljs-comment">// 此函数将解码后的值放在value中</span><br><span class="hljs-comment">// limit总是为p+5，因为变长整数最多5个字节</span><br><span class="hljs-comment">// p是一个指向包含值得字符串</span><br><span class="hljs-comment">// 返回的是对变长整数解码后的一个字节，设置成这样的目的是用于get方法</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (p &lt; limit)<br>    {<br>        <span class="hljs-type">uint32_t</span> result = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        <span class="hljs-comment">// 内部只解码不超过127的整数，剩下的更长的交给GetVarint32PtrFallback处理</span><br>        <span class="hljs-keyword">if</span> ((result &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span>)<br>        {<br>            *value = result;<br>            <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetVarint32PtrFallback</span>(p, limit, value);<br>}<br><br><span class="hljs-comment">// 解码32位变长整数中大于127的数字，即存储超过1个字节的变长32位整数</span><br><span class="hljs-comment">// 被GetVarint32Ptr调用</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 由于32位变长整数只能由28位存储数字，所以偏移的上限就是28位</span><br>    <span class="hljs-comment">// 每个字节只能存储7位有效字符，所以每处理一字节就偏移7位</span><br>    <span class="hljs-comment">// shift同时也是每个字节中有效数字的权</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">28</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>)<br>    {<br>        <span class="hljs-comment">// 解码出一个字节</span><br>        <span class="hljs-type">uint32_t</span> byte = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        p++;<br>        <span class="hljs-comment">// 判断最高位，如果是1则继续取并执行，否则就返回解码的数据</span><br>        <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>)<br>        {<br>            result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            result |= (byte &lt;&lt; shift);<br>            *value = result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(p);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 当变长整数编码不正确就返回nullptr</span><br>    <span class="hljs-comment">// 不正确的原因只能是因为连续5个字节都是被标记为1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>}<br><br><span class="hljs-comment">// 解码64位变长整数的函数，与解码32位变长的那个函数类似</span><br><span class="hljs-comment">// 不过这个函数没有回调，是直接在本函数内进行全部的解码工作</span><br><span class="hljs-comment">// 原因我觉得是这样的：因为小整数比较多，而小整数一般就以32位变长存储</span><br><span class="hljs-comment">// 而解码最小整数的函数被设置成内联函数，这样效率就会提升很多</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit, <span class="hljs-type">uint64_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint64_t</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这个函数内部与GetVarint32PtrFallback一致</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">63</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>)<br>    {<br>        <span class="hljs-type">uint64_t</span> byte = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *&gt;(p));<br>        p++;<br>        <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>)<br>        {<br>            result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            result |= (byte &lt;&lt; shift);<br>            *value = result;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(p);<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>}<br><br><span class="hljs-comment">/*=============Put与Get方法=============*/</span><br><br><span class="hljs-comment">// 把32位定长转换成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(value)];<br>    <span class="hljs-built_in">EncodeFixed32</span>(buf, value);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, <span class="hljs-built_in">sizeof</span>(buf));<br>}<br><br><span class="hljs-comment">// 把64位定长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置一个缓存区，然后把value编码到缓存区后插入</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(value)];<br>    <span class="hljs-built_in">EncodeFixed64</span>(buf, value);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, <span class="hljs-built_in">sizeof</span>(buf));<br>}<br><br><span class="hljs-comment">// 把32位变长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint32</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint32_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 设置最大的缓冲区，注意EncodeVarint32会返回指向编码后的一个字节的指针</span><br>    <span class="hljs-comment">// 所以就能根据指针偏移来计算出当前变长整数的长度</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">EncodeVarint32</span>(buf, v);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, ptr - buf);<br>}<br><br><span class="hljs-comment">// 把64位变长转化成字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint64</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 原理和PutVarint32一样，只是缓冲区大小大了一些</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">EncodeVarint64</span>(buf, v);<br>    dst-&gt;<span class="hljs-built_in">append</span>(buf, ptr - buf);<br>}<br><br><span class="hljs-comment">// 把slice转化成字符串存储</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutLengthPrefixedSlice</span><span class="hljs-params">(std::string *dst, <span class="hljs-type">const</span> Slice &amp;value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 字符串的编码格式是长度在前，然后是字符串本身</span><br>    <span class="hljs-comment">// 所以按照定义就可以插入了</span><br>    <span class="hljs-comment">// 先插入长度，然后把字符串移动过去</span><br>    <span class="hljs-comment">// 由于Slice末尾不需要'\0'，所以需要指定长度</span><br>    <span class="hljs-built_in">PutVarint32</span>(dst, value.<span class="hljs-built_in">size</span>());<br>    dst-&gt;<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br>}<br><br><span class="hljs-comment">// 计算变长整数的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VarintLength</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> v)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 这个函数思路很简单，不解析了</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (v &gt;= <span class="hljs-number">128</span>)<br>    {<br>        v &gt;&gt;= <span class="hljs-number">7</span>;<br>        len++;<br>    }<br>    <span class="hljs-keyword">return</span> len;<br>}<br><br><span class="hljs-comment">// 从字符串中获取32位变长</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();                   <span class="hljs-comment">// 先拿到字符串的首指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();           <span class="hljs-comment">// 然后获取尾部地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, value); <span class="hljs-comment">//先解码出数据</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-comment">// 所请求元素不合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 由于一个字符串可能内部不止一个整数</span><br>        <span class="hljs-comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span><br>        <span class="hljs-comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span><br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 从字符串中获取64位变长</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint64</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint64_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 同上，只是部分接口不一样</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint64Ptr</span>(p, limit, value);<br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 解码出字符串</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-comment">// 先获取长度，然后根据长度去解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="hljs-built_in">size</span>() &gt;= len)<br>    {<br>        *result = <span class="hljs-built_in">Slice</span>(input-&gt;<span class="hljs-built_in">data</span>(), len);<br>        input-&gt;<span class="hljs-built_in">remove_prefix</span>(len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br><br></code></pre></td></tr></table></figure><p>其中，关于字符串的解码部分我认为还是很巧妙的，因为字符串编码后的长度在前，且长度是一个变长整数，所以解码时需要先提取出长度。正常情况下的写法可能是先对整个编码后字符串遍历，解析出前面的长度，记录下这个字符串长度以及变长整数的长度后再去处理后面的字符串。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic2.png" class=""><p>但是levelDB中的处理方式是让变长解码函数解码多少就把输入中解码的这段数据给弄掉(修改了源字符串的指针)，因为这部分需要解码的值已经被解析出来并返回了，也就不再需要了。</p><img src="/2022/08/30/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4/pic3.png" class=""><p><strong><em>每个解码函数只处理字符串开头，并且处理完成后及时改变字符串的首地址(后移)，这样就不需要记录这部分的状态并考虑处理细节了</em></strong></p><p>能够这样做的原因就是通过传递超尾元素来标定界限，同时所有处理函数都以指针作为数据传递的方式(统一接口标准)。</p><p>而直接移动字符串指针很容易就引出另外一个问题：会不会内存泄漏呢？</p><p>答案是不会，因为内存并不由Slice管理，Slice只是对底层字符串做出了映射而已，其主要目的是用于传递，后续我们会对Slice进行解析。</p><p>再特意把这段代码贴出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice *input, <span class="hljs-type">uint32_t</span> *value)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = input-&gt;<span class="hljs-built_in">data</span>();                   <span class="hljs-comment">// 先拿到字符串的首指针</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *limit = p + input-&gt;<span class="hljs-built_in">size</span>();           <span class="hljs-comment">// 然后获取尾部地址</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *q = <span class="hljs-built_in">GetVarint32Ptr</span>(p, limit, value); <span class="hljs-comment">//先解码出数据，q是超尾元素(相对变长整数而言)</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>    {<br>        <span class="hljs-comment">// 所请求元素不合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 由于一个字符串可能内部不止一个整数</span><br>        <span class="hljs-comment">// 解码完一个整数后可能还剩余一部分未解码的数据</span><br>        <span class="hljs-comment">// 比如字符串存储格式是前面一个32位变长+字符串本身</span><br>        *input = <span class="hljs-built_in">Slice</span>(q, limit - q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice *input, Slice *result)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-comment">// 先获取长度，然后根据长度去解码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVarint32</span>(input, &amp;len) &amp;&amp; input-&gt;<span class="hljs-built_in">size</span>() &gt;= len)<br>    {<br>        *result = <span class="hljs-built_in">Slice</span>(input-&gt;<span class="hljs-built_in">data</span>(), len);<br>        input-&gt;<span class="hljs-built_in">remove_prefix</span>(len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br><br></code></pre></td></tr></table></figure><hr><h2 id="总结部分">总结部分</h2><table><thead><tr class="header"><th style="text-align: center;">函数/变量</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">inline void EncodeFixed32(char *dst,uint32_t value)</td><td style="text-align: center;">编码定长32位整数</td></tr><tr class="even"><td style="text-align: center;">inline void EncodeFixed64(char *dst,uint64_t value)</td><td style="text-align: center;">编码定长64位整数</td></tr><tr class="odd"><td style="text-align: center;">inline uint32_t DecodeFixed32(const char*ptr)</td><td style="text-align: center;">解码32位定长整数</td></tr><tr class="even"><td style="text-align: center;">inline uint64_t DecodeFixed64(const char*ptr)</td><td style="text-align: center;">解码64位定长整数</td></tr><tr class="odd"><td style="text-align: center;">char <em>EncodeVarint32(char </em>dst,uint32_t v)</td><td style="text-align: center;">编码32位变长整数</td></tr><tr class="even"><td style="text-align: center;">char <em>EncodeVarint64(char </em>dst,uint64_t v)</td><td style="text-align: center;">编码64位变长整数</td></tr><tr class="odd"><td style="text-align: center;">inline const char<em>GetVarint32Ptr(const char </em>p, const char <em>limit, uint32_t</em>value)</td><td style="text-align: center;">解码32位变长整数</td></tr><tr class="even"><td style="text-align: center;">const char<em>GetVarint32PtrFallback(const char </em>p, const char<em>limit,uint32_t </em>value)</td><td style="text-align: center;">解码32位变长整数中大于127的数字，被GetVarint32Ptr调用</td></tr><tr class="odd"><td style="text-align: center;">const char <em>GetVarint64Ptr(const char</em>p, const char <em>limit, uint64_t </em>value)</td><td style="text-align: center;">解码64位变长整数的函数</td></tr><tr class="even"><td style="text-align: center;">void PutFixed32(std::string *dst,uint32_t value)</td><td style="text-align: center;">把32位定长转换成字符串</td></tr><tr class="odd"><td style="text-align: center;">void PutFixed64(std::string *dst,uint64_t value)</td><td style="text-align: center;">把64位定长转化成字符串</td></tr><tr class="even"><td style="text-align: center;">void PutVarint32(std::string *dst,uint32_t v)</td><td style="text-align: center;">把32位变长转化成字符串</td></tr><tr class="odd"><td style="text-align: center;">void PutVarint64(std::string *dst,uint64_t v)</td><td style="text-align: center;">把64位变长转化成字符串</td></tr><tr class="even"><td style="text-align: center;">void PutLengthPrefixedSlice(std::string*dst, const Slice &amp;value)</td><td style="text-align: center;">把slice转化成字符串存储</td></tr><tr class="odd"><td style="text-align: center;">int VarintLength(uint64_t v)</td><td style="text-align: center;">计算变长整数的长度</td></tr><tr class="even"><td style="text-align: center;">bool GetVarint32(Slice <em>input,uint32_t </em>value)</td><td style="text-align: center;">从字符串中获取32位变长</td></tr><tr class="odd"><td style="text-align: center;">bool GetVarint64(Slice <em>input,uint64_t </em>value)</td><td style="text-align: center;">从字符串中获取64位变长</td></tr><tr class="even"><td style="text-align: center;">bool GetLengthPrefixedSlice(Slice<em>input, Slice </em>result)</td><td style="text-align: center;">解码出字符串</td></tr></tbody></table><p>编码解码部分使用到了很多位级编程，这部分都很有意思，可以做到四两拨千斤的作用。</p><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><ul><li><p>在函数内需要用到的常量可以定义成内部静态常量<code>static const</code>，这样就避免了全局变量的额外开销与权限混乱、同时也能避免局部变量的每次都需要额外分配的开销。</p></li><li><p>当函数是处理连续的区间时，预留出超尾元素接口是很有必要的。</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(3)--levelDB的内存管理策略</title>
    <link href="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/"/>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/</url>
    
    <content type="html"><![CDATA[<h2 id="leveldb的内存管理策略">levelDB的内存管理策略</h2><span id="more"></span><hr><h3 id="leveldb的内存管理类arena">levelDB的内存管理类Arena</h3><div class="note note-primary">            <p>源代码位置：utils/arena.cc utils/arena.h</p>          </div><p>对于数据库而言，内存管理策略是十分重要的，因为其正是需要为存入的数据分配内存，倘若直接使用new/delete这样每次插入数据都单独去分配内存，效率是很低的，同时由于每条插入的数据的大小并不一致，导致会出现许多的内存碎片。</p><p>对于levelDB这样一个billion级别的数据库，显然其不能采取这样的策略。</p><p>在levelDB中，由于只有<code>MemTable</code>位于内存且需要频繁的插入，所以它最需要内存管理，levelDB中用于内存管理的类为<code>Arena</code>，每个<code>MemTable</code>都绑定一个<code>Arena</code>。而其余的部分则直接使用new/delete，因为这些部分要么是不频繁，要么是块本身就很大。</p><h4 id="arena类">Arena类</h4><div class="note note-info">            <p><strong>基本思想</strong>：先分配出一大块内存，然后当需要用到内存时，就在这一大块内存中移动指针，这样就能解决小块内存频繁调用new和内存碎片的问题，不过缺点是有一部分内存被浪费掉。</p>          </div><p>我们可以先来看一下arena类的头文件捏。从头文件中可以很明显的看到其用于内存分配的方法就是公有函数<code>Allocate</code>和<code>AllocateAligned</code>，区别是后者提供内存对齐，这对效率也有提升。</p><h5 id="头文件">头文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// utils/arena.h</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Arena</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Arena</span>();                                  <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-built_in">Arena</span>(<span class="hljs-type">const</span> Arena &amp;) = <span class="hljs-keyword">delete</span>;            <span class="hljs-comment">//关闭复制构造函数</span><br>    Arena &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Arena &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//关闭使用=的拷贝构造函数</span><br>    ~<span class="hljs-built_in">Arena</span>();                                 <span class="hljs-comment">//析构函数</span><br><br>    <span class="hljs-comment">//返回一个指针指向新分配的内存区域，即内部的分配内存的方法</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>    <span class="hljs-comment">//同Allocate，但是提供了内存对齐策略</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>    <span class="hljs-comment">//返回目前从内存中申请的内存大小，由于memory_usage_是原子操作</span><br>    <span class="hljs-comment">//此处的memory_order_relaxed表示宽松内存序，即任何一个线程可以任意更新</span><br>    <span class="hljs-comment">//不用同步到其他线程中，下一个访问该元素的线程获取到更新之后的值</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">MemoryUsage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">return</span> memory_usage_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;       <span class="hljs-comment">//获取新分配的内存，被AllocateAligned和Allocate调用</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span></span>; <span class="hljs-comment">//new函数的包装，被AllocateFallback调用</span><br><br>    <span class="hljs-type">char</span> *alloc_ptr_;                  <span class="hljs-comment">//当前内存块未使用内存的首地址</span><br>    <span class="hljs-type">size_t</span> alloc_bytes_remaining_;     <span class="hljs-comment">//当前内存块中未使用空间的大小</span><br>    std::vector&lt;<span class="hljs-type">char</span> *&gt; blocks_;       <span class="hljs-comment">//存储每一次向系统请求分配的内存块的指针</span><br>    std::atomic&lt;<span class="hljs-type">size_t</span>&gt; memory_usage_; <span class="hljs-comment">//记录已申请全部内存使用的数目，注意此操作是原子的</span><br>};<br></code></pre></td></tr></table></figure><p>头文件定义了Arena这个类，在类中只有3个公有方法，分别用于返回小内存、对齐的小内存、当前类占用的空间。</p><h5 id="实现文件">实现文件</h5><p>分析完了头文件，我们接下来看一下它的cpp实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">/*=============类的构造析构等基础函数=============*/</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kBlockSize = <span class="hljs-number">4096</span>; <span class="hljs-comment">//一个内存块的大小</span><br><br><span class="hljs-comment">// 构造函数，默认的构造函数直接对内部的几个元素进行初始化</span><br>Arena::<span class="hljs-built_in">Arena</span>()<br>    : <span class="hljs-built_in">alloc_ptr_</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">alloc_bytes_remaining_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">memory_usage_</span>(<span class="hljs-number">0</span>) {}<br><br><span class="hljs-comment">// 析构函数，注意，由于类中存在一个vector数组存储了每次分配的内存的块的指针</span><br><span class="hljs-comment">// 所以析构的时候遍历这个数组然后逐个delete</span><br>Arena::~<span class="hljs-built_in">Arena</span>()<br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; blocks_.<span class="hljs-built_in">size</span>(); i++)<br>    {<br>        <span class="hljs-keyword">delete</span>[] blocks_[i];<br>    }<br>}<br><br><span class="hljs-comment">/*=============公有接口=============*/</span><br><br><span class="hljs-comment">// 分配小内存的函数，这个函数是此类对外的接口，被写成内联函数效率更高</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> *<span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 首先，断言申请的内存数目是否合法</span><br>    <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span><br>    <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_)<br>    {<br>        <span class="hljs-type">char</span> *result = alloc_ptr_;<br>        alloc_ptr_ += bytes;<br>        alloc_bytes_remaining_ -= bytes;<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>    <span class="hljs-comment">// 否则调用AllocateFallback进行分配（从内存中申请空间去分配）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>}<br><br><span class="hljs-comment">// 采用对齐的方式去分配内存，只比Allocate多出计算需要分配内存的步骤</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 首先设置对齐的字节数，(sizeof(void *)可以计算出当前机器的每个指针的字节数</span><br>    <span class="hljs-comment">// 最多8字节对齐，当当前机器指针的字节数不足8字节时，会使用当前机器的字节数</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> align = (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *) &gt; <span class="hljs-number">8</span>) ? <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *) : <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 静态断言，在编译时执行断言</span><br>    <span class="hljs-comment">// a&amp;(a-1)的功能是去掉右边的1(二进制)，所以当不是2的幂次方时，去掉1后就非0</span><br>    <span class="hljs-built_in">static_assert</span>((align &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>,<br>                  <span class="hljs-string">"Pointer size should be a power of 2"</span>);<br><br>    <span class="hljs-comment">// 下面这里的位运算等价于求余运算</span><br>    <span class="hljs-comment">// 因为上面这个断言已经确保了align是2个幂次方，因此align-1是一个右侧均为1的掩模</span><br>    <span class="hljs-comment">// 两者相与的结果就可以快速求出alloc_ptr_%align</span><br>    <span class="hljs-comment">// 但注意，此时两者能够等价的重要原因是align是2的幂次方</span><br>    <span class="hljs-comment">// 此处还有强制类型转换，也就是把取模结果转换成uintptr_t</span><br>    <span class="hljs-type">size_t</span> current_mod = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 当取模结果不是0就表示需要分配的内存是2的整数幂，所以需要额外分配一些内存</span><br>    <span class="hljs-type">size_t</span> slop = (current_mod == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : align - current_mod);<br><br>    <span class="hljs-comment">// 计算出总的需要的内存</span><br>    <span class="hljs-type">size_t</span> needed = bytes + slop;<br><br>    <span class="hljs-comment">/*-------- 至此，计算出需要对齐时分配的内存后，就与Allocate无异 --------*/</span><br><br>    <span class="hljs-type">char</span> *result;<br><br>    <span class="hljs-comment">// 当从内存申请的整块中仍然存在空间时，就直接从这个块中分配</span><br>    <span class="hljs-keyword">if</span> (needed &lt;= alloc_bytes_remaining_)<br>    {<br>        result = alloc_ptr_ + slop;<br>        alloc_ptr_ += needed;<br>        alloc_bytes_remaining_ -= needed;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        <span class="hljs-comment">// 此处存在一点点区别，AllocateFallback申请的参数时bytes而不是对齐后的need</span><br>        <span class="hljs-comment">// 这是因为AllocateFallback调用的是new/delete，总是内存对齐的</span><br>        result = <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>    }<br><br>    <span class="hljs-comment">// 这里再做一下断言，保证对齐</span><br>    <span class="hljs-built_in">assert</span>((<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(result) &amp; (align - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">/*=============私有接口=============*/</span><br><br><span class="hljs-comment">// 私有方法：回调函数，用于当当前块内内存不足时申请内存的策略</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateFallback</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 当需要的内存超过kBlockSize的1/4，（默认1kb时），申请和bytes相同大小的内存</span><br>    <span class="hljs-comment">// 这样做是因为当需要用到的内存已经超过块大小的1/4了，那么之前剩余的块可能还有不少</span><br>    <span class="hljs-comment">// 如果新分配一个块那么就可能会浪费比较多的内存</span><br>    <span class="hljs-keyword">if</span> (bytes &gt; kBlockSize / <span class="hljs-number">4</span>)<br>    {<br>        <span class="hljs-type">char</span> *result = <span class="hljs-built_in">AllocateNewBlock</span>(bytes);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">// 当需要的内存不足kBlockSize的1/4，（默认1kb时），就申请一个整个的块（默认4kb）</span><br>    <span class="hljs-comment">// 然后从这里面分配内存</span><br>    <span class="hljs-comment">// 但注意，进入到此函数里只说明原来的块不足以分配现在需要的内存，但其可能仍然剩余内存</span><br>    <span class="hljs-comment">// 此处的策略是直接把原来的内存块中可能剩余的内存给浪费掉</span><br>    <span class="hljs-comment">// 毕竟此时需要分配的内存不到1/4个块，说明原来的块也剩下不了多少内存了</span><br>    alloc_ptr_ = <span class="hljs-built_in">AllocateNewBlock</span>(kBlockSize);<br><br>    <span class="hljs-comment">// 下面这几部就是分配了一个块后做块内的内存分配</span><br>    alloc_bytes_remaining_ = kBlockSize;<br>    <span class="hljs-type">char</span> *result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>}<br><br><span class="hljs-comment">// 私有方法：向系统申请内存</span><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">Arena::AllocateNewBlock</span><span class="hljs-params">(<span class="hljs-type">size_t</span> block_bytes)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 就是对new的一层包装，同时更新一下类内的参数</span><br>    <span class="hljs-type">char</span> *result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[block_bytes];<br>    blocks_.<span class="hljs-built_in">push_back</span>(result);<br>    memory_usage_.<span class="hljs-built_in">fetch_add</span>(block_bytes + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *),<br>                            std::memory_order_relaxed);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3/pic1.jpg" class=""><p>实际上总体来说思路如下:</p><p>1、当调用<code>AllocateAligned</code>或<code>Allocate</code>时，先判断当前分配内存块中剩余的内存是否有足够的内存去分配新的内存（以及计算内存对齐）；如果足以容纳，则直接从当前内存块中提取内存作为所需内存使用。若是不足以容纳则调用<code>AllocateFallback</code>去申请内存并分配。</p><p>2、在<code>AllocateFallback</code>中，先判断需要申请的内存是否大于1K，若是大于1K，直接<code>AllocateNewBlock</code>向系统申请足够的内存以供使用。若是小于1K，则调用<code>AllocateNewBlock</code>分配一个块，并在这个块中分配需要的内存。</p><p>3、<code>AllocateNewBlock</code>使用系统new操作符向系统申请内存，并更新类内参数。当所分配的内存为4kb时，会将这个申请的内存作为新的内存块(此时旧的内存块中即使还有内存未使用，也不会再拿来使用，因为alloc_ptr_会指向新申请的内存块)。然后再向新申请的内存块提取内存以供使用。</p><p>这里Level对于小于1K的内存申请才向内存池提取内存，主要是连续多次申请小的内存会容易导致内存碎片，影响系统的性能。并且多次的new和delete比较耗时(不断的构造和析构)，会付出额外的空间和时间。</p><hr><h2 id="总结部分">总结部分</h2><table><thead><tr class="header"><th style="text-align: center;">方法/变量</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Arena()</td><td style="text-align: center;">构造函数</td></tr><tr class="even"><td style="text-align: center;">~Arena()</td><td style="text-align: center;">析构函数</td></tr><tr class="odd"><td style="text-align: center;">char* Allocate(size_t bytes)</td><td style="text-align: center;">提供bytes大小的内存</td></tr><tr class="even"><td style="text-align: center;">char* AllocateAligned(size_t bytes)</td><td style="text-align: center;">提供内存对齐的bytes大小的内存</td></tr><tr class="odd"><td style="text-align: center;">size_t MemoryUsage() const</td><td style="text-align: center;">返回当前申请的内存大小</td></tr><tr class="even"><td style="text-align: center;">char* AllocateFallback(size_tbytes)</td><td style="text-align: center;">当块中内存不够时向系统申请内存接口，由Allocate或AllocateAligned调用</td></tr><tr class="odd"><td style="text-align: center;">char* AllocateNewBlock(size_tblock_bytes)</td><td style="text-align: center;">系统new的包装函数，由AllocateFallback调用</td></tr><tr class="even"><td style="text-align: center;">alloc_ptr_</td><td style="text-align: center;">当前内存块中未使用空间的首地址</td></tr><tr class="odd"><td style="text-align: center;">alloc_bytes_remaining_</td><td style="text-align: center;">当前内存块中剩余的空间</td></tr><tr class="even"><td style="text-align: center;">blocks_</td><td style="text-align: center;">new出来的内存的首地址组成的vector数组</td></tr><tr class="odd"><td style="text-align: center;">memory_usage_</td><td style="text-align: center;">向系统已申请的内存大小</td></tr></tbody></table><div class="note note-primary">            <h3 id="编程小技巧">编程小技巧</h3><p><code>a &amp; (a - 1)</code>：去掉a在二进制表示中最右边的1</p><p><code>A &amp; (B - 1) = A % B</code>：此公式仅在B是2的幂次方时成立</p>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(2)--分析levelDB的架构</title>
    <link href="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/"/>
    <url>/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/</url>
    
    <content type="html"><![CDATA[<h2 id="分析leveldb的架构">分析levelDB的架构</h2><span id="more"></span><hr><h3 id="leveldb的组件">levelDB的组件</h3><p>levelDB由以下几个组件组成：<code>MemTable</code>，<code>Immutable MemTable</code>，<code>WAL</code>，<code>SSTable</code>，<code>Manifest</code>，<code>Current</code>，<code>Compaction</code></p><img src="/2022/08/29/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2/pic1.jpg" class=""><div class="note note-primary">            <p><strong><em>MemTable</em></strong>：这个组件是操作的入口，是常驻内存的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>树，所有的写入操作都将被直接写入到此树中。另外这棵树是有序的，可以对其进行快速查找和遍历，也支持数据库的操作。</p><p>它本身就可以看成是一个数据库，相当于levelDB内置的redis。</p><p>当其占用空间到达一个阈值时，就转换成一个<code>Immutable MemTable</code>供后续合并，同时生成一个新的<code>MemTable</code>来继续执行下去。</p>          </div><div class="note note-primary">            <p><strong><em>ImmutableMemTable</em></strong>：这个组件是内存与磁盘的交互组件。它与<code>MemTable</code>完全一样，仅仅在于其是只读结构。</p><p>当生成<code>Immutable MemTable</code>后，后台线程会将其创建出一个<code>SSTable</code>，并归并到磁盘中。</p>          </div><div class="note note-primary">            <p><strong><em>WAL</em></strong>：即write aheadlog，在写入到数据库之前，先写入到日志文件。</p><p>这样做的目的是为了不丢失数据，由于<code>MemTable</code>位于内存中，写入一些数据后，其不能立刻同步到磁盘中，如果突然掉电，这样写入的数据就丢失了。而<code>WAL</code>位于磁盘中，不过由于日志结构是顺序写，因此其写入效率也是很高的。</p><p>每次数据库重启时都需要读取日志并进行恢复，如果日志结构太大，启动数据库的速度就会很慢。</p>          </div><div class="note note-primary">            <p><strong><em>SSTable</em></strong>：即Sorted StringTable。这是比较重要的结构，虽然数据库的读写是基于<code>MemTable</code>的，但是其位于内存中，内存不是无限大的，需要被持久化到磁盘中。当创建出<code>Immutable MemTable</code>后，就会对其创建出一个<code>SSTable</code>来保存数据到磁盘上。</p><p>其有序体现在键是有序的，同时各级的<code>SSTable</code>文件之间也是有序的，即键不重叠。这样做的目的是为了保持良好的读速度。由于levelDB不需要更新磁盘数据结构，因此不需要使用B+树。当数据存储在磁盘上键有序，这样就可以使用高效的二分查找；而键不重叠则避免二分查找读多个磁盘块。</p><p>同时，将<code>MemTable</code>写入到磁盘上的<code>SSTable</code>后就可以释放掉这部分的日志空间，减少下次启动时的恢复速度。</p><p>但是当<code>SSTable</code>数目变多时，可能会导致键的范围出现重叠，这时候可以进行合并，将多个小的<code>SSTable</code>合并成一个大的，由于<code>SSTable</code>是有序的，其合并速度也是十分的快。</p>          </div><div class="note note-primary">            <p><strong><em>Manifest</em></strong>：LevelDB中有版本Version的概念，一个版本Version主要记录了每一层Level中所有文件的元数据。随着Compaction的进行，元数据会改变，所以每次还需要将改变的元数据写到MANIFEST中。</p>          </div><div class="note note-primary">            <p><strong><em>Current</em></strong>：本文件指向当前的<code>Manifest</code>文件，由于可能存在多个<code>Manifest</code>文件，<code>Current</code>文件指向我们当前需要用到的<code>Manifest</code>文件。</p>          </div><div class="note note-primary">            <p><strong><em>Compaction</em></strong>：作用是将多个小的<code>SSTable</code>合并成一个大的<code>SSTable</code>。这样可以解决查找的效率问题。</p><p>每个大的<code>SSTable</code>是键有序的，可以将其再次分成多个小的键不重叠的<code>SSTable</code>，这样每次合并时只需要合并小的<code>SSTable</code>即可，而不需要去读取一个很大的<code>SSTable</code>。</p><p>另外，由于<code>level-0</code>是直接由内存写入的，其多个<code>SSTable</code>可能存在键重叠现象，但是更高层的<code>level</code>是不存在键重叠现象的。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TODO</title>
    <link href="/2022/08/28/TODO/"/>
    <url>/2022/08/28/TODO/</url>
    
    <content type="html"><![CDATA[<p>博客补全计划...</p><span id="more"></span><p>目前，本博客刚刚建成，因此后续打算将之前的笔记转移到此博客上，从而形成一个比较集中的管理。</p><h5 id="高优先级部分">高优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">levelDB源码剖析</li><li><input type="checkbox" disabled="">python技巧系列</li><li><input type="checkbox" disabled="">CUDA开发</li><li><input type="checkbox" disabled="">小工具的源码剖析</li><li><input type="checkbox" disabled="">3D视觉</li></ul><h5 id="中优先级部分">中优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">SICP读书笔记转移</li><li><input type="checkbox" disabled="">CSAPP笔记转移</li><li><input type="checkbox" disabled="">OpenCV源码剖析</li><li><input type="checkbox" disabled="">一些的工具使用与开发</li></ul><h5 id="低优先级部分">低优先级部分</h5><ul class="task-list"><li><input type="checkbox" disabled="">机器学习中的笔记</li><li><input type="checkbox" disabled="">python爬虫部分，涉及xpath、re、scrapy、selenium、splash、代理池等等</li><li><input type="checkbox" disabled="">计算机网络部分笔记</li><li><input type="checkbox" disabled="">Notability上的手写笔记转成md格式存储</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>levelDB源码剖析(1)--概述levelDB项目结构</title>
    <link href="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/"/>
    <url>/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/</url>
    
    <content type="html"><![CDATA[<h2 id="概述leveldb项目结构">概述levelDB项目结构</h2><span id="more"></span><hr><p><em><a href="https://zhuanlan.zhihu.com/p/203578801">参考1</a></em></p><p><em><a href="https://zhuanlan.zhihu.com/p/436037845">参考2</a></em></p><p><em><a href="https://github.com/google/leveldb">项目地址</a></em></p><hr><h3 id="leveldb项目概述">levelDB项目概述</h3><p>levelDB是一个持久化<code>kv</code>存储数据库，<code>kv</code>均为任意的字节数组。</p><p>其随机写、顺序写/读的性能很高，但是随机读的性能一般。</p><h4 id="lsm-tree">LSM Tree</h4><p>其实现原理为<code>LSM Tree</code>，简单来说就是讲磁盘的随机写转换成顺序写.</p><p>由于磁盘的寻址非常耗时，因此顺序写的速度远远超过随机写.</p><p><code>LSM Tree</code>由两部分组成分别是<code>Log structed</code>和<code>Merge Tree</code>.</p><p>其中<code>Log structed</code>是日志结构，而日志本身是不会修改的，只需要追加写.</p><p><code>Merge Tree</code>是合并树，即将多个树合并成一个更大的树.</p><p><em>所以，<code>LSM Tree</code>是数据以追加写的方式写入文件，成为一颗小树，然后合并成更大的树.</em></p><p>在<code>LSM Tree</code>中，<strong>更新一个数据不需要修改过去的旧数据</strong>，但是此时，<br>其写的性能很强大，但是需要支付额外的存储空间来作为代价。为了同步提升其读的性能，levelDB也同样支付了一些存储空间作为读性能提升的代价。</p><p>具体而言，将索引树结构拆分成多个大小逐渐变大的结构<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>，其均为有序的。</p><p>最小的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>位于内存，是所有操作数据的落脚点，保存了最近写入的kv，其也可以随时原地更新，支持随时查询。</p><img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic1.jpg" class=""><p>其余的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>均位于磁盘中，但是每棵树也是有序的。</p><p><strong><em>当执行写操作时</em></strong>：首先将数据加入到<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层索引树中，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>层数据大小达到一定程度时，会执行<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>与<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>层的合并。由于两者均为有序的，所以这个过程类似一个归并，而归并这个操作只需要用到有序写，合并出来的新的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>会取代掉旧的<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>，当<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>到达指定大小后，也会同样向后合并。</p><img src="/2022/08/28/levelDB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1/pic2.jpg" class=""><p><strong><em>当执行读操作时</em></strong>：在<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 1151.6 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container></span>、<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></span>...<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.765ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1222.3 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>中逐层查找，直到找到为止，因此，即使数据没有更新到较高的层中，也不影响数据的正确性。</p><p>当然，levelDB具体的实现还是存在一些细节的。</p><hr><h3 id="leveldb的项目结构">levelDB的项目结构</h3><h4 id="一些头文件及其作用">一些头文件及其作用</h4><p><code>include</code>: 函数库的头文件</p><p><code>port</code>: 可移植性相关的功能</p><p><code>util</code>: 项目用到的一些功能函数</p><p><code>table</code>: SSTable的实现</p><p><code>helpers/memenv</code>：简单完全内存的文件系统，提供操作目录文件接口</p><p><code>benchmarks</code>：性能测试相关代码</p><p><code>db</code>:数据库实现，版本管理，Compaction，WAL和MemTable实现</p><h4 id="接口文件的对应功能">接口文件的对应功能</h4><p><code>cache.h</code>:缓存接口，提供了默认的LRU缓存，也可以自己实现缓存</p><p><code>comparator.h</code>:定以数据库比较器的接口，用来比较键，可以使用默认的基于字节的比较，可以定义自己的比较器</p><p><code>dumpfile.h</code>: 以可读文本形式导出一个文件，调试使用</p><p><code>export.h</code>: 可移植性相关</p><p><code>iterator.h</code>: 迭代器接口</p><p><code>slice.h</code>: 实现一个字符串，存储指针和长度，指向字符串</p><p><code>table_builder.h</code>: 构造一个SSTable</p><p><code>write_batch.h</code>: 实现批量写入的接口</p><p><code>c.h</code>: 实现C语言相关的接口</p><p><code>db.h</code>: 操作数据库的主要接口</p><p><code>env.h</code>: 定义操作系统相关的功能，如读写文件之类的</p><p><code>filter_policy.h</code>: 定义布隆过滤器接口</p><p><code>options.h</code>: 配置选项</p><p><code>status.h</code>: 定义数据库操作的返回状态</p><p><code>table.h</code>: SSTable相关的接口</p>]]></content>
    
    
    <categories>
      
      <category>levelDB源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>levelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
